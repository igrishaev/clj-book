\chapter{Системы}

\label{chapter-systems}

\index{системы}

\begin{teaser}
В этой главе мы поговорим о системах. Так называют набор компонентов со связями
между ними. Рассмотрим, как большие проекты складываются из малых частей; как
победить сложность и заставить части работать как одно целое.
\end{teaser}

Понятие системы связано с конфигурацией, которую мы только что обсудили. Отличие
в том, что конфигурация отвечает на вопрос, как \emph{получить} параметры, а
система знает, как ими \emph{распорядиться}.

Системы появились, когда возник спрос на долгоиграющие приложения. Для скриптов
и утилит вопрос не стоял остро: их время работы коротко, и состояние живет
недолго. При завершении ресурсы освобождаются, поэтому нет смысла в контроле за
ними.

С серверными приложениями всё по-дру\-го\-му: они работают постоянно и поэтому
устроены иначе, чем скрипты. Приложение состоит из компонентов, которые работают
в фоне. Каждый компонент выполняет узкую задачу. При запуске приложение включает
компоненты в~правильном порядке и строит между ними связи.

\section{Подробнее о системе}

\index{состояние}

Компонент~--- это объект, который несёт состояние. На него действуют операции
<<включить>> и <<выключить>>. Как правило, включить компонент означает открыть
ресурс, а выключить~--- закрыть его.

\index{граф зависимостей}

Типичные компоненты приложения~--- это сервер, база данных, кэш. Чтобы не открывать
соединение на каждый запрос к базе, понадобится пул соединений. Не хотелось бы
создавать его вручную и передавать в функции JDBC. Должен быть компонент,
который при включении открывает пул и хранит его. Потребителям компонент
предлагает методы для работы с базой. Внутри они используют открытый пул.

\index{ООП}

На первый взгляд, схема напоминает ООП и инкапсуляцию. Не торопитесь с выводами:
компоненты в Clojure работают иначе. Ниже мы рассмотрим разницу между объектами
и компонентами.

\subsection{Зависимости}

Главная точка системы~--- это зависимости компонентов. Сервер, база и~кэш не зависят
друг от друга. Это базовые компоненты системы, на которые опираются другие,
уровнем выше. Предположим, фоновый поток читает базу и отправляет письма. Будет
неправильно, если компонент откроет новые подключения к базе и почте. Вместо
этого он принимает включённые компоненты и работает с ними как с чёрным ящиком.

Система запускает и останавливает компоненты в верном порядке. Если компонент A
зависит от B и C, то к моменту запуска A последние два должны быть включены. При
завершении компоненты B и C нельзя выключить до тех пор, пока работает~A, потому
что это нарушит его работу. Система строит граф зависимостей между
компонентами. Граф обходят так, чтобы удовлетворить всех участников.

В систему должно быть легко добавить новый компонент. В идеальном случае система~---
это комбинация словарей и списков. Код загрузки пробегает по ним и включает
компоненты. Расширить систему означает добавить новый узел в дерево.

Когда система знает о зависимостях, можно включить её подмножество. Представим,
нужно отладить обработчик почты, который зависит от базы и
SMTP-сервера. Веб-сервер и кэш в данном случае не нужны, и запуск всей системы
избыточен. Продвинутые системы предлагают функцию с семантикой <<запусти этот
компонент и его зависимости>>.

\subsection{Преимущества}

На первый взгляд кажется, что система~--- лишнее усложнение. Это новая
библиотека, соглашения в команде и рефакторинг. Однако первичные неудобства
окупаются со временем.

Система приводит проект в порядок. С ростом кодовой базы становится важно, чтобы
части проекта были в одном стиле. Если этому следовать, служебные компоненты
уйдут в библиотеки, а в проекте останется только логика. Проще начать проект,
когда под рукой база внутренних компонентов, испытанных в бою.

Системы полезны на всех стадиях производства, особенно тестировании. В тестах
запускают систему, где некоторые компоненты работают по-другому. Например,
отправитель СМС пишет сообщения в файл или атом. Компонент авторизации читает
код подтверждения из этих источников. Подход не гарантирует полной надёжности,
но выполнит тесты изолировано, без обращения к~сторонним сервисам. Проблему
изоляции мы рассмотрим в~главе про тесты \page{test-isolation}.

\section{Подготовка к обзору}

\index{переменные!глобальные}
\index{clojure.core!alter-var-root}

В главе об изменяемых данных мы упоминали системы \page{systems-intro}. Способ
работает на \verb|alter-var-root| и глобальных переменных. Идея в том, чтобы
вынести компонент в модуль и снабдить функциями \verb|start!| и
\verb|stop!|, которые переключают состояние модуля. Запуск системы сводится к
их вызову в верном порядке.

Это любительское решение, потому что система не знает о зависимостях между
компонентами. Она хрупкая, работает в ручном режиме, и каждое изменение требует
проверки.

Clojure предлагает несколько библиотек для систем. Мы рассмотрим Mount,
Component и Integrant. Библиотеки различаются подходом: они по-разному описывают
компоненты и зависимости. Так мы рассмотрим проблему с разных сторон.

Библиотеки нарочно следуют в таком порядке. Mount устроен проще, поэтому начнём
с него в качестве знакомства с темой. Component стал промышленным
стандартом. Уделим ему больше внимания и поэтому ставим в середину. Integrant
замыкает обзор: его рассматривают как альтернативу Component, с которым читатель
должен быть знаком.

Наша система похожа на то, с чем вы столкнётесь на практике. Она состоит из
веб-сервера, базы данных и воркера~--- фоновой задачи, которая обновляет записи
в базе. Мы добавили его специально, чтобы научиться работать с
зависимостями. Чтобы лучше понять систему, нарисуем её топологию \fig{fig:chart-system}.

\begin{figure}[ht!]
  \chart{chart-sys-1}
  \caption{Схема будущей системы с зависимостями}
  \label{fig:chart-system}
\end{figure}

Стрелки означают отношения между компонентами. Выражение A~\arr~B означает
<<А зависит от В>>. В нашей схеме все компоненты зависят от конфигурации.
Дополнительно фоновый обработчик нуждается в базе данных. Над этой
системой мы будем работать до конца главы.

\subsection{База и воркер}

Мы упоминали, что открывать соединение на каждый запрос не оптимально. В
настоящих проектах с базой работают через пул. Это сущность с состоянием,
поэтому его тоже включают и выключают.

\index{базы данных!SQLite}

Базы вроде SQLite и H2 хранят данные в памяти. Это удобно для быстрого старта,
но не отражает реалии производства~--- то, к чему мы стремимся в этой книге. Для
in-memory баз не используют пулы соединений, потому что данные в памяти, а не в
сети. Будем работать с реляционной БД PostgreSQL и пулом HikariCP.

Фоновый процесс (или воркер) дополняет записи в базе информацией из
сети. Предположим, фирма ведёт аналитику посещений сайта. Когда кто-то открывает
страницу, приложение сохраняет URL и IP-адрес клиента. Чтобы строить отчёты по
странам и городам, нужно получить геоданные по IP из сторонних сервисов. Это
долгая операция, поэтому записи ставят флаг <<в обработке>> и выносят логику
в фон.

\subsection{Docker}

\index{Docker}

\label{docker-db}

Если у вас установлен PostgreSQL, создайте новую базу и таблицу в ней. Если нет,
самое время попробовать Docker. Это программа для запуска приложений из
образов. Под образом понимают специальный файл, в котором упаковано приложение
со всем необходимым для запуска. Запущенный образ называют контейнером.

У контейнеров несколько преимуществ. Приложение живёт в изолированной среде и
поэтому отделено от основной системы. Кроме безопасности, это решает проблему
\emph{чистоты}~--- контейнер не оставляет следов работы, если это не задано
специально.

Docker ищет образы в открытом репозитории. В нём публикуют программы разных
версий и комплектации. Если нужен PostgreSQL версии строго 9.3, скачайте образ с
этим тегом. Установка этой версии в~систему, скорее всего, обернётся конфликтом
с уже работающей базой.

\mnoindent
Некоторые образы можно настроить переменными среды или файлами. Образ PostgreSQL
устроен так, что при старте он загружает все \verb|*.sql| файлы из папки
\texttt{/docker-entrypoint\--initdb.d}. Если сопоставить ей локальный путь с
миграциями, получим готовую базу. При этом мы не написали ни строчки кода,
а~только указали настройки.

\index{утилиты!docker-compose}

В комплекте с Docker идёт утилита \texttt{docker\--compose}. Она запускает
контейнер из файла конфигурации. По умолчанию файл называется
\verb|docker-compose.yaml|. Это YAML-документ, где указаны образ и параметры
запуска. Мы задали образ \verb|postgres| и его опции: порт, файловые пути и
переменные среды.

\index{форматы!YAML}

\ifx\devicetype\mobile

\begin{english}
  \begin{yaml}
version: '2'
services:
  postgres:
    image: postgres
    volumes:
      - ./initdb.d:/docker-entrypoint-
                                initdb.d
    ports:
      - 5432:5432
    environment:
      POSTGRES_DB: book
      POSTGRES_USER: book
      POSTGRES_PASSWORD: book
  \end{yaml}
\end{english}

\else

\begin{english}
  \begin{yaml}
version: '2'
services:
  postgres:
    image: postgres
    volumes:
      - ./initdb.d:/docker-entrypoint-initdb.d
    ports:
      - 5432:5432
    environment:
      POSTGRES_DB: book
      POSTGRES_USER: book
      POSTGRES_PASSWORD: book
  \end{yaml}
\end{english}

\fi

\mnoindent
В папке \verb|initdb.d| находятся SQL-файлы для старта базы. Достаточно файла
\verb|01.init.sql| с таблицей:

\index{языки!SQL}

\ifx\devicetype\mobile

\begin{english}
  \begin{sql}
drop table if exists requests;
create table requests (
    id            serial primary key,
    path          text not null,
    ip            inet not null,
    is_processed  boolean not null
                  default false,
    zip           text,
    country       text,
    city          text,
    lat           float,
    lon           float
);
  \end{sql}
\end{english}

\else

\begin{english}
  \begin{sql}
drop table if exists requests;
create table requests (
    id            serial primary key,
    path          text not null,
    ip            inet not null,
    is_processed  boolean not null default false,
    zip           text,
    country       text,
    city          text,
    lat           float,
    lon           float
);
  \end{sql}
\end{english}

\fi

Если запустить \verb|docker-compose up|, поднимется сервер PostgreSQL на порту
5432 с базой \verb|book|. Этого хватит для дальнейшей работы. Больше мы не
будем говорить о Docker, поскольку это тема отдельной книги. Все детали вы
найдёте \footurl{на сайте проекта}{https://docker.com}[Docker][-10mm].

\section{Mount}

\index{библиотеки!Mount}

Библиотека \footurl{Mount}{https://github.com/tolitius/mount}[Mount][1mm] описывает сущность с
двумя состояниями: запуск и остановка. По команде она <<включается>> и принимает
значение, которое вернул код запуска. При выключении сработает код
остановки. Сущность похожа на глобальную переменную, которая меняется по
команде. Mount прост, поэтому подойдёт начинающим. С него мы начнём
практическую часть.

\subsection{Первая сущность}

\index{макросы!defstate}

Макрос \verb|defstate| задаёт новую сущность. Он напоминает \verb|def|,
потому что объявляет переменную в текущем пространстве. Разница в том, что
вместо значения \verb|defstate| принимает код запуска и остановки.

Добавьте в проект зависимость Mount. С помощью макроса опишем компонент
веб-сервера. Поместим его в модуль \verb|server.clj|. Функция \verb|app|~--- это
примитивное приложение, которое вернёт статус 200 на все запросы.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; project.clj
:dependencies [... [mount "0.1.16"]]

;; server.clj
(ns book.systems.mount.server
  (:require
   [mount.core :as mount
    :refer [defstate]]
   [ring.adapter.jetty
    :refer [run-jetty]]))

(def app (constantly
           {:status 200 :body "Hello"}))

(defstate server
  :start (run-jetty app
           {:join? false :port 8080})
  :stop (.stop server))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
;; project.clj
:dependencies [... [mount "0.1.16"]]

;; server.clj
(ns book.systems.mount.server
  (:require
   [mount.core :as mount :refer [defstate]]
   [ring.adapter.jetty :refer [run-jetty]]))

(def app (constantly {:status 200 :body "Hello"}))

(defstate server
  :start (run-jetty app {:join? false :port 8080})
  :stop (.stop server))
  \end{clojure}
\end{english}

\fi

Пока что мы только объявили состояние, но ничего не включили. Если выполнить
\verb|server|, увидим следующее:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
#DerefableState[{:status :pending
                 :val nil}]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
#DerefableState[{:status :pending, :val nil}]
  \end{clojure}
\end{english}

\fi

\mnoindent
Чтобы запустить компонент, выполните \texttt{(mount\-/start)}. Функция пробегает
по компонентам и включает их. Выражение \verb|(run-jetty ...)| под ключом
\verb|:start| вернёт сервер, который работает в фоне. После запуска браузер
покажет приветствие по адресу \verb|http://127.0.0.1:8080|. Переменная
\verb|server| станет экземпляром \verb|Server| из пакета \verb|jetty|:

\begin{english}
  \begin{clojure}
(type server)
;; org.eclipse.jetty.server.Server
  \end{clojure}
\end{english}

Чтобы выключить систему, выполните \verb|(mount/stop)|. Обратите внимание, что
в выражении \verb|(.stop server)| сущность обращается к~самой себе. После
остановки \verb|server| станет значением, которое означает завершение.

\begin{english}
  \begin{clojure}
(mount/stop)
(type server)
;; mount.core.NotStartedState
  \end{clojure}
\end{english}

Так строят систему. Сперва находят сущности, которые работают на протяжении всей
программы. В основном это сетевые подключения и фоновые задачи. Затем объявляют
компонент с логикой запуска и~остановки.

\subsection{Связь с конфигурацией}

Выше мы допустили ошибку: параметры сервера <<захардкожены>> в~компоненте. Мы
уже обсудили, чем это плохо; параметры должны быть в
конфигурации \page{hardcode}. Поскольку у нас система, вынесем конфигурацию
в~компонент.

\index{конфигурация!в Mount}

Сущность \verb|config|~--- это упрощённый загрузчик конфигурации. Для краткости
опустим перехват ошибок и другие детали. Фаза \verb|:start| читает файл
EDN. Замените \texttt{edn/read\--string}| на Yummy, Aero или своё
решение. Компоненту не нужна фаза \verb|:stop|, потому что он не хранит
состояние.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defstate config
  :start
  (-> "system.config.edn"
      slurp
      edn/read-string))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defstate config
  :start
  (-> "system.config.edn" slurp edn/read-string))
  \end{clojure}
\end{english}

\fi

В файле \verb|system.config.edn| записан словарь, где ключ~--- это имя компонента, а
значение~--- параметры. Поместим сервер под ключ \verb|:jetty|:

\begin{english}
  \begin{clojure}
{:jetty {:join? false :port 8088}}
  \end{clojure}
\end{english}

\index{зависимости!Mount}

Улучшим сервер так, чтобы он зависел от конфигурации. В список \verb|:require|
модуля добавим компонент \verb|config|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.mount.server
 (:require
  [book.systems.mount.config
   :refer [config]]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.mount.server
 (:require
  [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

\fi

\noindent
Перепишем сервер, чтобы он читал конфигурацию:

\begin{english}
  \begin{clojure}
(defstate server
  :start
  (let [{jetty-opt :jetty} config]
    (run-jetty app jetty-opt))
  :stop (.stop server))
  \end{clojure}
\end{english}

Получилась система из двух компонентов, где один зависит от другого. Убедитесь,
что после вызова \verb|(mount/start)| сервер работает как ожидалось.

\subsection{База данных}

\index{библиотеки!JDBC}
\index{библиотеки!HikariCP}

Подготовим компонент базы данных. Понадобятся библиотеки
\footurl{JDBC}{https://github.com/clojure/java.jdbc}[JDBC][1mm] и
\footurl{HikariCP}{https://github.com/tomekw/hikari-cp}[HikariCP][20mm]. Первая предлагает доступ
к реляционным базам данных. Это набор функций, которые работают одинаково для
разных баз. Выражения:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(jdbc/get-by-id db :users 42)
(jdbc/insert! db :users
  {:name "Ivan" :email "ivan@test.com"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(jdbc/get-by-id db :users 42)
(jdbc/insert! db :users {:name "Ivan" :email "ivan@test.com"})
  \end{clojure}
\end{english}

\fi

\noindent
прочитают и запишут пользователя в Postgre\-SQL, MySQL или Oracle. Для каждого
бекэнда JDBC строит запрос с учётом его особенностей.

\index{JDBC!спека}

Функции JDBC принимают первым параметром \emph{JDBC-спеку}. Обычно это словарь
подключения: адрес и порт сервера, имя базы, пользователь и пароль. На каждый
запрос JDBC открывает соединение, обменивается данными и закрывает его.

В спеке может быть ключ \verb|:datasource| с готовым источником данных. Тогда
JDBC игнорирует другие ключи и работает напрямую с~\verb|:datasource|. HikariCP
предлагает функцию, чтобы построить источник с пулом соединений. Каждый раз,
когда мы запросим соединение у источника, получим одно из открытых ранее.

\index{JDBC!datasource}

Источник хранит состояние, поэтому вынесем его в компонент. Подготовим модуль
\verb|db.clj|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.mount.db
  (:require
   [mount.core :as mount
    :refer [defstate]]
   [hikari-cp.core :as cp]
   [book.systems.mount.config
    :refer [config]]))

(defstate db
  :start
  (let [{pool-opt :pool} config
        store (cp/make-datasource
                pool-opt)]
    {:datasource store})
  :stop
  (-> db
      :datasource
      cp/close-datasource))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.mount.db
  (:require
   [mount.core :as mount :refer [defstate]]
   [hikari-cp.core :as cp]
   [book.systems.mount.config :refer [config]]))

(defstate db
  :start
  (let [{pool-opt :pool} config
        store (cp/make-datasource pool-opt)]
    {:datasource store})
  :stop
  (-> db :datasource cp/close-datasource))
  \end{clojure}
\end{english}

\fi

\index{пул соединений}

Код старта вернёт JDBC-спеку~--- словарь с ключом \verb|:datasource|, внутри
которого пул. При выключении функция \verb|close-datasource| закрывает его и
открытые соединения. Добавим в конфигурацию настройки пула:

\begin{english}
  \begin{clojure}
{:pool {:minimum-idle       10
        :maximum-pool-size  10
        :adapter            "postgresql"
        :username           "book"
        :password           "book"
        :database-name      "book"
        :server-name        "127.0.0.1"
        :port-number        5432}}
  \end{clojure}
\end{english}

Для экономии укажем только основные параметры. Это свойства подключения (хост,
порт, пользователь, пароль) и размерность пула. При желании можно настроить
тайминги соединений: время простоя, соединения и другие. Полный список опций
смотрите на странице проекта в GitHub.

Запустите систему и выполните запрос:

\begin{english}
  \begin{clojure}
(mount/start)
(require '[clojure.java.jdbc :as jdbc])
(jdbc/query db "select 1 as number")
;; ({:number 1})
  \end{clojure}
\end{english}

\subsection{Фоновая задача}

\label{worker}

Всё готово для последнего компонента системы. Это воркер, который работает в
отдельном потоке. Он выбирает из базы сырые записи и~дополняет полями из
стороннего сервиса.

Таблица \verb|requests| хранит адрес страницы и IP клиента. Флаг
\verb|is_processed| определяет, была ли уже обработана запись. Поля \verb|city|,
\verb|country| и другие по умолчанию равны \verb|NULL|.

\index{null!в SQL}

Цикл воркера состоит из шагов:

\begin{itemize}

\item
  раз в интервал выбрать запись с флагом \verb|NOT is_processed|;

\item
  сделать запрос к сервису, который вернёт геоданные по IP;

\item
  обновить запись в транзакции.

\end{itemize}

Выразим воркер в терминах Mount. Задача работает в отдельном потоке, поэтому
нужен тред или футура с бесконечным циклом. Чтобы остановить воркер по запросу,
цикл должен быть с условием~--- проверкой флага на каждом шаге. Флаг доступен и
воркеру, и тому, кто им управляет.

\index{футуры!реализация}

В Clojure это решается футурой и атомом. В атоме хранят флаг~--- признак
продолжения цикла. На каждом шаге футура <<дерефит>> атом, и если он истина,
выполняет задачу. Чтобы завершить футуру, совершают два действия. Первое~---
возводят флаг в ложь. Второе~--- ждут до тех пор, пока футура не станет
\emph{реализованной} \eng{realized}. В терминах Clojure это значит, что
исполнитель (executor) выполнил задание и передал футуре ответ.

Подготовим модуль воркера. Понадобится конфигурация, база данных, логирование и
HTTP-клиент:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.mount.worker
  (:require
   [clojure.java.jdbc :as jdbc]
   [clj-http.client :as client]
   [clojure.tools.logging :as log]
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config
    :refer [config]]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.mount.worker
  (:require
   [clojure.java.jdbc :as jdbc]
   [clj-http.client :as client]
   [clojure.tools.logging :as log]
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

\fi

Воркер~--- это словарь с полями \verb|:flag| и \verb|:task|, состояние и
футура. Фаза \verb|:start| готовит этот словарь. Функции \verb|make-task|
пока что не существует, но считаем, что она вернёт футуру. В фазе \verb|:stop|
флаг становится ложью, и мы ждём, пока футура не остановится.

\index{clojure.core!realized?}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defstate worker
  :start
  (let [{task-opt :worker} config
        flag (atom true)
        task (make-task flag task-opt)]
    {:flag flag :task task})
  :stop
  (let [{:keys [flag task]} worker]
    (reset! flag false)
    (while (not (realized? task))
      (log/info
      "Waiting for the task
                to complete")
      (Thread/sleep 300))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defstate worker
  :start
  (let [{task-opt :worker} config
        flag (atom true)
        task (make-task flag task-opt)]
    {:flag flag :task task})
  :stop
  (let [{:keys [flag task]} worker]
    (reset! flag false)
    (while (not (realized? task))
      (log/info "Waiting for the task to complete")
      (Thread/sleep 300))))
  \end{clojure}
\end{english}

\fi

Код \verb|:start| и \verb|:stop| должен быть небольшим. Чтобы упростить его,
технические шаги выносят в функции. Если этого не сделать, логику запуска и
остановки будет трудно понять.

Добавим в файл EDN параметры воркера. Нужно одно поле~--- сколько миллисекунд
ждать в промежутках между обработкой записи.

\begin{english}
  \begin{clojure}
{:worker {:sleep 1000}}
  \end{clojure}
\end{english}

\index{функции!make-task}

Опишем функцию \verb|make-task|. Она принимает атом с флагом и~параметры
EDN. Функция вернёт футуру с циклом:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines}
(defn make-task
  [flag opt]
  (let [{:keys [sleep]} opt]
    (future
      (while @flag
        (try
          (task-fn)
          (catch Throwable e
            (log/error e))
          (finally
            (Thread/sleep
              sleep)))))))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(defn make-task
  [flag opt]
  (let [{:keys [sleep]} opt]
    (future
      (while @flag
        (try
          (task-fn)
          (catch Throwable e
            (log/error e))
          (finally
            (Thread/sleep sleep)))))))
  \end{clojure/lines}
\end{english}

\fi

Функция \verb|task-fn| выполняет бизнес-логику приложения \coderef{7}. Её
оборачивают в \verb|try/catch|, чтобы футура не завершилась аварийно. Если
поймали исключение, пишем его в лог. В конце итерации небольшая задержка, чтобы
не обрушить на базу шквал запросов \coderef{11}. Если кто-то установит
\verb|flag| в ложь, управление выйдет из \verb|while| и~футура завершится.

Теперь опишем \verb|task-fn|. Функция читает из базы одну запись, которая
ждёт обработки. С помощью функции \verb|get-ip-info| ищем геоданные по
IP. Пока что мы не знаем, как работает поиск, но известно, что он вернёт словарь
с полями \verb|:city|, \verb|:country| и другими.

\index{транзакции}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines}
(defn task-fn []
 (jdbc/with-db-transaction [tx db]
  (when-let [request
             (first
              (jdbc/query tx query))]
    (let [{:keys [id ip]} request
          info   (get-ip-info ip)
          {zip :postal_code
           country country_name
           city :city lat :lat
           lon :lng} info
          fields {:is_processed true
                  :zip zip
                  :country country
                  :city city
                  :lat lat
                  :lon lon}]
      (jdbc/update! tx :requests
        fields ["id = ?" id])))))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(defn task-fn []
  (jdbc/with-db-transaction [tx db]
    (when-let [request (first (jdbc/query tx query))]
      (let [{:keys [id ip]} request
            info   (get-ip-info ip)
            fields {:is_processed true
                    :zip (:postal_code info)
                    :country (:country_name info)
                    :city (:city info)
                    :lat (:lat info)
                    :lon (:lng info)}]
        (jdbc/update! tx :requests
                      fields
                      ["id = ?" id])))))
  \end{clojure/lines}
\end{english}

\fi

\index{SQL!FOR UPDATE}

Запрос на поиск записи мы вынесли в переменную \verb|query|, чтобы сократить
код \verb|task-fn|. Это SQL с оператором \verb|FOR UPDATE|, который
блокирует запись на изменение в других подключениях.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def query
  "SELECT * FROM requests
   WHERE NOT is_processed
   LIMIT 1 FOR UPDATE;")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def query
  "SELECT * FROM requests WHERE NOT is_processed
   LIMIT 1 FOR UPDATE;")
  \end{clojure}
\end{english}

\fi

\verb|FOR UPDATE| работает только в транзакции, поэтому тело функции обёрнуто
в~\texttt{(jdbc/with\--db-transaction)}. Это макрос, внутри которого доступно
транзакционное соединение с базой. На него указывает символ~\verb|tx|. В~функции
JDBC мы передаём \verb|tx|, а~не~\verb|db| \ifx\devicetype\mobile(строки 5 и~18)\else(строки 3 и~12)\fi.

\index{функции!get-ip-info}
\index{сайты!iplocation.com}

Напишем функцию \verb|get-ip-info|. Она обращается к сервису, который принимает
IP и возвращает сведения о нём в JSON. В нашем случае это сайт
\verb|iplocation.com|. В промышленных системах базы адресов разворачивают
локально, чтобы не зависеть от сторонних служб.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn get-ip-info [ip]
  (:body (client/post
           "https://iplocation.com"
           {:form-params {:ip ip}
            :as :json})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn get-ip-info [ip]
  (:body (client/post "https://iplocation.com"
                      {:form-params {:ip ip}
                       :as :json})))
  \end{clojure}
\end{english}

\fi

\noindent
Если вызвать \verb|get-ip-info| с адресом Берлина, получим словарь:

\begin{english}
  \begin{clojure}
(get-ip-info "85.214.132.117")

{:postal_code "12529"
 :continent_code "EU"
 :region_name "Land Berlin"
 :city "Berlin"
 :isp "Strato AG"
 :region "BE"
 :country_code "DE"
 :country_name "Germany"
 :time_zone "Europe/Berlin"
 :lat 52.5167
 :company "Strato AG"
 :lng 13.4}
  \end{clojure}
\end{english}

Мы описали последний элемент воркера, и он готов к работе. Добавим в базу
несколько записей, запустим воркер и через некоторое время прочтём их снова.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(mount/start)

(jdbc/insert! db :requests
  {:path "/help" :ip "31.148.198.0"})
;; wait for a while

(jdbc/query db "select * from requests")
({:path "/help"
  :ip "31.148.198.0"
  :is_processed true
  :city "Pinsk"
  :zip "225710" :id 1
  :lon 26.0728 :lat 52.1214
  :country "Belarus"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(mount/start)

(jdbc/insert! db :requests {:path "/help" :ip "31.148.198.0"})
;; wait for a while

(jdbc/query db "select * from requests")
({:path "/help" :ip "31.148.198.0" :is_processed true
  :city "Pinsk" :zip "225710" :id 1
  :lon 26.0728 :lat 52.1214 :country "Belarus"})
  \end{clojure}
\end{english}

\fi

Адрес \verb|31.148.198.0| разрешится в город Пинск в Беларуси. Система работает
правильно.

\subsection{Сбор системы}

\index{компоненты}

Компоненты готовы и работают по отдельности; осталось собрать вместе. Для этого
напишем центральный модуль \verb|core|, который импортирует все известные
компоненты. Вызов \verb|(mount/start)| из него запустит систему
целиком. Разберёмся, зачем нужен этот модуль.

Функции \verb|start| и \verb|stop| работают только с теми компонентами, которые
известны Mount. Если загрузить модуль воркера, Mount получит информацию о
\verb|worker|, \verb|db| и \verb|config|, но не \verb|server|, потому что никто
не ссылается на него в \verb|require|. Модуль сервера не загрузится, и~система
не узнает об этом компоненте. Проблему решит импорт всех компонентов без
исключений.

\label{mount-main}

\begin{english}
  \begin{clojure}
(ns book.systems.mount.core
  (:require
   ;; other packages...
   [mount.core :as mount]
   book.systems.mount.config
   book.systems.mount.db
   book.systems.mount.server
   book.systems.mount.worker))

(defn start []
  (mount/start))
  \end{clojure}
\end{english}

Читатель заметит, что модули \verb|config| и \verb|db| указывать
необязательно. Компилятор загрузит их автоматически, потому что на них ссылаются
\verb|server| и \verb|worker|. Мы оставили их для наглядности и советуем делать так
же, особенно если вы только начали с Clojure. Модуль \verb|core|~--- это реестр
компонентов: достаточно одного взгляда, чтобы понять, как устроен
проект. Указывайте в нём все компоненты без исключения.

\subsection{Зависимости}

\index{зависимости}

Главная задача системы~--- обойти компоненты в правильном порядке с~учётом
зависимостей. Рассмотрим, как с этим справляется Mount.

При объявлении компонента мы не указываем его зависимости. \verb|Worker|
нуждается в \verb|config| и \verb|db|, но об этом нигде не сказано. Когда мы
вызываем \verb|(mount/start)|, система угадывает порядок запуска:
\verb|config|~\arr{} \verb|db|~\arr{} \verb|worker|. Если переставить любые два
элемента, произойдёт сбой. Как это работает?

Чтобы вычислить порядок, Mount полагается на компилятор Clojure. Пространства
имён зависят друг от друга, как компоненты в системе. Компилятор ищет в теле
\verb|ns| ссылки на другие модули и загружает их первыми. Вспомним, как
выглядит шапка воркера:

\begin{english}
  \begin{clojure}
(ns book.systems.mount.worker
  (:require
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config
     :refer [config]]))
  \end{clojure}
\end{english}

\index{граф зависимостей}

\ifx\mode\print

\noindent
Начертим граф ссылок:

\begin{figure}[h!]
  \chart{chart-sys-2}
\end{figure}

\fi

\ifx\mode\ebook

\noindent
Начертим граф ссылок \fig{fig:chart-sys-2}.

\begin{figure}[ht!]
  \chart{chart-sys-2}
  \caption{Зависимости первого уровня}
  \label{fig:chart-sys-2}
\end{figure}

\fi

Компилятор не загрузит \verb|mount.worker| до тех пор, пока не разрешит
зависимости. Он начнёт с модуля базы данных. Его упрощённое определение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.mount.db
  (:require
   [book.systems.mount.config
    :refer [config]]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.mount.db
  (:require
   [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

\fi

\ifx\mode\print

\noindent
Что с точки зрения компилятора:

\begin{figure}[h!]
  \chart{chart-sys-3}
\end{figure}

\fi

\ifx\mode\ebook

\noindent
Что с точки зрения компилятора выглядит как на второй схеме
\fig{fig:chart-sys-3}:

\begin{figure}[b!]
  \chart{chart-sys-3}
  \caption{Зависимости второго уровня}
  \label{fig:chart-sys-3}
\end{figure}

\fi

Прежде чем загрузить \verb|db|, компилятор займётся \verb|config|. Последний
не зависит от других модулей и загрузится первым. Затем компилятор вернётся к
\verb|db| и загрузит его. Дальше он поднимется на уровень
\verb|worker|. Модуль \verb|db| готов, следующий по списку
\verb|config|. Конфигурацию уже загрузили на этапе \verb|db|. Clojure не
загружает модуль дважды, поэтому компилятор его. На последнем шаге
загрузится \verb|worker|.

\index{пространства имён}

Мы вывели порядок \emph{пространств}: \verb|config|, \verb|db|,
\verb|worker|. Каждая форма \verb|defstate| выполняется в той же очереди. В
этом и заключается трюк: вызов \verb|defstate| увеличивает внутренний счётчик
Mount, а компонент запоминает это число. Сущности \verb|config|, \verb|db| и
\verb|worker| получат номера 1, 2 и 3. Чтобы запустить систему, Mount
обходит компоненты по возрастанию номера, а для остановки~--- по убыванию.

\subsection{Внутреннее устройство}

Mount хранит сведения о компонентах в приватных атомах. Они скрыты для
потребителей, но Clojure позволяет добраться до них. Когда компоненты загружены,
выполните:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def _state
  @@(resolve 'mount.core/meta-state))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def _state @@(resolve 'mount.core/meta-state))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!resolve}

В переменной \verb|_state| окажется словарь компонентов. Двойной оператор
\verb|@| играет следующую роль. Функция \verb|resolve| по символу вернёт
объект \verb|Var|. Мы выяснили, что это контейнер, который хранит
значение \page{var-section}. Первый \verb|@| извлекает значение из
\verb|Var|; это атом со словарём. Второй \verb|@| получает словарь из атома.

\mnoindent
Ключ словаря~--- это текстовая ссылка на компонент, в нашем случае
\texttt{\#'book.systems.mount\-.config/config}. Значение~--- это другой словарь с
состоянием компонента. Нас интересует поле \verb|:order|~--- его
номер. Отсортируем по нему компоненты и получим верный порядок:

\begin{english}
  \begin{clojure}
(->> _state
     vals
     (sort-by :order)
     (map #(-> % :var meta :name)))
;; (config server db worker)
  \end{clojure}
\end{english}

Код ниже вернёт словарь запущенных компонентов с похожей структурой:

\begin{english}
  \begin{clojure}
@@(resolve 'mount.core/running)
  \end{clojure}
\end{english}

Атом \verb|state-seq| хранит глобальный счётчик компонентов. Чтобы прочитать
его, выполните:

\begin{english}
  \begin{clojure}
@@(resolve 'mount.core/state-seq) ;; 4
  \end{clojure}
\end{english}

\noindent
Получится 4, потому что значения от 0 до 3 уже заняты нашими компонентами:
сервером, базой и~другими.

При работе с Mount вы не должны менять его внутренности. Примеры выше нужны,
чтобы читатель лучше понял устройство библиотеки.

\subsection{Состояние}

\index{состояние}

Лёгкость, с которой компонент меняется при вызове \verb|start| и
\verb|stop|, похожа магию. Раскроем секрет \verb|defstate|: он работает на
функции \verb|alter-var-root|, которую мы рассмотрели в главе про
изменяемость \page{alter-var-root}. Вспомним компонент сервера:

\begin{english}
  \begin{clojure}
(defstate server
  :start (let [{jetty-opt :jetty} config]
           (run-jetty app jetty-opt))
  :stop (.stop ^Server server))
  \end{clojure}
\end{english}

Форма \verb|defstate| раскрывается в несколько выражений. Это глобальная
переменная без значения:

\index{переменные!без значения}

\begin{english}
  \begin{clojure}
(def server)
  \end{clojure}
\end{english}

\noindent
и анонимные функции запуска и остановки. Тела функций получат код из~ключей
\verb|:start| и \verb|:stop|.

\begin{english}
  \begin{clojure}
(fn [] ;; start
  (alter-var-root #'server
   (fn [_]
     (let [{jetty-opt :jetty} config]
       (run-jetty app jetty-opt)))))

(fn [] ;; stop
  (alter-var-root #'server
   (fn [_]
     (.stop ^Server server))))
  \end{clojure}
\end{english}

Mount помещает ссылки на эти функции в атом \verb|meta-state|. Чтобы включить
компонент, нужно найти в словаре функцию включения и~вызвать её. Функция
назначит переменной \verb|#'server| новое значение. Остановка работает
аналогично.

\subsection{Выборочный запуск}

\label{mount-selective}
\index{системы!выборочный запуск}

До сих пор мы запускали систему целиком. Вызов \verb|(mount/start)| без
параметров пробегает по \verb|meta-state| и включает все компоненты. Это не
всегда удобно. Предположим, мы работаем над воркером и хотели бы запустить
только его и зависимости. В этом случае веб-сервер не~требуется.

Чтобы запустить только нужные компоненты, их ссылки передают в функцию
\verb|mount/start|. Важно: функция ожидает именно ссылку, объект \verb|Var|.

\begin{english}
  \begin{clojure}
(mount/start
  #'book.systems.mount.config/config
  #'book.systems.mount.db/db
  #'book.systems.mount.worker/worker)
  \end{clojure}
\end{english}

Если передать простое значение (без \verb|#'|), Mount не запустит
компонент. Связь между переменной и значением работает в одну сторону: по
второму нельзя найти первое. В примере ниже не будет ошибки, просто ничего не
произойдёт:

\begin{english}
  \begin{clojure}
;; does nothing
(mount/start
  book.systems.mount.config/config
  book.systems.mount.db/db
  book.systems.mount.worker/worker)
  \end{clojure}
\end{english}

\index{переменные!Var}

Тот факт, что функция ожидает именно \verb|Var|, а не значение, сбивает с толку
новичков. Это не очевидно, поскольку в Clojure к переменным прибегают редко.

При ручном запуске за порядок компонентов отвечаете вы. Предположим, вы забыли,
что базе и воркеру нужна конфигурация:

\begin{english}
  \begin{clojure}
(mount/start
  #'book.systems.mount.db/db
  #'book.systems.mount.worker/worker)
  \end{clojure}
\end{english}

Получим странное исключение. Оно возникнет в компоненте \verb|db|, где создаётся
пул. Объект \verb|config| не запущен, и выражение \spverb|(:pool config)| вернёт
\verb|nil|. При попытке создать пул из \verb|nil| получим \verb|NPE|.

С ростом системы всё сложнее отслеживать зависимости. Mount знает только порядок
компонентов, но не как они связаны. Это слабое место библиотеки~--- чтобы
включить подсистему, компоненты указывают вручную. Чтобы облегчить этот
сценарий, библиотека предлагает \emph{селекторы} компонентов. Это функции,
которые вернут ссылки на них по какому-то признаку.

Селектор \verb|except| вернёт имена компонентов \emph{кроме}
перечисленных. Если передать результат в \verb|start|, получим систему без
указанных компонентов. Ниже запускается подмножество без веб-сервера:

\begin{english}
  \begin{clojure}
(-> [#'book.systems.mount.server/server]
    mount/except
    mount/start)
  \end{clojure}
\end{english}

Другие селекторы и их комбинации смотрите на странице проекта в~GitHub. Кроме
селекторов, Mount предлагает функции для инверсии системы: включить то, что не
работает, и~наоборот.

\subsection{Проблема перезагрузки}

При работе с проектом мы подключаемся к нему из редактора через REPL. Чтобы
состояние Лисп-машины совпадало с кодом, мы выполняем изменённые участки на
сервере. Вопрос: что случится, если исправить уже запущенный компонент? Как
Mount отреагирует на перезагрузку модуля?

\index{Emacs}
\index{CIDER}

Если вы работаете в Emacs и CIDER, подключитесь к проекту через
\verb|M-x cider-connect|. Запустите систему, как мы делали это выше.
Откройте модуль сервера и выполните \verb|M-x cider-eval-buffer|
(или клавишами \verb|C-c C-k|). Команда выполнит файл на сервере.
Все определения, включая \verb|ns|, \verb|def| и \verb|defstate|,
сработают повторно.

Появится сообщение, что сервер перезагружен. Макрос \verb|defstate| проверяет,
что компонент с таким именем существует и работает. Mount выключит компонент и
запустит с новыми версиями \verb|start| и \verb|stop|.

Перезагрузка~--- это не всегда желаемое поведение. При частых изменениях случается
<<рассинхрон>>~--- ситуация, когда компонент считается выключенным, но его
ресурс занят. Например, в блоке \verb|:stop| мы не вызвали метод
\verb|(.stop)|. Если перезагрузить такой компонент, получим ошибку, что порт
занят.

Реакцию компонента на перезагрузку указывают в метаданных. Это поле
\verb|:on-reload|, которое по умолчанию равно \verb|:restart|. С ним
компонент перезапускает себя при повторном вызове \verb|defstate|. Если задать
\verb|:stop|, компонент остановится. Ключ \verb|:noop| означает <<не делать
ничего>>. Компонент с метаданными выглядит так:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defstate
  ^{:on-reload :noop}
  server
  :start (run-jetty app
           {:join? false :port 8080})
  :stop (.stop server))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defstate
  ^{:on-reload :noop}
  server
  :start (run-jetty app {:join? false :port 8080})
  :stop (.stop server))
  \end{clojure}
\end{english}

\fi

Если вы не уверены, выбирайте \verb|:noop|: с ним загрузка кода в REPL не
несёт побочных эффектов. Изменения в коде не всегда относятся к компоненту: это
может быть опечатка или комментарий. Если вы исправили компонент, перезагрузите
его вручную.

\subsection{Самостоятельная работа}

\index{библиотеки!Clj-http}

Вернёмся к функции \verb|get-ip-info| из модуля воркера. На каждый вызов она
выполняет HTTP-запрос. На низком уровне мы открываем TCP-соединение, работаем с
ним и закрываем. Это не оптимально, и~проблему решают как с базами данных~---
пулом соединений. Изучите пример из библиотеки
\footurl{Clj-http}{https://github.com/dakrone/clj-http}[Clj-http][-10mm]:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(:require
 [clj-http.conn-mgr :refer
   [make-reusable-conn-manager
    shutdown-manager]])

;; create a new pool
(def cm (make-reusable-conn-manager
         {:timeout 2 :threads 3}))

;; make a request within the pool
(client/get "http://example.org/"
            {:connection-manager cm})

;; shut down the pool
(shutdown-manager cm)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
;; create a new pool
(def cm (clj-http.conn-mgr/make-reusable-conn-manager
         {:timeout 2 :threads 3}))

;; make a request within the pool
(client/get "http://example.org/"
            {:connection-manager cm})

;; shut down the pool
(clj-http.conn-mgr/shutdown-manager cm)
  \end{clojure}
\end{english}

\fi

\index{пул соединений!в HTTP}

Напишите компонент, который шлёт запросы через пул. Параметры компонента
(тайминг, число потоков) приходят из конфигурации. На старте компонент открывает
пул, при остановке закрывает его. Измените воркер так, чтобы он зависел от
нового компонента.

\section{Component}

\index{библиотеки!Component}

Библиотека \footurl{Component}{https://github.com/stuartsierra/component}[Compo-\\*nent][1mm] тоже
описывает систему и компоненты. Это небольшой фреймворк, где главную роль играет
не объём кода, а идея. Дизайн Component в корне отличается от Mount, который мы
рассмотрели.

\index{состояние}
\index{компоненты}

Как и в Mount, на компонент действуют операции \verb|start| и
\verb|stop|. Они возвращают \emph{копию} объекта в новом состоянии; исходный
компонент остаётся прежним. Можно сказать, компоненты неизменяемы. Это отсекает
ошибки, связанные с глобальными переменными.

Система~--- это словарь компонентов с зависимостями. Изначально система пребывает в
покое, компоненты не запущены. Код запуска обходит и включает их. Получается
рабочая копия системы. Она похожа на исходную, но каждый компонент заменён на
его рабочую версию. Остановка работает так же: на выходе получится выключенная
копия системы.

Component не терпит глобального состояния. В библиотеке нет скрытых атомов для
учёта компонентов. Один компонент имеет доступ к другому только если они
зависимы. Как и система, компонент избегает атомов и других изменяемых типов. На
каждое действие он порождает новую копию себя.

\subsection{Устройство}

\label{defrecord}

Компонент~--- это объект, который реализует протокол \verb|Lifecycle|. В~протокол
входят методы \verb|start| и \verb|stop|. На роль компонента подходит
типизированный словарь, который объявляют формой \verb|defrecord|. По-другому их
называют <<типизированные записи>> или <<р\'{е}корды>>.

\index{clojure.core!defrecord}
\index{р\'{е}корды}
\index{протоколы!Lifecycle}

Запись отличается от словаря тем, что заранее перечисляет ключи. Их называют
\emph{слотами} записи. Слоты работают быстрее ключей в~обычном словаре. Они
нужны компоненту для входных параметров и~состояния.

Запись и протокол сочетаются на уровне языка. При объявлении записи можно сразу
расширить её протоколом. В методах протокола слоты доступны как локальные
переменные. Это уменьшает код и~экономит внимание.

\index{ООП}

Компонент таит состояние, и только он знает, как им управлять. Будет ошибкой
читать его слоты и передавать их в функции. Пользуйтесь методами, которые входят
в протокол компонента. Код на Component напоминает ООП: это объект и набор
операций над ним. Как и класс, компонент инициируют, запускают и останавливают.

\index{ООП!SOLID}

Отличие в том, что компоненты неизменяемы. Переход на новую стадию не затронет
старый компонент, в то время как в классических языках его поля
перепишут. Принцип \verb|SOLID| и тройка <<инкапсуляция, наследование,
полиморфизм>> не имеют той же силы в Clojure. Б\'{о}льшая их часть отпадает за
ненадобностью. Программируя на Clojure, мы не волнуемся о том, что нарушили
постулаты ООП.

\subsection{Первый компонент}

Перепишем систему из прошлого раздела на Component. Начнём с~веб-сервера. В
файле \verb|server.clj| объявим пространство имён:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.comp.server
  (:require
   [com.stuartsierra.component
    :as component]
   [ring.adapter.jetty
    :refer [run-jetty]]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.comp.server
  (:require
   [com.stuartsierra.component :as component]
   [ring.adapter.jetty :refer [run-jetty]]))
  \end{clojure}
\end{english}

\fi

Компонент~--- это запись с двумя слотами: \verb|options| и \verb|server|. В
опциях записаны параметры Jetty-сервера, в \verb|server|~--- его
экземпляр. Строка \verb|component/Lifecycle| означает протокол, который
реализует запись. Ниже следует \emph{реализация} протокола.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defrecord Server [options server]

  component/Lifecycle

  (start [this]
    (let [server (run-jetty app
                   options)]
      (assoc this :server server)))

  (stop [this]
    (.stop server)
    (assoc this :server nil)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defrecord Server [options server]

  component/Lifecycle

  (start [this]
    (let [server (run-jetty app options)]
      (assoc this :server server)))

  (stop [this]
    (.stop server)
    (assoc this :server nil)))
  \end{clojure}
\end{english}
\fi


Метод \verb|start| вернёт ту же запись, но с заполненным слотом
\verb|:server|. В нём находится объект сервера. Метод \verb|stop| принимает
запущенный компонент. Он выключает сервер и возвращает ещё одну запись, где слот
\verb|:server| равен \verb|nil|.

\index{инициализация}

Внутри методов мы обращаемся к слотам как к локальным переменным. Это работает
только если методы описаны внутри \verb|defrecord|. Если запись расширяют
отдельным шагом, например через \verb|extend|, доступ к слотам
теряется. Придётся извлечь их из переменной \verb|this|.

Сущность \verb|Server|~--- это не компонент, а только абстрактное описание. На
первом шаге его \emph{инициируют}, то есть создают экземпляр. Для этого служит
функция \verb|map-><Record>|, где \verb|<Record>|~--- это имя записи. Макрос
\verb|defrecord| автоматически порождает эту функцию. В нашем случае она
называется \verb|map->Server|. Функция принимает обычный словарь и~возвращает
его типизированную версию. Ключи словаря совпадают со~слотами записи. Если ключ
не найден, слот равен \verb|nil|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def s-created
  (map->Server
    {:options {:port 8080
               :join? false}}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def s-created
  (map->Server {:options {:port 8080 :join? false}}))
  \end{clojure}
\end{english}

\fi

Переменная \verb|s-created|~--- это экземпляр записи \verb|Server|. Мы указали
слот \verb|options|, но не \verb|server|, потому что он будет заполнен
позже.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def s-started
  (component/start s-created))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def s-started (component/start s-created))
  \end{clojure}
\end{english}

\fi

\mnoindent
Это выражение вернёт \emph{запущенный} компонент. Откройте браузер по адресу
\texttt{http://127.0.0.1\-:8080} и проверьте, что сервер работает. У~записи
\verb|s-started| заполнен слот \verb|:server|:

\begin{english}
  \begin{clojure}
(-> s-started :server type)
;; org.eclipse.jetty.server.Server
  \end{clojure}
\end{english}

Остановите компонент. Проверьте, что страница больше не открывается, а слот
сервера равен \verb|nil|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def s-stopped
  (component/stop s-started))
(:server s-stopped) ;; nil
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def s-stopped (component/stop s-started))
(:server s-stopped) ;; nil
  \end{clojure}
\end{english}

\fi

Мы прошли полный цикл компонента: подготовку, запуск и остановку. Переход на
каждую стадию даёт новый компонент. На практике компонентами не управляют
вручную~--- это делает система.

\subsection{Конструктор}

\index{конструктор}

Вспомним, как мы создали экземпляр \verb|Server|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(map->Server
  {:options {:port 8080
             :join? false}})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(map->Server {:options {:port 8080 :join? false}})
  \end{clojure}
\end{english}

\fi

\index{слоты}

У этой записи недостаток: нужно помнить, какие слоты нужны для инициализации, а
какие~--- для внутреннего состояния. Для простых записей это не критично, но на
практике бывают компоненты с десятью и более слотами. Чтобы не запутаться,
объявляют функцию-\emph{конструктор}.

Конструктор принимает только те аргументы, которые нужны для инициализации
компонента. В нашем случае это \verb|options|, поэтому функция выглядит так:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn make-server
  [options]
  (map->Server {:options options}))

(def s-created
  (make-server {:port 8080
                :join? false}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn make-server
  [options]
  (map->Server {:options options}))

(def s-created (make-server {:port 8080 :join? false}))
  \end{clojure}
\end{english}

\fi

С конструктором легче создать компонент: невозможно передать в
\verb|map->Server| что-то лишнее. Конструктор~--- это функция, поэтому к~нему можно
добавить документацию и спеку. Продвинутый редактор подскажет сигнатуру в месте
вызова. Пишите конструктор даже для тривиальных компонентов.

\subsection{Особенность слотов}

При остановке сервера мы совершаем два действия: вызываем у него метод
\verb|(.stop)| и заменяем слот на \verb|nil|. Почему бы не заменить
\verb|assoc| на \verb|dissoc|? Зачем хранить \verb|nil|, когда можно
отсоединить поле?

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; why this?
(assoc this :server nil)
  \end{clojure}

\splitter

  \begin{clojure}
;; but not this?
(dissoc this :server)
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
;; why this?
(assoc this :server nil)
  \end{clojure}

&

  \begin{clojure}
;; but not this?
(dissoc this :server)
  \end{clojure}

\end{tabular}

\end{english}

\fi

Причина в том, как устроены записи и слоты. Запись сохраняет уникальные свойства
до тех пор, пока её слоты на месте. Если забрать у записи слот через
\verb|dissoc|, получим обычный словарь. Покажем это на примере:

\begin{english}
  \begin{clojure}
(-> s-stopped
    (assoc :server nil)
    type)
;; book.systems.comp.server.Server

(-> s-stopped
    (dissoc :server)
    type)
;; clojure.lang.PersistentArrayMap
  \end{clojure}
\end{english}

Если компонент вызывает \verb|dissoc| на себе, на новой стадии получим не
компонент, а словарь. Это ведёт к странному поведению: при попытке выключить
компонент он продолжит работу. Почему так происходит?

Когда запись расширяют протоколом, образуется связь между классом и
реализацией. Для \verb|Server| методы \verb|start| и \verb|stop| выполнят
одно, для \verb|DB| или \verb|Worker|~--- другое.

Поиск метода в Clojure работает с учётом иерархии классов подобно перехвату
исключений \page{exc-hierarchy}. При загрузке Component расширяет базовый класс
\verb|Object| методами \verb|start| и \verb|stop|, которые просто
возвращают \verb|this|. Если забрать у записи слот, она станет
словарём. Словарь не реализует \verb|Lifecycle| напрямую, поэтому поиск пойдёт
вверх по дереву наследования. В результате он разрешится в \verb|Object|,
который молча вернёт \verb|this|.

Привёдем неудачный компонент. Его метод \verb|start| вернёт словарь с~полем
\verb|server|:

\begin{english}
  \begin{clojure}
(defrecord BadServer [options server]
  component/Lifecycle
  (start [this]
    {:server (run-jetty app options)})
  (stop [this]
    (.stop server)
    nil))
  \end{clojure}
\end{english}

Сервер запустится без ошибок, но дальше нас ждёт проблема. Если передать
результат \verb|start| в~\verb|stop|, сервер не остановится. Можно сколько
угодно вызывать \verb|component/stop|, но это ничего не даст.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def bs-created
  (map->BadServer
    {:options {:port 8080
               :join? false}}))

(def bs-started
   (component/start bs-created))
(type bs-started)
;; clojure.lang.PersistentArrayMap

(component/stop bs-started)
;; does nothing, the server still works
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def bs-created (map->BadServer
                  {:options {:port 8080 :join? false}}))

(def bs-started (component/start bs-created))
(type bs-started)
;; clojure.lang.PersistentArrayMap

(component/stop bs-started)
;; does nothing, the server still works
  \end{clojure}
\end{english}

\fi

В метод stop тоже закралась ошибка. При остановке компонент выключит сервер, но
вернёт \verb|nil|. Если передать результат \verb|stop| в \verb|start|,
последний получит \verb|nil|. Это вызовет исключение, потому что \verb|nil|
не~реализует протокол \verb|Lifecycle|.

\index{протоколы!Lifecycle}

Следите за тем, чтобы компонент менял только значения слотов, но не их
состав. Как правило, код \verb|start| и \verb|stop| завершается формой
\verb|assoc|, но не \verb|dissoc|. Не должно быть проблем с пробросом
(<<чейнингом>>) компонента по его стадиям:

\begin{english}
  \begin{clojure}
(-> (make-component {...})
    (component/start)
    (component/stop)
    (component/start))
  \end{clojure}
\end{english}

\index{чейнинг}

\subsection{Компонент базы}

Напишем компонент для работы с базой. Он содержит слоты \verb|options|
и~\verb|db-spec|. Первый~--- это словарь опций будущего пула, а второй~---
JDBC-спека с открытым пулом. Принцип его работы известен вам из прошлых
разделов.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defrecord DB [options db-spec]
  component/Lifecycle
  (start [this]
    (let [pool (cp/make-datasource
                 options)]
      (assoc this :db-spec
        {:datasource pool})))
  (stop [this]
    (-> db-spec
        :datasource
        cp/close-datasource)
    (assoc this :db-spec nil)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defrecord DB [options db-spec]
  component/Lifecycle
  (start [this]
    (let [pool (cp/make-datasource options)]
      (assoc this :db-spec {:datasource pool})))
  (stop [this]
    (-> db-spec :datasource cp/close-datasource)
    (assoc this :db-spec nil)))
  \end{clojure}
\end{english}

\fi

\noindent
Добавим конструктор:

\begin{english}
  \begin{clojure}
(defn make-db [options]
  (map->DB {:options options}))
  \end{clojure}
\end{english}

Компонент готов к запуску: его можно прогнать через функции
\verb|make-db|~\arr{} \texttt{component\-/start}~\arr{} \verb|component/stop|.

Пока что неясно, как выполнить запрос через компонент. Нас интересует слот
\verb|db-spec|, который хранит спеку. Можно вычленить его и~передать в функцию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [{:keys [db-spec]} db-started
      users (jdbc/query db-spec
              "select * from users")]
  (process-users users))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [{:keys [db-spec]} db-started
      users (jdbc/query db-spec "select * from users")]
  (process-users users))
  \end{clojure}
\end{english}

\fi

Это варварский подход: нельзя вторгаться в компонент, даже если язык предлагает
такую возможность. Мы нарушаем идею, согласно которой компонент неделим для
потребителя. Мы вправе только дёргать за ручки, которые предлагает
компонент. Сейчас ручек нет, поэтому добавим их.

Расширим запись \verb|DB| методами для работы с базой. Поместим их в отдельный
протокол. Сигнатуры похожи на функции JDBC с той разницей, что первый параметр~---
это не спека, а \verb|this|, компонент:

\index{протоколы!IDB}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defprotocol IDB
  (query [this sql-params])
  (update!
    [this table set-map where-clause]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defprotocol IDB
  (query [this sql-params])
  (update! [this table set-map where-clause]))
  \end{clojure}
\end{english}

\fi

В теле \verb|defrecord|, сразу после \verb|stop|, реализуем новый
протокол. Методы сводятся к функциям JDBC, в которые передаём слот
\verb|db-spec| и~аргументы. Сначала компонент реализует \verb|Lifecycle| как
обычно:

\begin{english}
  \begin{clojure}
(defrecord DB [options db-spec]
  ;; ...component/Lifecycle
  \end{clojure}
\end{english}

\noindent
Далее следует частный протокол:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
  IDB
  (query [this sql-params]
    (jdbc/query db-spec sql-params))

  (update!
    [this table set-map where-clause]
    (jdbc/update! db-spec
      table set-map where-clause)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
  IDB
  (query [this sql-params]
    (jdbc/query db-spec sql-params))

  (update! [this table set-map where-clause]
    (jdbc/update! db-spec table set-map where-clause)))
  \end{clojure}
\end{english}

\fi

Компонент готов к запросам. Мы вызываем не функции JDBC, а методы
протокола. Этим мы изолируем зависимость от JDBC и~снижаем связанность кода.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def db-created (make-db options))
(def db-started
  (component/start db-created))

(query db-started "select * from users")
(update! db-started
  :users {:name "Ivan"} ["id = ?" 42])

(def db-stopped
  (component/stop db-started))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def db-created (make-db options))
(def db-started (component/start db-created))

(query db-started "select * from users")
(update! db-started :users {:name "Ivan"} ["id = ?" 42])

(def db-stopped (component/stop db-started))
  \end{clojure}
\end{english}

\fi

\subsection{Транзакционный компонент}

\index{транзакции}

Для согласованных изменений в базе нужны транзакции. Раньше мы пользовались
макросом \verb|jdbc/with-db-transaction|. Из обычного соединения он получает
транзакционное и связывает с символом.

В отличие от JDBC, наш макрос работает с компонентом. Он принимает обычный
компонент и связывает с символом его \emph{транзакционную} версию. Макрос
сводится к следующим шагам:

\begin{itemize}

\item
  получить спеку из компонента;

\item
  обернуть тело в макрос JDBC, связать транзакционное соединение с переменной;

\item
  получить компонент, в котором слот \verb|:db-spec| заменён на эту переменную;

\item
  связать новый компонент с символом из макроса.

\end{itemize}

\begin{listing}[ht!]

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defmacro with-db-transaction
  [[comp-tx comp-db & trx-opt] & body]
  `(let [{db-spec# :db-spec} ~comp-db]
     (jdbc/with-db-transaction
       [t-conn# db-spec# ~@trx-opt]
       (let [~comp-tx
             (assoc ~comp-db
               :db-spec t-conn#)]
         ~@body))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmacro with-db-transaction
  [[comp-tx comp-db & trx-opt] & body]
  `(let [{db-spec# :db-spec} ~comp-db]
     (jdbc/with-db-transaction
       [t-conn# db-spec# ~@trx-opt]
       (let [~comp-tx (assoc ~comp-db :db-spec t-conn#)]
         ~@body))))
  \end{clojure}
\end{english}

\fi

\caption{Макрос транзакции для компонента базы}
\label{fig:trx-macro}

\end{listing}

\index{ООП!геттер}
\index{ООП!сеттер}

Приведём код макроса в отдельном листинге \ref{fig:trx-macro}.

При анализе читатель заметит, что нарушен принцип закрытости компонента. Мы
вручную читаем и~заменяем слот \verb|db-spec|. Подумайте, как улучшить
код. Подсказка: доступ к слоту можно вынести в~методы \verb|get-|
и~\verb|set-spec|, то есть обычные <<геттер>> и <<сеттер>> из мира ООП. Разница
в~том, что <<сеттер>> вернёт новый компонент. Макрос в~действии:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(with-db-transaction
  [db-tx db-started]
  (let [query "select * from requests
               limit 1 for update"
        result (query db-tx query)]
    (when-let [id (some->
                    result first :id)]
      (update! db-tx :requests
               {:is_processed false}
               ["id = ?" id]))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-db-transaction
  [db-tx db-started]
  (let [query "select * from requests limit 1 for update"
        result (query db-tx query)]
    (when-let [id (some-> result first :id)]
      (update! db-tx :requests
               {:is_processed false}
               ["id = ?" id]))))
  \end{clojure}
\end{english}

\fi

\noindent
В логах PostgreSQL увидим записи:

\index{SQL!BEGIN}
\index{SQL!UPDATE}
\index{SQL!COMMIT}

\ifx\devicetype\mobile

\begin{english}
  \begin{sql}
BEGIN
select * from requests
limit 1 for update
UPDATE requests SET is_processed = $1
WHERE id = $2
DETAIL:  parameters: $1 = 'f', $2 = '3'
COMMIT
  \end{sql}
\end{english}

\else

\begin{english}
  \begin{sql}
BEGIN
select * from requests limit 1 for update
UPDATE requests SET is_processed = $1 WHERE id = $2
DETAIL:  parameters: $1 = 'f', $2 = '3'
COMMIT
  \end{sql}
\end{english}

\fi

\noindent
Запросы \verb|SELECT| и \verb|UPDATE| действительно были в транзакции.

\subsection{Воркер}

Напишем компонент воркера. Объявим модуль и зависимости:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.comp.worker
  (:require
   [com.stuartsierra.component
    :as component]
   [book.systems.comp.db :as db]
   [clj-http.client :as client]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.comp.worker
  (:require
   [com.stuartsierra.component :as component]
   [book.systems.comp.db :as db]
   [clj-http.client :as client]))
  \end{clojure}
\end{english}

\fi

\index{протоколы!IWorker}

\mnoindent
Воркер~--- это запись с протоколами \verb|Lifecycle| и \verb|IWorker|. Протокол
\verb|Lifecycle| уже знаком читателю: это функции \verb|start| и
\verb|stop|. В \verb|IWorker| поместим логику компонента. В неё входят
бесконечный цикл и его подготовка. Ожидаем, что \verb|task-fn|~--- это функция,
которую воркер вызывает на каждом шаге цикла. Метод \verb|make-task|
оборачивает её в цикл и \verb|try/catch|.

\begin{english}
  \begin{clojure}
(defprotocol IWorker
  (make-task [this])
  (task-fn [this]))
  \end{clojure}
\end{english}

Запись хранит четыре слота: входные опции, флаг продолжения, футура с циклом
(\verb|task|) и база данных. Последний слот~--- это зависимый компонент, экземпляр
\verb|DB|, который мы только что написали. Реализуем \verb|Lifecycle|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines}
(defrecord Worker
  [options flag task db]

  component/Lifecycle

  (start [this]
    (let [flag (atom true)
          this (assoc this :flag flag)
          task (make-task this)]
      (assoc this :task task)))

  (stop [this]
    (reset! flag false)
    (while (not (realized? task))
      (log/info
        "Waiting for
             the task to complete")
      (Thread/sleep 300))
    (assoc this :flag nil :task nil)))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(defrecord Worker
  [options flag task db]

  component/Lifecycle

  (start [this]
    (let [flag (atom true)
          this (assoc this :flag flag)
          task (make-task this)]
      (assoc this :task task)))

  (stop [this]
    (reset! flag false)
    (while (not (realized? task))
      (log/info "Waiting for the task to complete")
      (Thread/sleep 300))
    (assoc this :flag nil :task nil)))
  \end{clojure/lines}
\end{english}

\fi

Обратите внимание на строку~8: мы дополняем \verb|this| флагом
состояния. Метод \verb|make-task| ожидает \verb|this| с заполненным слотом
\verb|flag|. Если строку убрать, \verb|make-task| получит запись с пустым
флагом.

\index{функции!make-task}

Опишем протокол \verb|IWorker|. Код \verb|make-task| и \verb|task-fn| уже
знаком читателю из раздела про Mount. Разница в том, что теперь мы работаем не с
функциями, а с методами. У метода прямой доступ к слотам, поэтому не нужно
передавать их в параметрах. Ниже мы перенесли код \verb|make-task| и
\verb|task-fn| в компонент. Для краткости опустим перехват ошибок и некоторые
детали.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defrecord Worker
  ;; ...component/Lifecycle
  IWorker

  (make-task [this]
    (future
      (while @flag    ;; ...try/catch
        (task-fn this)))) ;; ...sleep

  (task-fn [this]
    (db/with-db-transaction [tx db]
      (when-let [[request]
                 (db/query tx query)]
        ;; get fields
        (let [fields (...))]
          (db/update! tx :requests
            fields ["id = ?" id]))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defrecord Worker
  ;; ...component/Lifecycle
  IWorker

  (make-task [this]
    (future
      (while @flag        ;; ...try/catch
        (task-fn this)))) ;; ...sleep

  (task-fn [this]
    (db/with-db-transaction [tx db]
      (when-let [[request] (db/query tx query)]
        (let [fields (...))] ;; get fields
          (db/update! tx :requests
                      fields ["id = ?" id]))))))
  \end{clojure}
\end{english}

\fi

\noindent
Добавим конструктор, и компонент готов:

\index{конструктор}

\begin{english}
  \begin{clojure}
(defn make-worker
  [options]
  (map->Worker {:options options}))
  \end{clojure}
\end{english}

\subsection{Ручные зависимости}

\index{зависимости!ручные}

От других компонентов воркер отличается зависимостями. Пока что не~ясно, как
он узнаёт о базе данных, потому что конструктор принимает только опции. Эту
проблему решает система, а не программист. Мы не~должны передавать компоненты
друг другу при создании.

В учебных целях мы \emph{нарушим} это правило и соберём мини-систему
вручную. Так мы лучше поймём, как она работает, и проверим код. Проведём
эксперимент в модуле \verb|core| с двумя компонентами. Добавьте в модуль
конструкторы:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.systems.comp.core
  (:require
   [com.stuartsierra.component
    :as component]
   [book.systems.comp.worker
    :refer [make-worker]]
   [book.systems.comp.db
    :refer [make-db]]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.systems.comp.core
  (:require
   [com.stuartsierra.component :as component]
   [book.systems.comp.worker :refer [make-worker]]
   [book.systems.comp.db :refer [make-db]]))
  \end{clojure}
\end{english}

\fi

Рассмотрите систему ниже. Это функция, которая принимает конфигурацию. Мы
вручную запускаем базу и воркер и возвращаем словарь компонентов. В десятой
строке мы задаём воркеру слот с базой. Важен момент, когда это происходит:
компонент базы \emph{уже включён}, а~воркер ещё нет (\verb|assoc| идёт перед
\verb|start|).

\begin{english}
  \begin{clojure/lines}
(defn my-system-start
  [config]
  (let [{db-opt :pool
         worker-opt :worker} config
        db (-> db-opt
               make-db
               component/start)
        worker (-> worker-opt
                   make-worker
                   (assoc :db db)
                   component/start)]
    {:db db :worker worker}))
  \end{clojure/lines}
\end{english}

Чтобы запустить систему, передайте в функцию параметры пула и~воркера. Сохраните
систему в переменной, чтобы выключить её позже.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def _sys
  (my-system-start
    {:pool {...} :worker {...}}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def _sys (my-system-start {:pool {...} :worker {...}}))
  \end{clojure}
\end{english}

\fi

Проверьте систему: добавьте записи в таблицу \verb|requests| и убедитесь, что
воркер дополняет их. Функция выключения остановит компоненты в обратном порядке:

\begin{english}
  \begin{clojure}
(defn my-system-stop
  [system]
  (-> system
      (update :worker component/stop)
      (update :db component/stop)))

(my-system-stop _sys)
  \end{clojure}
\end{english}

\subsection{Промышленная система}

\index{системы}

Рассмотрим, как строят систему на практике. Функция \verb|system-map| принимает
цепочку значений. Нечётные элементы~--- это имена компонентов, а чётные~--- вызовы
их конструкторов. Вызов \verb|system-map| строит дерево компонентов с
заполненными слотами. Получим систему в состоянии покоя.

\index{функции!system-map}

При сборке системы не должно быть побочных эффектов. Конструкторы только
порождают записи. Если конструктор обращается к~диску или меняет состояние, это
грубая ошибка.

Система зависит от конфигурации, поэтому сборку выносят в функцию
\verb|make-system|. Она принимает словарь конфигурации и делит на~части. Каждый
конструктор принимает свою часть. Удобно, когда структура конфигурации повторяет
систему: на верхнем уровне ключи компонентов, а под ними словари опций.

Чтобы сообщить компоненту зависимости, его оборачивают в функцию
\verb|component/using|. Второй аргумент~--- это ключи компонентов, которые он
должен получить до старта. Ключи могут быть вектором или словарём. Если имена
слота и компонента совпадают, это вектор. Если отличаются, передают словарь вида
\verb|{:slot :component}|.

Ниже функция \verb|make-system| строит систему, о которой мы договорились в
начале главы. Компонент \verb|worker| обёрнут в \verb|component/using|. Мы
передали вектор \verb|[:db]|, потому что так называется и слот воркера, и
компонент системы.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn make-system
  [config]
  (let [{:keys [jetty pool worker]}
        config]
    (component/system-map
     :server (make-server jetty)
     :db     (make-db pool)
     :worker (component/using
               (make-worker worker)
               [:db]))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn make-system
  [config]
  (let [{:keys [jetty pool worker]} config]
    (component/system-map
     :server (make-server jetty)
     :db     (make-db pool)
     :worker (component/using
              (make-worker worker) [:db]))))
  \end{clojure}
\end{english}

\fi

\index{зависимости!Component}

\noindent
Если бы компонент назывался \verb|:storage|, мы бы задали словарь:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(component/system-map
 :server  (make-server jetty)
 :storage (make-db pool)
 :worker  (component/using
            (make-worker worker)
            {:db :storage}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(component/system-map
 :server  (make-server jetty)
 :storage (make-db pool)
 :worker  (component/using
           (make-worker worker) {:db :storage}))
  \end{clojure}
\end{english}

\fi

Словарь полезен для сторонних компонентов. Их создатели не знают, как называются
сущности в вашем проекте. Предположим, чужой компонент зависит от
\verb|:database|, а у нас это просто \verb|:db|. Словарь снимает проблему
расхождения имён.

Чтобы запустить систему, её передают в \verb|component/start|. У системы
особая реализация \verb|Lifecycle|. При запуске она строит граф зависимостей и
выводит порядок обхода. Перед тем как запустить компонент с зависимостями,
система сообщает их компоненту через \verb|assoc|, как мы делали это
вручную. Аналогично работает выключение системы.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def config {...})
(def sys-init (make-system config))
(def sys-started
  (component/start sys-init))
(def sys-stopped
  (component/stop sys-started))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def config {...})
(def sys-init (make-system config))
(def sys-started (component/start sys-init))
(def sys-stopped (component/stop sys-started))
  \end{clojure}
\end{english}

\fi

Как и компонент, система свободно скользит по функциям \verb|start|
и~\verb|stop| в операторе \arr. Если это не так, в системе ошибка.

\begin{english}
  \begin{clojure}
(-> (make-system config)
    (component/start)
    (component/stop)
    (component/start))
  \end{clojure}
\end{english}

\subsection{Хранение системы}

\index{системы!хранение}

Выше мы задали систему через \verb|def|, что не совсем правильно. Система~--- это
сущность, которую включают по требованию. С ней обращаются как с глобальной
переменной, которая меняет значение. Для этого подходит \verb|alter-var-root|.

В модуле объявляют переменную будущей системы. Для этого служит макрос
\verb|defonce|, который выполняется строго один раз. Так мы не потеряем старую
систему при перезагрузке модуля. Как и компонент, система пребывает в одном из
трёх состояний: покой, запуск и остановка. Функции \verb|system-init|,
\verb|system-start| и \verb|system-stop| переводят систему в нужное
состояние. Они работают с помощью служебной \verb|alter-system|, которую для
краткости задали с помощью \verb|partial|.

\index{clojure.core!alter-var-root}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defonce system nil)

(def alter-system
  (partial alter-var-root #'system))

(defn system-init [config]
  (alter-system
    (constantly (make-system config))))

(defn system-start []
  (alter-system component/start))

(defn system-stop []
  (alter-system component/stop))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defonce system nil)

(def alter-system (partial alter-var-root #'system))

(defn system-init [config]
  (alter-system (constantly (make-system config))))

(defn system-start []
  (alter-system component/start))

(defn system-stop []
  (alter-system component/stop))
  \end{clojure}
\end{english}

\fi

\index{функции!-main}

Появились рычаги, чтобы управлять системой. Функция \verb|-main|~--- это точка
входа в программу. Она сводится к трём шагам: чтению конфигурации, подготовке и
запуску системы.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (let [config
        (load-config "config.edn")]
    (system-init config)
    (system-start)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (let [config (load-config "config.edn")]
    (system-init config)
    (system-start)))
  \end{clojure}
\end{english}

\fi

Система глобальна, но к ней нельзя обращаться напрямую. Если один компонент
что-то ищет в недрах системы, это провал разработчика. Такой подход рушит саму
идею системы и компонентов. Обращаться к системе можно только в разработке или
тестах. Для большей надежности систему делают приватной: так мы обезопасим
её от обращения извне.

\index{clojure.core!defonce}
\index{переменные!приватные}
\index{переменные!единоразовые}

\begin{english}
  \begin{clojure}
(defonce ^:private system nil)
  \end{clojure}
\end{english}

Конечно, и до приватной системы можно добраться с помощью \verb|resolve| и
полного символа. Это продвинутая техника, которой не может противиться ни одна
переменная. Но \verb|resolve| выделяется на общем фоне, и нарушение легче
заметить.

\subsection{Корректное завершение}

\index{системы!завершение}

Глобальная система идёт вразрез с тем, что пишет автор библиотеки: In
production, the system map is ephemeral. It is used to start all the components
running, then it is discarded. (В промышленном запуске система эфемерна. Она
запускает все компоненты и затем исчезает.)

\index{graceful shutdown}

Позволим себе не согласиться с автором. Практика показывает, что ссылка на
систему нужна и в промышленном запуске. Без ссылки нельзя корректно остановить
приложение (англ.~graceful shutdown). Корректность означает, что все ресурсы
закрыты.

Во время работы некоторые компоненты не могут остановиться в~произвольный
момент. Это очереди задач, каналы данных, транзакции. Если аварийно завершить
очередь, мы потеряем сообщение или обработаем его дважды. Закрывайте ресурсы
правильно, даже если их приходится ждать.

\index{POSIX}
\index{сигналы!SIGTERM}

В боевом режиме приложение слушает сигналы POSIX и реагирует на них должным
образом. Если поступил SIGTERM, приложение останавливает систему, дожидается
остановки и только потом завершается.

\index{библиотеки!Signal}

Библиотека \footurl{Signal}{https://github.com/pyr/signal}[Signal][1mm] предлагает макрос,
чтобы связать сигнал с~реакцией на него. Подключите библиотеку в проект:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; project.clj
[spootnik/signal "0.2.2"]

;; src/book/systems/comp/core.clj
(ns ...
  (:require
   [signal.handler :refer
    [with-handler]]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
;; project.clj
[spootnik/signal "0.2.2"]

;; src/book/systems/comp/core.clj
(ns ...
  (:require [signal.handler :refer [with-handler]]))
  \end{clojure}
\end{english}

\fi

Расширьте функцию \verb|-main|. После запуска системы добавьте событие на
сигналы SIGTERM и SIGHUP. Первый останавливает систему и завершает
программу. Второй мы расцениваем как перезагрузку системы.

\begin{english}
  \begin{clojure}
(with-handler :term
  (log/info "caught SIGTERM, quitting")
  (system-stop)
  (log/info "all components shut down")
  (System/exit)
  \end{clojure}
\end{english}

\index{сигналы!SIGHUP}

\begin{english}
  \begin{clojure}
(with-handler :hup
  (log/info "caught SIGHUP, reloading")
  (system-stop)
  (system-start)
  (log/info "system reloaded"))
  \end{clojure}
\end{english}

Сигналы не работают, когда проект запущен через \verb|lein run| или в
REPL. Чтобы проверить сигналы, соберите \verb|uberjar| и запустите его как
Java-приложение.

\begin{english}
  \begin{bash}
$ lein uberjar
$ java -jar target/book-standalone.jar
  \end{bash}
\end{english}

Нажмите \verb|Ctrl+C|. Приложение завершится не сразу, и вы увидите сообщение
об остановке всех компонентов.

Программы по управлению процессами обычно ждут 30 секунд, пока процесс не
остановится. В противном случае его завершают принудительно. Ожидание системы
должно быть разумным. Если оно выходит на рамки 30 секунд, нужно найти и
улучшить проблемный компонент.

\subsection{Подробнее об ожидании}

\index{системы!ожидание}

Вернёмся к функции \verb|-main| приложения. Это входная точка программы на
Clojure:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (let [config
        (load-config "config.edn")]
    (system-init config)
    (system-start)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (let [config (load-config "config.edn")]
    (system-init config)
    (system-start)))
  \end{clojure}
\end{english}

\fi

У читателя, не знакомого с тонкостями JVM, возникнет вопрос: почему программа не
завершается после вызова \verb|(system-start)|? За ним нет цикла, хука или
события, но платформа продолжит работать.

\index{JVM!ожидание}

Это стандартное поведение JVM. Если программа выполнила инструкции без ошибок,
главный поток ожидает, пока не остановятся дочерние. Запуск системы порождает
новые потоки (сервер, пул соединений). После \verb|(system-start)| основной
поток повиснет в ожидании их~завершения. Он будет ждать до тех пор, пока систему
не выключат в другом потоке или не придёт SIGTERM, на который повесили её
остановку.

Если у компонента нет состояния, не будет и новых потоков. Компонент \verb|DB|
можно изменить так, что слот \verb|db-spec|~--- это не пул соединений, а~статичный
словарь. Бывают компоненты, которые выполняют разовую задачу на старте. Если ни
один компонент не породил поток, программа выполнит \verb|start| для каждого из
них и завершится.

\subsection{Улучшаем зависимости}

\index{зависимости!Component}

Мы сообщили компоненту зависимости с помощью \verb|using|:

\begin{english}
  \begin{clojure}
(component/system-map
 ;; ...
 :worker (component/using
          (make-worker worker) [:db]))
  \end{clojure}
\end{english}

Когда компонентов много, зависимости вносят шум и код трудно читать. В примере
выше мы сперва получаем компонент из конструктора, а затем вешаем на него
зависимости. Последний шаг можно сдвинуть в конструктор. Он вернёт
<<заряженный>> компонент, и \verb|using| уйдёт из~системы. Перепишем конструктор
воркера:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn make-worker [config]
  (-> config
      map->Worker
      (component/using [:db])))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn make-worker [config]
  (-> config map->Worker (component/using [:db])))
  \end{clojure}
\end{english}

\fi

\noindent
Новая система чище и короче:

\begin{english}
  \begin{clojure}
(component/system-map
 :server (make-server jetty)
 :db     (make-db pool)
 :worker (make-worker worker))
  \end{clojure}
\end{english}

Подход требует, чтобы имена компонентов совпадали со слотами. Если это ваши
компоненты, договоритесь с командой об именах. Для сторонних компонентов легко
написать свой конструктор.

\index{метаданные!в Component}

Теперь рассмотрим, как устроены зависимости. Очевидно, вызов
\verb|component/using| что-то сообщает компоненту, но последний от этого не
меняется. В нём нет поля \verb|:deps| или скрытого атома. Компонент хранит
зависимости в \emph{метаданных}.

Метаданные~--- это словарь дополнительной информации об объекте. Метаданные работают
с коллекциями и некоторыми типами Clojure (символ, кейворд, \verb|Var|). К
метаданным прибегают, чтобы дополнить объект, не изменяя его. Зависимости
компонента ложатся на эту схему.

Функция \verb|meta| вернёт метаданные объекта. Код ниже доказывает, что
конструктор добавил зависимости:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(-> {...} make-worker meta)
#:...component{:dependencies {:db :db}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(-> {...} make-worker meta)
#:com.stuartsierra.component{:dependencies {:db :db}}
  \end{clojure}
\end{english}

\fi

Другой способ увидеть их~--- задать переменной \verb|*print-meta*| истину. При
печати объекта в REPL появятся метаданные:

\index{REPL}
\index{печать!метаданных}
\index{clojure.core!*print-meta*}
\index{clojure.core!set"!}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(set! *print-meta* true)

(make-worker {...})
^#:...component{:dependencies {:db :db}}
#book.systems.comp.worker.Worker{...}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(set! *print-meta* true)

(make-worker {...})
^#:com.stuartsierra.component{:dependencies {:db :db}}
#book.systems.comp.worker.Worker{...}
  \end{clojure}
\end{english}

\fi

\subsection{Группировка слотов}

\index{слоты!группировка}

Слоты делятся на три группы: входные параметры, состояние и
зависимости. Вспомним компонент воркера:

\begin{english}
  \begin{clojure}
(defrecord Worker
    [options flag task db])
  \end{clojure}
\end{english}

В этом примере слот \verb|options| относится к инициализации, \verb|flag|
и~\verb|task| к состоянию, а \verb|db|~--- зависимость. Чем сложнее компонент,
тем больше слотов в каждой группе. Когда слоты в случайном порядке, трудно понять
их семантику. Считается хорошим тоном отделять слоты комментарием:

\begin{english}
  \begin{clojure}
(defrecord Worker
    [;; init
     options
     ;; runtime
     flag
     task
     ;; deps
     db])
  \end{clojure}
\end{english}

Первой идёт группа \verb|init|, входные параметры. От конструктора ожидают
такие же аргументы. В \verb|runtime| перечислены слоты, которые компонент
заполнит при старте. В \verb|deps| указаны зависимости. Они совпадают с
вектором ключей из функции \verb|using|.

Группировка слотов улучшает код, делает его понятнее. Договоритесь с командой,
чтобы внедрить эту практику. Когда слотов слишком много, это говорит о том, что
компонент переусложнён. Часть логики выносят в дочерний компонент и подключают в
зависимости первого.

На страницах книги мы не группируем слоты, потому что иначе код займёт много
места. В вашем проекте делайте это обязательно.

\subsection{Условная система}

\index{feature flags}

В главе про конфигурацию мы писали про \emph{feature flags} \page{feature-flags}.
Это параметры, которые включают пласты логики. С флагами отпадает нужда в новой сборке
приложения. Достаточно изменить конфигурацию и~перезагрузить сервис.

Иногда систему строят не линейно, а по условиям. Предположим, воркер
всё ещё в испытательном режиме. Добавим в конфигурацию поле с семантикой
<<включить воркер>>. Если оно ложь, система запустится без этого компонента.

\index{фичи}

Выделим в конфигурации группу \verb|:features| для флагов <<фич>>:

\begin{english}
  \begin{clojure}
{:features {:worker? true}
 :jetty {:join? false :port 8088}
 ...}
  \end{clojure}
\end{english}

Перепишем функцию \verb|make-system| с учётом флагов. Перед тем как попасть в
\verb|system-map|, компоненты проходят отбор. Выделим базовые компоненты,
которые работают всегда, и постепенно дополним их.

Макрос \verb|cond->| пропускает вектор по цепочке условий и форм. Если условие
\verb|worker?| истина, следующая форма добавит к вектору значения \verb|:worker|
и \verb|(make-worker {...})|. Ниже могут идти другие флаги и~выражения.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn make-system [config]
  (let [{:keys [features jetty
                pool worker]} config
        {:keys [worker?]} features
        comps-base [:server
                    (make-server jetty)
                    :db (make-db pool)]
        comps (cond-> comps-base
                worker?
                (conj :worker
                  (make-worker worker)))]
    (apply component/system-map comps)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn make-system [config]
  (let [{:keys [features jetty pool worker]} config
        {:keys [worker?]} features
        comps-base [:server (make-server jetty)
                    :db (make-db pool)]
        comps (cond-> comps-base
                worker?
                (conj :worker (make-worker worker)))]
    (apply component/system-map comps)))
  \end{clojure}
\end{english}

\fi

Убедимся, что флаг работает. Система~--- это запись, поэтому функция \verb|keys|
вернёт её ключи. Слот \verb|:worker| появляется в зависимости от~флага:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(keys (make-system
        {:features {:worker? false}}))
(:server :db)

(keys (make-system
        {:features {:worker? true}}))
(:server :db :worker)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(keys (make-system {:features {:worker? false}}))
(:server :db)

(keys (make-system {:features {:worker? true}}))
(:server :db :worker)
  \end{clojure}
\end{english}

\fi

Флаги облегчают работу с проектом. Некоторые компоненты сложны и требуют
специального окружения. Если можно задать их флагом, это принесёт пользу
всей команде.

\subsection{Спуск системы}

\index{системы!спуск}

Внутри системы компоненты свободно общаются друг с другом. Если одному из них
нужен другой, мы добавим зависимость и слот. Проблема возникает, когда к системе
обращается не компонент, а другая сущность.

В основном это случается, когда отдельные компоненты нужны обработчику
HTTP-запроса \page{first-handler}. Функция плохо ложится на идеи компонента:
последний хранит состояние, а функция избегает его. Запуск и остановка функции
не имеют смысла. Компонент и функция противоположны друг другу.

Рассмотрим случай, когда в запросе нужен компонент базы данных. Как спустить
часть системы в функцию, не нарушив принцип библиотеки? Глобальную переменную мы
не рассматриваем, потому что в данном случае это капитуляция. Помогут два
способа: проброс и~замыкание.

\index{системы!проброс}

\textbf{Проброс} означает, что отдельные компоненты передают в запросе. Вариант
имеет право на жизнь, потому что запрос~--- это часть сервера, а сервер~--- это
компонент. На основании этого последний может добавить поля запросу. Чтобы компонент
базы стал доступен серверу, подключим его в~зависимости. Изменим слоты сервера и
конструктор:

\begin{english}
  \begin{clojure}
(defrecord Server
  [options server db]) ;; db added

(defn make-server
  [options]
  (-> (map->Server {:options options})
      (component/using [:db])))
  \end{clojure}
\end{english}

Расширим метод сервера \verb|start|. Если раньше мы передавали \verb|app|
напрямую в \verb|run-jetty|, то теперь введём новый шаг. Функция
\texttt{make\--hand\-ler} оборачивает \verb|app| таким образом, что каждый запрос
в~\verb|app| дополнен базой.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; app factory
(defn make-handler [app db]
  (fn [request]
    (app (assoc request :db db))))

;; Lifecycle
(start [this]
  (let [handler (make-handler app db)
        server (run-jetty handler
                 options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
;; app factory
(defn make-handler [app db]
  (fn [request]
    (app (assoc request :db db))))

;; Lifecycle
(start [this]
  (let [handler (make-handler app db)
        server (run-jetty handler options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\fi

Пусть главная страница выводит данные из базы. Код ниже показывает, как
прочитать таблицу из HTTP-запроса. Чтобы не усложнять пример вёрсткой HTML,
вёрнем красиво напечатанные данные.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn app [{:keys [db]}]
  (let [data (db/query db
               "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint
               data))}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn app [{:keys [db]}]
  (let [data (db/query db "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint data))}))
  \end{clojure}
\end{english}

\fi

Со временем понадобятся другие компоненты, например очередь задач или
кэш. Поступим аналогично: добавим их в зависимости серверу и пробросим в
\verb|make-handler|.

\index{системы!подмножество}

Когда компонентов всё больше, хранить их на верхнем уровне запроса неудобно:
возникает риск конфликта ключей. Поместим их во вложенный словарь
\verb|:system|. Важно понимать, что в \verb|:system| не вся система, а
минимальное подмножество, необходимое для веб-части.

\index{системы!замыкание}

Подход с \textbf{замыканием} меняет дерево маршрутов. Оно уже не статично, а
приходит из функции-построителя. Функция принимает компоненты, которые нужны
обработчикам. Внутри мы вызываем их с запросом и зависимостями. Это меняет
сигнатуру функции: теперь у~обработчика может быть несколько аргументов (запрос,
база, кэш).

Чтобы упростить замыкание, в систему вводят группировочный компонент. Он ничего
не делает при запуске и остановке, а только аккумулирует зависимости. От
группировочного компонента зависит сервер. На базе него он строит дерево
маршрутов, где каждый обработчик принимает компонент первым аргументом.

Введём группировочный компонент \verb|:web|. Пока что он зависит только от
базы данных, но в будущем потребует что-то ещё:

\begin{english}
  \begin{clojure}
(defrecord Web [db])

(defn make-web []
  (-> (map->Web {})
      (component/using [:db])))
  \end{clojure}
\end{english}

\noindent
Подключим его в систему:

\begin{english}
  \begin{clojure}
(component/system-map
 :web    (make-web)
 :server (make-server jetty)
 :db     (make-db pool)
 :worker (make-worker worker))
  \end{clojure}
\end{english}

\index{компоненты!группировочные}

Исправим зависимость сервера: теперь это не база данных, а группировочный
\verb|web|:

\begin{english}
  \begin{clojure}
(defrecord Server
  [options server web])

(defn make-server [options]
  (-> (map->Server {:options options})
      (component/using [:web])))
  \end{clojure}
\end{english}

\index{макросы!defroutes}
\index{библиотеки!Compojure}

Вспомним, как мы строили маршруты. Макрос \verb|defroutes| вернёт функцию,
которая принимает запрос и возвращает ответ \page{compojure}.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/"
    request (page-index request))
  (GET "/hello"
    request (page-hello request))
  page-404)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
  \end{clojure}
\end{english}

\fi

Новое дерево маршрутов не статично, потому что зависит от компонента. Функция
\verb|make-routes| принимает группировочный компонент и возвращает маршруты,
замкнутые на нём. В функции \verb|page-index| и~другие приходят два аргумента:
компонент и запрос. Компонент будет в том состоянии, в каком его передали в
\verb|make-routes|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn make-routes [web]
  (routes
    (GET "/"
      request (page-index web request))
    (GET "/hello"
      request (page-hello web request))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn make-routes [web]
  (routes
   (GET "/"      request (page-index web request))
   (GET "/hello" request (page-hello web request))))
  \end{clojure}
\end{english}

\fi

\noindent
Метод \verb|start| сервера строит маршруты и передаёт в \verb|run-jetty|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(start [this]
  (let [routes (make-routes web)
        server (run-jetty
                 routes options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(start [this]
  (let [routes (make-routes web)
        server (run-jetty routes options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\fi

Рассмотрим обработчик \verb|page-index|, который обращается к базе
данных. Первый аргумент~--- это \verb|web|, хранилище компонентов. Распакуем его на
уровне сигнатуры. Далее обращаемся к компоненту \verb|db|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn page-index
  [{:keys [db]} request]
  (let [data (db/query db
               "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint
               data))}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn page-index
  [{:keys [db]} request]
  (let [data (db/query db "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint data))}))
  \end{clojure}
\end{english}

\fi

Проброс и замыкание решают одинаковую задачу. Разница в том, как передают
аргументы в функцию. Проброс удобен тем, что обычно обработчик принимает один
аргумент, и не придётся менять сигнатуру.

С другой стороны, передача компонентов в запросе не всегда очевидна. Когда в
запросе много полей, с ним трудно работать в~тестах и разработке. При печати
запроса или в логах вы получите слишком большой вывод. Вариант с замыканием и
двумя аргументами очевидней. Сигнатура прямо говорит о том, какие данные ожидают
на входе. Выбор зависит от соглашений в команде.

\subsection{Идемпотентность}

До сих пор мы писали компоненты так, что их повторный запуск привёл бы к
ошибке. Покажем это на примере веб-сервера:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def s-started
  (-> {:port 8088 :join? false}
      make-server
      component/start))

(component/start s-started)
;; BindException: Address already in use
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def s-started (-> {:port 8088 :join? false}
                    make-server
                    component/start))

(component/start s-started)
;; Execution error (BindException)
;; Address already in use
  \end{clojure}
\end{english}

\fi

В теле \verb|start| мы не проверяем, что сервер уже работает. При попытке
включить его повторно получим ошибку: порт занят. Это правильно: мы бы не
хотели, чтобы запустилось два сервера. Для других компонентов исключения может
не быть. Если повторно запустить базу данных, получим новый пул
соединений. Старый пул останется в памяти и будет работать. Так происходит
утечка ресурсов.

\index{идемпотентность}

Свойство, когда повторная операция возвращает тот же результат, называется
\emph{идемпотентность}. Компонент должен ему следовать, чтобы избежать утечки
ресурсов. Для этого мы проверяем слот перед тем, как открывать ресурс. Если слот
\verb|nil|, мы порождаем новый сервер и записываем в слот. В противном случае
сервер уже запущен и~возвращают \verb|this|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(start [this]
  (if server
    this
    (let [server (run-jetty
                   app options)]
      (assoc this :server server))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(start [this]
  (if server
    this
    (let [server (run-jetty app options)]
      (assoc this :server server))))
  \end{clojure}
\end{english}

\fi

\noindent
Аналогично работает \verb|stop|: перед остановкой ресурса слот проверяют на
пустоту:

\begin{english}
  \begin{clojure}
(stop [this]
  (when server
    (.stop server))
  (assoc this :server nil))
  \end{clojure}
\end{english}

Вариант с макросом \verb|or| немного короче. Мы всегда записываем слот, но
значение~--- это либо текущий сервер, либо новый.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(start [this]
  (let [server (or server
                   (run-jetty
                     app options))]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(start [this]
  (let [server (or server
                   (run-jetty app options))]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\fi

\subsection{Альтернативный способ}

На протяжении главы мы описывали компоненты р\'{е}кордами (типизированными
словарями). Р\'{е}корд порождает отдельный класс, который расширяют
протоколом. При вызове метода из протокола Clojure ищет реализацию по классу.

\index{clojure.core!defrecord}
\index{протоколы}
\index{метаданные}

\verb|Defrecord|~--- это рекомендуемый способ работать с Component. Он не лишён
недостатков: код с р\'{е}кордами занимает больше места, чем функции. Р\'{е}корд не
работает с \verb|dissoc|: если отнять у него слот, получится обычный словарь, у
которого пустая реализация \verb|start| и~\verb|stop|. Существует второй способ
описать компонент. Он занимает меньше кода, но требует глубокого понимания того,
как устроены методы в~Clojure.

Тезис о том, что поиск метода работает по классу, на самом деле неполный. Если
протоколу задано свойство \verb|:extend-via-metadata|, то вдобавок Clojure ищет
реализацию в метаданных объекта.

Предположим, в пространстве \verb|project.api| объявили протокол \verb|API| с
этим свойством и методом \verb|get-user|. Метод ожидает первым аргументом
объект, который реализует этот протокол. Однако вместо него можно передать
другой объект, в метаданных которого символ \verb|project.api/get-user| с
функцией. В этом случае метод разрешается в~функцию из метаданных.

У протокола \verb|Lifecycle| искомый флаг установлен в истину. Идея в~том, чтобы
сфабриковать объект, в метаданных которого реализации методов Component. На роль
объекта подойдёт словарь, потому что библиотека добавляет зависимости через
\verb|assoc|.

Опишем компонент сервера новым способом. Он состоит из трёх функций:
конструктора, \verb|start| и \verb|stop|. Конструктор принимает параметры
сервера и оборачивает их словарь. Функция \verb|with-meta| добавляет компоненту
метаданные. Их ключи — полные символы, которые указывают на методы протокола
\verb|Lifecycle|. В ключах пока что неизвестные функции запуска и остановки:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn init [options]
  (with-meta {:options options}
    {'com.stuartsierra.component/start
     start
     'com.stuartsierra.component/stop
     stop}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn init [options]
  (with-meta {:options options}
    {'com.stuartsierra.component/start start
     'com.stuartsierra.component/stop stop}))
  \end{clojure}
\end{english}

\fi

Напишем запуск компонента. Функция \verb|start| принимает словарь, который мы
вернули в \verb|init|. Для удобства назовём его \verb|this| и распакуем опции на
уровне сигнатуры. Запустим сервер и добавим к текущему словарю.

\begin{english}
  \begin{clojure}
(defn start
  [{:as this :keys [options]}]
  (let [server (run-jetty app options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

Остановка устроена аналогично. Обратите внимание, что в конце мы отсоединяем
ключ с помощью \verb|dissoc|. Потеря ключа ни на что не влияет, потому что поиск
метода работает не по классу, а по метаданным. Из-за \verb|dissoc| метаданные не
меняются.

\begin{english}
  \begin{clojure}
(defn stop
  [{:as this :keys [server]}]
  (.stop server)
  (dissoc this :server))
  \end{clojure}
\end{english}

В системе компонент ведёт себя как обычно. При построении системы вызывают
функцию \verb|init| с параметрами конфигурации. В~момент запуска библиотека
вызывает метод \verb|start| у всех сущностей, и~для сервера сработает
реализация из метаданных.

В зависимостях ничего не меняется: их также указывают через \verb|using| и с~вектором
или словарём. Работает и второй способ, когда конструктор <<заряжает>>
компонент зависимостями при создании.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn init [options]
  (->
    {:options options}
    (with-meta
     {'com.stuartsierra.component/start
      start
      'com.stuartsierra.component/stop
      stop})
    (component/using [:compA :compB])))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn init [options]
  (-> {:options options}
      (with-meta
        {'com.stuartsierra.component/start start
         'com.stuartsierra.component/stop stop})
      (component/using [:compA :compB])))
  \end{clojure}
\end{english}

\fi

\noindent
Методам \verb|start| и \verb|stop| нужно только распаковать их на уровне
сигнатуры:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn start
  [{:as this
    :keys [compA compB options]}]
  ...)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn start
  [{:as this :keys [compA compB options]}]
  ...)
  \end{clojure}
\end{english}

\fi

Чтобы убедиться, что компонент обладает всем необходимым, исследуем его
метаданные после \verb|init|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(-> (init {:port 8080})
    meta
    clojure.pprint/pprint)

#:com.stuartsierra.component
 {start #function[.../start]
  stop  #function[.../stop]
  :dependencies
  {:compA :compA :compB :compB}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(-> (init {:port 8080})
    meta
    clojure.pprint/pprint)

#:com.stuartsierra.component
  {start #function[book.systems.comp.server/start]
   stop #function[book.systems.comp.server/stop]
   :dependencies {:compA :compA :compB :compB}}
  \end{clojure}
\end{english}

\fi

\index{метаданные}
\index{печать!метаданных}
\index{clojure.core!*print-meta*}

\noindent
Для отладки таких компонентов пригодится переменная \verb|*print-meta*|, о
которой мы говорили в прошлой главе \page{print-meta}.

Альтернативный способ не отменяет сказанного в этой главе. Как и с
\verb|defrecord|, компонент должен следовать практикам, что мы рассмотрели. Даже
если новая запись нравится вам больше, не торопитесь переходить на неё. Для
начала разберитесь с классическими компонентами, как рекомендует библиотека.

На этом мы заканчиваем обзор Component и переходим к третьей библиотеке~---

\section{Integrant}

\index{библиотеки!Integrant}

Библиотека \footurl{Integrant}{https://github.com/weavejester/integrant}[Integrant][1mm]~--- это
следующий виток в развитии системы. Мы поместили её в конец обзора по нескольким
причинам. Integrant отталкивается от идей Component, которые мы только что
рассмотрели. Библиотека устроена гибче и в целом более продвинута. Перечислим
основные отличия.

\index{ООП}

Сущности Component напоминают классы и ООП. В Clojure на~фоне данных и функций
это выглядит усложнением. Пусть компонент будет функцией. Она проще объекта,
потому что на функцию действует только одна операция~--- вызов.

Component выделяет только два состояния~--- \verb|start| и
\verb|stop|. Integrant предлагает дополнительные стадии: паузу и
возобновление, валидацию спекой, подготовку параметров. По умолчанию эти стадии
пусты, но компонент может дополнить их. С таким подходом у нас больше контроля
за системой.

\index{декларативность}

Integrant декларативен: можно описать систему в файле и считать одной
функцией. Это выгодное отличие от Component, где систему строят вручную.

Integrant лоялен к зависимостям. В Component зависимость требует два шага~---
добавить слот и метаданные,~--- а в Integrant один. В Component зависимость
может быть только другим компонентом. Иногда объект оборачивают в компонент
только чтобы выполнить это требование. В Integrant зависимостью может быть что
угодно: словарь, футура, функция.

\subsection{Базовое устройство}

Работу с Integrant начинают с описания будущей системы. Это словарь, за который
цепляется дальнейшая логика. Ключ словаря~--- это машинное имя компонента, а
значение~--- параметры запуска. Система ниже состоит из веб-сервера и базы
данных.

\begin{english}
  \begin{clojure}
(def config
  {::server {:port 8080 :join? false}
   ::db {:username      "book"
         :password      "book"
         :database-name "book"
         :server-name   "127.0.0.1"
         :port-number   5432}})
  \end{clojure}
\end{english}

\index{мультиметоды!в Integrant}

Система и компоненты связаны через мультиметоды. Чтобы добавить реакцию на
событие, мы расширяем нужный мультиметод ключом компонента. Например, при старте
система вызывает метод \verb|init-key| для каждого ключа. Чтобы объяснить
системе, как запускать сервер, метод расширяют ключом \verb|::server|.

Integrant ожидает от ключа минимум два метода: запуск и остановку. Это главные
действия, поэтому для них нет реакции по умолчанию. Другие события не
обязательны и остаются на ваше усмотрение.

\subsection{Первые компоненты}

\index{компоненты!в Integrant}

Напишем компоненты сервера и базы. Они просты и не имеют
зависимостей. Подготовьте модуль \verb|integrant.clj| с шапкой:

\begin{english}
  \begin{clojure}
(ns book.integrant
  (:require [integrant.core :as ig]))
  \end{clojure}
\end{english}

Для краткости опустим импорты \verb|Jetty|, \verb|HikariCP| и других
библиотек. Они аналогичны примерам из Mount и Component.

Начнём с сервера. Метод \verb|init-key| принимает ключ и словарь опций. Это
значения \verb|::server| и \verb|{:port 8080 :join? false}| из
конфигурации. Метод должен вернуть состояние компонента. В нашем случае это
результат \verb|run-jetty|.

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::server
  [_ options]
  (run-jetty app options))
  \end{clojure}
\end{english}

\index{пул соединений}

Ключ известен из определения метода, поэтому первый аргумент затеняют
подчёркиванием. По аналогии опишем базу данных. Её состояние~--- это спека JDBC с
пулом соединений.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::db
  [_ options]
  {:datasource
    (cp/make-datasource options)})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::db
  [_ options]
  {:datasource (cp/make-datasource options)})
  \end{clojure}
\end{english}

\fi

Функция \verb|init| пробегает по конфигурации и вызывает для каждого ключа
\verb|init-key|. Получим словарь с теми же ключами, но на месте параметров
появится состояние компонента. Сохраним запущенную систему в переменную, чтобы
позже выключить её.

\index{инициализация}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def _sys (ig/init config))

(keys _sys)
(:book.integrant/db
 :book.integrant/server)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def _sys (ig/init config))

(keys _sys)
(:book.integrant/db :book.integrant/server)
  \end{clojure}
\end{english}

\fi

Остановка системы называется \verb|halt|. Метод \verb|halt-key!| определяет,
как выключить компонент. Он принимает ключ и состояние, которое получили из
метода \verb|init-key|. Опишем остановку сервера и базы:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defmethod ig/halt-key! ::server
  [_ server]
  (.stop server))

(defmethod ig/halt-key! ::db
  [_ db-spec]
  (-> db-spec
      :datasource
      cp/close-datasource))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmethod ig/halt-key! ::server
  [_ server]
  (.stop server))

(defmethod ig/halt-key! ::db
  [_ db-spec]
  (-> db-spec :datasource cp/close-datasource))
  \end{clojure}
\end{english}

\fi

\noindent
Функция \verb|halt!| остановит всю систему. Передайте в неё результат
\verb|ig/init|:

\begin{english}
  \begin{clojure}
(ig/halt! _sys)
  \end{clojure}
\end{english}

\subsection{Зависимости}

\index{граф зависимостей}
\index{зависимости!Integrant}

Чтобы указать зависимости, в опции добавляют ссылку. При запуске Integrant ищет
ссылки в системе и строит граф зависимостей. Ссылку задают функцией
\verb|ig/ref|. Она принимает ключ, от которого зависит компонент.

Рассмотрим зависимость на примере воркера. Добавьте в конфигурацию ключ, как в
примере ниже. Чтобы отделить опции компонента от зависимостей, поместим их в
отдельное поле \verb|:options|.

\begin{english}
  \begin{clojure}
{::worker {:options {:sleep 1000}
           :db (ig/ref ::db)}}
  \end{clojure}
\end{english}

Когда \verb|init-key| дойдёт до ключа \verb|::worker|, в \verb|:db| будет
значение, которое \verb|init-key| вернул для \verb|::db|. Привёдем код
запуска и остановки воркера. Поскольку это уже третья реализация, оставим только
основную часть. Если вы забыли, как устроен воркер, обратитесь к разделу, где мы
писали его в первый раз \page{worker}.

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::worker
  [_ {:keys [db options]}]
  (let [flag (atom true)
        task (make-task db flag options)]
    {:flag flag :task task}))

(defmethod ig/halt-key! ::worker
  [_ {:keys [flag task]}]
  (reset! flag false)
  (while (not (realized? task))
    (Thread/sleep 300)))
  \end{clojure}
\end{english}

\subsection{Параллели с Component}

Несколько приёмов, что мы рассмотрели в Component, работают и
в~Integrant. Вспомним некоторые их них.

\index{системы!хранение}

\textbf{Глобальное хранилище.} Чтобы управлять системой, нужно где-то её
хранить. Проще всего добавить глобальную переменную и функции запуска и
остановки.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defonce ^:private system nil)

(def alter-system
  (partial alter-var-root #'system))

(defn system-start []
  (alter-system
    (constantly (ig/init config))))

(defn system-stop []
  (alter-system ig/halt!))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defonce ^:private system nil)

(def alter-system (partial alter-var-root #'system))

(defn system-start []
  (alter-system (constantly (ig/init config))))

(defn system-stop []
  (alter-system ig/halt!))
  \end{clojure}
\end{english}

\fi

Как и в Component, система должна быть приватной. Недопустимо, чтобы потребители
свободно обращались к ней.

\index{системы!ожидание}

\textbf{Ожидание и сигналы.} Перед тем как закончить работу, приложение ожидает,
пока все компоненты остановятся. Макрос \verb|with-handler| и перехват
сигналов работают аналогично для Integrant:

\begin{english}
  \begin{clojure}
(with-handler :term
  (log/info "caught SIGTERM, quitting")
  (system-stop)
  (log/info "all components shut down")
  (exit))
  \end{clojure}
\end{english}

\index{системы!спуск}

\textbf{Спуск системы и маршруты.} В Integrant легче обратиться к системе из
HTTP-запроса. Обработчик может быть компонентом, который зависит от базы. Пусть
страница выводит число записей в~базе. Добавим в систему новый ключ и ссылку на
базу:

\begin{english}
  \begin{clojure}
{::handler {:db (ig/ref ::db)}}
  \end{clojure}
\end{english}

\noindent
В запуске ключа вернём обработчик запроса, замкнутый на \verb|db|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::handler
  [_ {:keys [db]}]
  (fn [request]
    (let [query "select count(*) as total
                 from requests"
          result (jdbc/query db query)
          total (-> result first :total)]
      {:status 200
       :body (format
               "You've got %s records."
               total)})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::handler
  [_ {:keys [db]}]
  (fn [request]
    (let [query "select count(*) as total from requests"
          result (jdbc/query db query)
          total (-> result first :total)]
      {:status 200
       :body (format "You've got %s records." total)})))
  \end{clojure}
\end{english}

\fi

\noindent
Доработаем сервер, чтобы он зависел от обработчика:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{::server {:options {:port 8080
                     :join? false}
           :handler (ig/ref ::handler)}}

(defmethod ig/init-key ::server
  [_ {:keys [handler options]}]
  (run-jetty handler options))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{::server {:options {:port 8080 :join? false}
           :handler (ig/ref ::handler)}}

(defmethod ig/init-key ::server
  [_ {:keys [handler options]}]
  (run-jetty handler options))
  \end{clojure}
\end{english}

\fi

Браузер покажет фразу You've got N records, где \verb|N|~--- число записей
в базе. Как и в Component, \verb|::handler| может вернуть не отдельную
страницу, а дерево маршрутов с помощью Compojure.

\index{системы!условные}

\textbf{Условное построение.} Перед запуском систему можно изменить по
условию. Специальная функция определяет, можно ли запустить воркер на этой
машине. Если можно, добавим в систему ключ компонента и его настройки.

\begin{english}
  \begin{clojure}
(cond-> sys-config
  (is-worker-supported?)
  (assoc ::worker {:options {:sleep 1000}
                   :db (ig/ref ::db)}))
  \end{clojure}
\end{english}

Другой способ запустить подмножество системы похож на
Mount \page{mount-selective}. Функция \verb|init| принимает необязательный
список ключей, которые следует включить. Список готовят заранее по какому-то
правилу. Ниже мы берём все ключи конфигурации и удаляем некоторые по условию.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [components (-> config keys set)
      components
      (cond-> components
        (not (is-worker-supported?))
        (disj ::worker))]
  (ig/init config components))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [components (-> config keys set)
      components (cond-> components
                   (not (is-worker-supported?))
                   (disj ::worker))]
  (ig/init config components))
  \end{clojure}
\end{english}

\fi

\subsection{Потеря ключей}

\index{ключи!потери}
\index{синтаксис!:: (пространство)}

Для компонентов указывают полные (квалифицированные) ключи: \verb|::server|,
\verb|::db|. Двойное двоеточие означает текущее пространство имён, в котором
объявлен ключ. Запись \verb|::db|~--- это краткий вариант
\verb|:book.integrant/db|.

Когда ключ полный (с пространством), легко понять, в каком модуле он объявлен. В
системах бывает больше десяти компонентов. Представьте, что возникла проблема с
ключом \verb|:queue|. Как понять, в каком модуле он находится?  Наоборот, ключ
\texttt{:my-project.utils.queue\-/queue} содержит эту информацию. Всегда используйте
полные ключи.

Возможна ситуация, что вы забыли импортировать модуль, в котором расширили
мультиметод. Если модуль не загружен, Integrant не узнает о компоненте. Иногда
это вгоняет в ступор: вы помните, что писали код, но компонента нет. Похожую
проблему мы рассмотрели в Mount \page{mount-main}. Чтобы избежать ошибки,
добавьте все модули с~компонентами в шапку главного модуля, который загружается
всегда. Пусть это будет модуль системы.

\begin{english}
  \begin{clojure}
(ns project.system
  (:require project.db
            project.server
            project.worker
            project.utils.queue))
  \end{clojure}
\end{english}

Утилиты для проверки синтаксиса (линтеры) могут выдать предупреждение. С их
точки зрения вы добавили модуль, но не используете его, потому что в коде нет
выражения \verb|project.db/<something>|. Чтобы подавить предупреждения,
исправьте настройки линтера. Добавьте \verb|project.db| в секцию known
namespaces или аналогичную.

\index{пространства имён}

\mnoindent
Integrant предлагает функцию \verb|load-namespaces| для автоматической загрузки
модулей. На вход подают конфигурацию системы. Для каждого ключа функция ищет его
пространство и загружает его. Вот как выглядит промышленная система с ключами из
разных модулей:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def config
  {:project.server/server
   {:options {:port 8080 :join? false}
    :handler (ig/ref
               :project.handlers/index)}
   :project.db/db {...}
   :project.worker/worker
   {:options {:sleep 1000}
    :db      (ig/ref :project.db/db)}
   :project.handlers/index
   {:db (ig/ref :project.db/db)}})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def config
  {:project.server/server
   {:options {:port 8080 :join? false}
    :handler (ig/ref :project.handlers/index)}
   :project.db/db {...}
   :project.worker/worker
   {:options {:sleep 1000}
    :db      (ig/ref :project.db/db)}
   :project.handlers/index
   {:db (ig/ref :project.db/db)}})
  \end{clojure}
\end{english}

\fi

\noindent
Чтобы загрузить все модули, которые участвуют в системе, выполните:

\begin{english}
  \begin{clojure}
(ig/load-namespaces config)
  \end{clojure}
\end{english}

Новичкам советуем воздержаться от автоматических импортов. Добавляйте их явно в
\verb|ns|: способ хоть и многословен, но очевиден. Прибегайте к
\verb|load-namespaces| только если точно знаете, как работают пространства
имён и их загрузка.

\subsection{Система в файле}

\index{декларативность}

Integrant поощряет декларативный подход. Конфигурация системы~--- это статичный
словарь. Для экономии места систему выносят в ресурс EDN и читают на старте
приложения.

\index{теги!Integrant}

Читатель заметит, что мы указали ссылки функцией \verb|ig/ref| и~не совсем
ясно, как выразить их в файле. Тег \verb|#ig/ref| работает как одноимённая
функция.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:project.worker/worker
 {:options {:sleep 1000}
  :db #ig/ref :project.db/db}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:project.worker/worker {:options {:sleep 1000}
                         :db #ig/ref :project.db/db}}
  \end{clojure}
\end{english}

\fi

\index{модули!clojure.edn}

\mnoindent
Integrant предлагает свою версию \verb|read-string| для чтения EDN. Это обёртка
над обычным \verb|clojure.edn/read-string|, но с тегами семейства
\verb|#ig/|. Чтобы прочитать систему из файла, выполните:

\begin{english}
  \begin{clojure}
(def config
  (-> "config.edn" slurp ig/read-string))
  \end{clojure}
\end{english}

\index{переменные!среды}

Из главы про конфигурацию мы помним, что нежелательно хранить в файле пароли и
ключи доступа \page{password-note}. Компонент \verb|:project.db/db| нарушает
этот принцип: пароль к базе записан открыто. Сделаем так, чтобы парсер читал
пароль из среды.

Поместим конфигурацию в файл \texttt{integrant\-.test.edn} (фрагмент):

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:project.db/db
 {:password #env DB_PASSWORD}
 :project.worker/worker
 {:options {:sleep 1000}
  :db #ig/ref :project.db/db}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:project.db/db {:password #env DB_PASSWORD}
 :project.worker/worker {:options {:sleep 1000}
                         :db #ig/ref :project.db/db}}
  \end{clojure}
\end{english}

\fi

Функция \verb|ig/read-string| принимает дополнительные теги EDN. Integrant
объединит их со своими при чтении файла. Обернём чтение конфигурации в
функцию. Первым аргументом в \verb|ig/read-string| укажем словарь с тегом
\verb|#env| из прошлой главы. Integrant дополнит наш словарь собственным,
поэтому оба \verb|#ig/ref| и \verb|#env| будут работать.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn load-config [filename]
  (ig/read-string
    {:readers {'env tag-env}}
    (slurp filename)))

(load-config "integrant.test.edn")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn load-config [filename]
  (ig/read-string {:readers {'env tag-env}}
                  (slurp filename)))

(load-config "integrant.test.edn")
  \end{clojure}
\end{english}

\fi

\noindent
Результат:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:project.db/db
 {:password "c8497b517da25"}
 :project.worker/worker
 {:options {:sleep 1000}
  :db
  #integrant.core.Ref{:key
                      :project.db/db}}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:project.db/db {:password "c8497b517da25"}
 :project.worker/worker
 {:options {:sleep 1000}
  :db #integrant.core.Ref{:key :project.db/db}}}
  \end{clojure}
\end{english}

\fi

\subsection{Наследование ключей}

\index{ключи!наследование}
\index{наследование}

В Clojure ключи могут строиться в иерархию. Функция \verb|derive| принимает
два ключа и задаёт превосходство первого над вторым.

\index{clojure.core!derive}

\begin{english}
  \begin{clojure}
(derive ::postgresql ::database)
  \end{clojure}
\end{english}

\mnoindent
Когда мультиметод ищет действие по ключу, он учитывает наследование. Если метод
задан для \verb|::database|, вызов с \verb|::postgresql| не приведёт к ошибке:
сработает версия \verb|::database|.

Integrant работает на мультиметодах, поэтому из наследования можно извлечь
пользу. Представим проект с двумя базами данных: мастер для записи и реплика для
чтения. Компоненты \verb|::db-master| и~\verb|::db-replica| отличаются только
входными параметрами.

Если бы мы не знали про наследование, то писали бы \verb|ig/init-key|
и~\verb|ig/halt-key!| для каждого ключа. Это повторяет код и считается плохой
практикой. Мы уже описали компонент \verb|::db| для общего доступа к
базе. Унаследуем от него два новых:

\begin{english}
  \begin{clojure}
(derive ::db-master ::db)
(derive ::db-replica ::db)
  \end{clojure}
\end{english}

Обновим конфигурацию. Для реплики выставим флаг \verb|:read-only|, чтобы
обезопасить себя от записи не в тот источник. Обратите внимание на
зависимости. Воркер \emph{пишет} данные в базу и поэтому ссылается на
\verb|::db-master|. Компонент \verb|::hander| только \emph{читает} данные,
поэтому зависит от \verb|::db-replica|. Пример конфигурации см. в~листинге
\ref{fig:config-refset}.

\begin{listing}[ht!]

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def config
  {::server {:options {:port 8080
                       :join? false}
             :handler (ig/ref ::handler)}
   ::db-master {;; other fields
                :read-only false}
   ::db-replica {;; other fields
                 :read-only true}
   ::worker {:options {:sleep 1000}
             :db (ig/ref ::db-master)}
   ::handler {:db (ig/ref
                    ::db-replica)}})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def config
  {::server {:options {:port 8080 :join? false}
             :handler (ig/ref ::handler)}
   ::db-master {;; other fields
                :read-only false}
   ::db-replica {;; other fields
                 :read-only true}
   ::worker {:options {:sleep 1000}
             :db (ig/ref ::db-master)}
   ::handler {:db (ig/ref ::db-replica)}})
  \end{clojure}
\end{english}

\fi

\caption{Конфигурация с двумя базами и ссылками на них}
\label{fig:config-refset}

\end{listing}

Функция и тег \verb|ig/refset| вернут множество ссылок с учётом
иерархии. Предположим, один из компонентов ожидает все базы данных, чтобы
выполнить на них служебный запрос. Чтобы не ссылаться на каждую базу вручную,
укажем корневой ключ \verb|::db|.

Для этого добавим компонент \texttt{::db-main\-te\-nance}. Он зависит от всех баз
через \verb|refset|. Метод \verb|init-key| вернёт фоновую задачу, которая
пробегает по базам и выполняет запрос. Её запуск и остановка аналогичны
воркеру. Пример ниже показывает, как добраться до обеих баз из параметров.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{::db-maintenance
 {:dbs (ig/refset ::db)}}

(defmethod ig/init-key ::db-maintenance
  [_ {:keys [dbs]}]
  (future
    (every-1h-interval
      (doseq [db dbs]
        (run-system-query db)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{::db-maintenance {:dbs (ig/refset ::db)}}

(defmethod ig/init-key ::db-maintenance
  [_ {:keys [dbs]}]
  (future
    (every-1h-interval
      (doseq [db dbs]
        (run-system-query db)))))
  \end{clojure}
\end{english}

\fi

\subsection{Другие стадии компонента}

\index{компоненты!стадии}

Кроме запуска и остановки, Integrant выделяет другие стадии компонента. В
отличие от \verb|init| и \verb|halt!|, их мультиметодам задано пустое действие
по умолчанию (вернуть \verb|nil| или исходный объект). Чтобы подписать компонент
на событие, расширьте мультиметод его ключом. Рассмотрим несколько полезных
стадий.

\subsection{Подготовка}

Метод \verb|ig/prep-key| служит для подготовки параметров. В основном это их
объединение с набором по умолчанию. Предположим, методом проб и ошибок мы нашли
идеальные метрики пула БД. Чтобы не указывать в конфигурации все поля, вынесем
их в словарь по~умолчанию.

\begin{english}
  \begin{clojure}
(def db-defaults
  {:auto-commit        false
   :read-only          false
   :connection-timeout 30000
   :idle-timeout       600000
   :max-lifetime       1800000
   :maximum-pool-size  10})

(defmethod ig/prep-key ::db
  [_ options]
  (merge db-defaults options))
  \end{clojure}
\end{english}

Метод \verb|prep-key| объединяет его с параметрами. В конфигурации достаточно
указать только поля доступа и, если требуется, переопределения для частных
случаев:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{::db {;; override the default
       :auto-commit   true
       :adapter       "postgresql"
       :username      "book"
       :password      "book"
       :database-name "book"
       :server-name   "127.0.0.1"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{::db {:auto-commit   true ;; override the default
       :adapter       "postgresql"
       :username      "book"
       :password      "book"
       :database-name "book"
       :server-name   "127.0.0.1"}}
  \end{clojure}
\end{english}

\fi

Функция \verb|ig/prep| принимает конфигурацию и готовит каждый ключ. Чтобы не
забыть этот шаг, добавьте его в \verb|load-config|.

\subsection{Спека}

\index{spec!в Integrant}

Метод \verb|ig/pre-init-spec| связывает компонент со спекой. Если метод вернул
спеку, она проверит параметры компонента. Убедимся, что задали все поля в
подключении к базе данных:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def :db/username string?)
(s/def :db/database-name string?)
;; host, password, etc

(defmethod ig/pre-init-spec ::db [_]
  (s/keys :req-un [:db/username
                   :db/database-name]))
                   ;; etc
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def :db/username string?)
(s/def :db/database-name string?)
;; host, password, etc

(defmethod ig/pre-init-spec ::db [_]
  (s/keys :req-un [:db/username
                   :db/database-name])) ;; etc
  \end{clojure}
\end{english}

\fi

\noindent
Если передать неверные параметры, получим ошибку Spec. Её сообщение и
отчёт \verb|explain| знакомы вам из прошлых глав \page{spec-explain}.

\subsection{Приостановка}

\index{системы!остановка}

Кроме запуска и остановки, Integrant выделяет третье состояние системы~---
\verb|suspended| \eng{приостановленный}. В нём компонент не теряет состояние, а
только ставит на паузу внутренние процессы. Если это потребитель сообщений из
очереди, он перестаёт читать источник, но не закрывает соединение. Обратная
операция называется \verb|resume| \eng{возобновить}. При возобновлении
компонент, не порождая новых соединений, продолжает работу.

\mnoindent
По умолчанию эти события работают как \verb|halt| и \verb|init|. Чтобы
задать особую реакцию на \verb|suspend| и \verb|resume|, расширьте методы
\texttt{ig/sus\-pend\--key!} и \verb|ig/resume-key|. Это потребует углублённого
чтения документации. Оставим тему читателю на самостоятельное изучение.

\section{Заключение}

Как машина складывается из деталей, так программа состоит из компонентов. Ими
управляет система~--- соглашение о том, как устроены и~связаны компоненты друг с
другом.

Каждый проект нуждается в системе, и чем дольше он развивается, тем сильнее
потребность. Если в проекте нет соглашения о том, как писать составные части, он
начинает буксовать. Со временем проект станет слишком затратным в поддержке.

Clojure предлагает несколько способов построить систему. Наиболее популярны
библиотеки Mount, Component и Integrant. Они исповедуют разные подходы, так что
каждый разработчик найдёт то, что ему по душе.

Mount отталкивается от глобальных переменных. Если проект написан, как в примере
ниже:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def server
  (run-jetty app {:port 8080})),
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def server (run-jetty app {:port 8080})),
  \end{clojure}
\end{english}

\fi

\noindent
то портировать его на Mount будет легко. Переменная \verb|server| станет
сущностью, которая меняет значение по команде. Mount подойдёт тем, кто недавно
познакомился с Clojure.

Component делает шаг в сторону настоящих компонентов. Мы задаём сущности, которые
изолируют состояние. Доступ к компоненту определяют методы, которые он
реализует. Компоненты и протоколы напоминают объекты из современных языков. По
этой причине Component обвиняют в раздутости, <<энтерпрайзности>>.

Иногда решение на компонентах занимает больше места, чем на~атомах и функциях. С
другой стороны, именно Component даёт понимание того, как строить устойчивые
системы. Заметим, что б\'{о}льшую часть вопросов мы обсудили в разделе именно
про Component.

Проект Integrant идёт дальше: он лишён тяжести ООП и в целом более
<<кложурный>>. Integrant опирается на идиомы и техники, принятые в Clojure, и
этим подкупает опытных разработчиков.

Мы не ставим цель выяснить, какая из библиотек лучше. Не бросайтесь переписывать
проект с условного Mount на Component или наоборот. Это изнуряющий труд, и вы не
поймёте, каких преимуществ достигли, пока не ощутите в них потребность.

Вместо споров о том, \emph{какая} система лучше, подумайте, \emph{зачем} система
нужна проекту. Когда ответ очевиден, технические решения найдутся сами.
