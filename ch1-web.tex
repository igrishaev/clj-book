\chapter{Веб-разработка}

\begin{teaser}
В первой главе мы рассмотрим, как писать веб-приложения на Clojure. Поговорим о
передаче данных по протоколу HTTP. Какие абстракции над ним возводят и что
предлагает Clojure. Чем хорош функциональный подход и почему разработка на~нём
удобнее.
\end{teaser}

\index{организации!Cognitect}
\index{организации!StackOverflow}

Каждый год компания Cognitect \footurl{опрашива\-ет}{https://cognitect.com/blog/2017/1/31/clojure-2018-results}[Cognitect 2018]
разработчиков на~Clojure. Один из вопросов уточняет, в какой области вы
работаете. В~2010 году под веб писала половина опрошенных. К~2018 году эта цифра
выросла до 80\%, что уже четыре человека из пяти. Похожую динамику показывают \footurl{опросы StackOverflow}{https://insights.stackoverflow.com/survey/2018}[Stack\-Overflow 2018][10mm].
Согласно им, всё больше инженеров переходят в веб из смежных областей.

Если вы найдёте работу на Clojure, скорее всего это будет веб-приложение. Мы
специально не говорим <<сайт>>, потому что термин уходит в прошлое. Сегодня
веб-приложение~--- это не только текст с~картинками. В широком плане это сложный
обмен данными по HTTP.

Протокол служит для передачи разметки HTML, но со временем подошёл и для
данных. Его дизайн оказался настолько гибким, что не пришлось менять
стандарт. Прежде чем перейти к Clojure, освежим в~памяти устройство протокола:
из каких частей он состоит и как с ним работает сервер. Это важно, потому что
языки и фреймворки меняются, а протокол нет.

\section{Основы HTTP}

\index{HTTP}

Протокол HTTP работает поверх стека TCP/IP. В широком смысле протоколы~--- это
соглашения о том, как обмениваться данными. Они записаны в официальных
документах. Документ HTTP называется \footurl{RFC~2616}{https://tools.ietf.org/html/rfc2616}[RFC~2616][-5mm].
С~ним сверяются разработчики фреймворков и браузеров, чтобы код работал
на разных языках и платформах.

HTTP удобен тем, что это текст. Не нужно парсить байты, чтобы понять, что
происходит. Протокол работает и с бинарными данными, но~главные его части
остаются текстом. В HTTP различают запрос и~ответ. Оба состоят из трёх частей:
первая строка, заголовки и тело.

Первая (стартовая) строка несёт самую важную информацию. Её формат отличается
для запроса и ответа. Для запроса это метод, путь и версия, для ответа~---
статус, сообщение и версия.

\index{HTTP!заголовки}

Заголовки~--- это пары ключей и значений. В коде их описывают словарём. Заголовки
несут дополнительные сведения о~запросе или ответе. Например,
\verb|Content-Type| сообщает, как читать тело. Был ли это XML- или
JSON-документ? Программа сверяет заголовок и~читает тело должным образом.

После заголовков следует тело. Им может быть что угодно~--- текст, пары полей и
значений, JSON, картинка. Стандарт допускает смешанный тип,
\verb|multipart-encoding|. Тело такого запроса состоит из ячеек, в каждой из
которых своё содержимое: текст, картинка, снова текст, архив.

Рассмотрим примеры трафика HTTP. Именно в таком виде его передают по сети. Ниже
запрос к главной странице Google по слову clojure:

\begin{english}
  \begin{http}
GET /search?q=clojure HTTP/1.1
Host: google.com
Accept-Language: en-us
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0)
  \end{http}
\end{english}

А это POST-запрос с JSON:

\begin{english}
  \begin{http}
POST /api/users/ HTTP/1.1
Host: example.com
Content-Type: application/json

{"username": "John", "city": "NY"}
  \end{http}
\end{english}

Обратите внимание на пустую строку выше: она отделяет тело от заголовков. Ответ
на этот запрос:

\begin{english}
  \begin{http}
HTTP/1.1 200 OK
Date: Tue, 19 Mar 2019 15:57:11 GMT
Server: Nginx
Connection: close
Content-Type: application/json

{
  "code": "CREATED",
  "message": "User has been created successfully."
}
  \end{http}
\end{english}

Видно, как изящно устроен протокол: данные идут по убыванию важности. Прочитав
только первую строку, клиент и~сервер готовы принять решение о~том, что делать
дальше.

\index{HTTP!404}

Рассмотрим случай, когда метод и путь запроса равны \verb|GET /about|, но такой
страницы не существует. Сервер проверит путь по таблице маршрутов. Если его нет,
получим ответ со статусом 404. Статус идёт раньше тела, что открывает путь для
оптимизации. Логика клиента может быть такова, что, получив негативный статус,
он пропустит ответ и потому справится быстрее. Подход выгоден и серверу, потому
что ему не придётся пересылать тело.

Чтение и разбор всего содержимого занимает много времени. Современные фреймворки не
делают этого зря. По заголовку \verb|Content-Type| они определяют, стоит ли
читать тело. Если приложение работает только с~JSON, то для \verb|text/xml|
получим ошибку. Аналогично поступают с~заголовком \verb|Content-Length|, где
указана длина тела в байтах. Если значение больше лимита, сервер отклонит запрос
до чтения.

Главные части запроса~--- это \emph{метод} и \emph{путь}. Путь указывает
на~определённый ресурс на сервере. Иногда он означает файл относительно заданной
папки. Например, \verb|/images/map.jpg| вернёт одноимённый файл из
\verb|/var/www/static|. Раздача файлов~--- это частный случай пути, и у него много других
сценариев. В пути может быть номер сущности: \verb|/users/9677/profile|. Сервер
можно настроить так, что запросы с~префиксом \verb|/internal| и \verb|/public|
уходят на разные машины.

Метод запроса означает действие, которое мы намерены выполнить над
ресурсом. Основные методы~--- это \verb|GET|, \verb|POST|, \verb|PUT| и
\verb|DELETE|, что значит прочитать, создать, обновить и удалить ресурс. Запрос
\verb|POST /users/| означает создать пользователя, а \verb|GET /users/|~---
получить список пользователей.

Главный параметр ответа~--- это статус, целое положительное число. Статусы
группируют по старшей цифре. Значения с 200 до 299 считают положительными. Они
означают, что сервер обработал запрос без ошибки. Для краткости интервал
обозначают \verb|2хх|.

Значения из группы \verb|3хх| связаны с направлением на другую страницу. В
заголовке \verb|Location| указан адрес, куда нужно отправить новый
запрос. Современные браузеры и клиенты делают это автоматически. По адресу
\verb|http://yandex.ru| получим пустой документ с заголовком
\verb|Location: https://yandex.ru|. Разница в схеме протокола: сервер обязывает
перейти на безопасное соединение. Мы даже не заметим этого, потому что браузер
сделает это сам.

Статусы \verb|4хх| означают ошибку на стороне клиента. Чаще других встречается
404~--- страница не найдена. Если прислать ошибочные данные, сервер ответит: 400
Bad request. Когда нет прав доступа, получим код 403.

Значения из группы \verb|5хх| говорят о проблеме на стороне сервера. В основном
это ошибки в коде: отказ базы данных, нехватка места на~диске. Если сервер на
техобслуживании, он вернёт код 503. В редких случаях сервер выключен и не
отвечает на запросы.

Принято считать, что ответ со статусом, отличным от \verb|2хх| означает
ошибку. Многие HTTP-клиенты бросают исключение на ответ с негативным статусом.
Это верно только на прикладном уровне, когда мы пишем код. С точки зрения
протокола ответ 404 такой же правильный, как и 200.

\index{HTTP!HEAD}

Когда действий с ресурсом много, применяют другие, более редкие
методы. Например, HEAD~--- получить краткие сведения о сущности. Сервис
Amazon~S3 в ответ на HEAD вернёт только статус и заголовки с пустым телом. В них
указаны тип файла и его размер, контрольная сумма, дата изменения. HEAD-запрос
предпочтительней GET. Обычно метаданные хранят отдельно от файла, поэтому доступ
к ним быстрее, чем к диску.

\index{веб-разработка!REST}
\index{веб-разработка!CRUD}


Подход <<метод и ресурс>> вырос в то, что сегодня называется
\footurl{REST}{https://restapitutorial.com}[REST]. Сторонники REST выделяют сущности и
CRUD-операции над ними (\textbf{C}reate, \textbf{R}ead, \textbf{U}pdate,
\textbf{D}elete). Считается верным подход, когда сущность задают через путь,
например \verb|/users/1|, а операцию~--- методом. Если это запрос на
изменение, данные читают из тела с JSON.

REST~--- не идеальный и не единственный подход к веб-разработке. Он конкурирует
с JSON-RPC, gRPC и другими аналогами. В этой книге мы не будем задерживаться на
конкретной парадигме. Протокол не заставляет следовать REST и другим
правилам. Работайте с HTTP так, как это удобно проекту. Идеальная архитектура не
обещает успех, и~наоборот: успех не значит, что в коде всё идеально.

\subsection{Фреймворк}

\index{фреймворки}

Фреймворк~--- это абстракция над HTTP. Разработчик не читает запрос по байтам
вручную~--- задачу берёт на себя чужой код. Взамен нам дают классы, чтобы
описать логику приложения. Типичный проект на~Python или Java состоит из
следующих классов.

\verb|Application|~--- это главная сущность проекта: она группирует классы рангом
ниже. \verb|Router| определяет, на какой обработчик подать входящий запрос~---
\verb|Request|. Обработчик~--- это класс \verb|Handler| с методами
\verb|.onGet|, \verb|.onPost| и другими. Они вернут экземпляр класса
\verb|Response|. Так устроены промышленные фреймворки вроде Django и
Rails. Имена и состав классов отличаются, но смысл прежний: приложение, роутер,
обработчик, запрос и ответ.

\index{фреймворки!Django}

Большие проекты делят на слои. Слой транспорта отвечает за обмен данными, слой
логики исполняет код, ничего не зная об источнике данных. С таким подходом
логика не зависит от транспорта, и последний можно сменить в любой
момент. Например, направить долгий запрос в очередь задач. На практике это
работает не всегда: по разным причинам, в том числе из-за спешки, слои
перемешиваются.

Проекты на Clojure опираются на фреймворки. Принципы, о которых мы говорили
выше, справедливы и для этого языка.

\section{HTTP в Clojure}

\index{люди!Джеймс Ривз}
\index{сайты!www.booleanknot.com}

Разработчик \footurl{Джеймс Ривз}{https://www.booleanknot.com}[James\\*Reeves] (James Reeves)
известен вкладом в экосистему Clojure. Нет проекта, который бы не использовал
его библиотеки. Джеймс ввёл стандарт веб-разработки для Clojure на заре
языка. Стандарт опирается на несколько простых идей.

Приложения бывают сколь угодно сложными: они полагаются на сторонние сервисы,
машинное обучение, учитывают сотню фактов о~клиенте. Но даже самое сложное
приложение принимает запрос и~возвращает ответ, и поэтому это функция. Скептики
заметят, что мысль не нова. В Django обработчик тоже бывает не классом,
а~функцией. Разница в том, что обработчик~--- это ещё не приложение. Ему не хватает
роутера, middleware и других абстракций. Функция-обработчик в~других языках~--- это
локальная возможность.

\label{http-all-function}

В Clojure приложение остаётся функцией на всех уровнях. Маршрут~--- это функция,
которая принимает запрос, ищет обработчик и передаёт ему управление. Middleware~---
это тоже функция, которая дополняет приложение логикой. Каждую тяжёлую
абстракцию (классы \verb|Application|, \verb|Router|, \verb|Handler|) в
Clojure заменяют функцией. Это удобно, потому что в отличие от классов функции
компонуются между собой.

Другая идея в том, чтобы зафиксировать структуру запроса и ответа. Должны быть
документы (не код, а именно документы), где описаны поля и их семантика. Это
напоминает протокол HTTP: спецификация упрощает код и делает его
переносимым. Удобно, когда разные проекты на Clojure работают с одними
структурами. Если фреймворк соблюдает стандарт, к нему легче привлечь
сообщество. Следовать ему в интересах разработчика.

\subsection{Ring}

\index{библиотеки!Ring}
\label{ring-jetty}

Идеи воплотились в проекте \footurl{Ring}{https://github.com/ring-clojure/ring}[Ring].
Сегодня это стандарт разработки на~Clojure под веб. Репозиторий содержит описание
запроса и ответа и базовый код для работы с ними. Прилагаются основные middleware,
обёртка для сервера Jetty и документация.

\index{Ring!совместимость}

\mnoindent
Со временем появился термин <<Ring-совмести\-мость>>. Ему следуют все фреймворки
на Clojure. Ring-приложение работает на платформах Jetty, Immutant и других без
изменений в коде.

Библиотека Ring разбита на отдельные части, чтобы можно было установить только
нужные. Перечислим компоненты, которые понадобятся по ходу главы:

\begin{itemize}

\item
  \verb|ring-core|~--- базовый набор: параметры, куки, сессии;

\item
  \verb|ring-jetty-adapter|~--- запуск сервера из функции;

\item
  \verb|ring/ring-json|~--- поддержка JSON.

\end{itemize}

Первое приложение мы напишем даже без библиотеки. Вот оно:

\index{Ring!приложение}

\label{first-handler}


\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn app [request]
 (let [{:keys [uri request-method]}
       request]
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (format "You requested %s %s"
           (-> request-method
               name
               .toUpperCase)
           uri)}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [uri request-method]} request]
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (format "You requested %s %s"
                   (-> request-method name .toUpperCase)
                   uri)}))
  \end{clojure}
\end{english}

\fi

Приложение читает путь и метод запроса и строит ответ. Его статус
положительный~--- 200. Мы выставили заголовок с типом <<простой текст>>. Поле
\verb|:body| содержит строку, которую получим функцией
\verb|format|. Поскольку \verb|app|~--- это функция, вызовем её с разными
запросами:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(app {:request-method :get
      :uri "/index.html"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested GET /index.html"}

(app {:request-method :post
      :uri "/users"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested POST /users"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(app {:request-method :get :uri "/index.html"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested GET /index.html"}

(app {:request-method :post :uri "/users"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested POST /users"}
  \end{clojure}
\end{english}

\fi


Кругом словари, и не ясно, что будет в браузере. Запустим приложение в виде
сервера. Он принимает приложение, параметры и~включает сложный процесс. Сервер
слушает указанный порт и читает байты. Из бинарных данных он строит словарь
запроса. В отдельном потоке сервер вызывает с ним приложение. Получим словарь
ответа. Сервер переводит словарь в байты и~пишет в удаленный порт клиента. Цикл
повторяется для каждого запроса.

\index{Ring!Jetty}
\index{библиотеки!Jetty}

Добавим в проект зависимости:

\begin{english}
  \begin{clojure}
[ring/ring-core "1.7.1"]
[ring/ring-jetty-adapter "1.7.1"]
  \end{clojure}
\end{english}

Запустим сервер:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[ring.adapter.jetty
           :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[ring.adapter.jetty :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
  \end{clojure}
\end{english}

\fi

Происходит следующее. Мы добавили в текущий модуль функцию
\verb|run-jetty|. Она принимает приложение и словарь опций. Ключ
\verb|join?| определяет, будет ли заблокирован текущий поток до конца работы
сервера. Если передать \verb|false|, сервер запустится в~фоне. Чтобы
остановить его, нужно поместить результат \verb|run-jetty| в~переменную
и~позже вызвать метод \verb|.stop|:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(def server
  (run-jetty app {:port 8080
                  :join? false}))

;; after a while
(.stop server)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def server
  (run-jetty app {:port 8080 :join? false}))

;; after a while
(.stop server)
  \end{clojure}
\end{english}

\fi

Если флаг~--- истина (как в первом случае), главный поток повиснет до тех пор, пока
сервер не выключат. Чтобы это сделать, нажмите \verb|Ctrl+C|. Пока сервер
работает, откройте браузер по адресу \verb|http://localhost:8080|. Вы увидите
строку <<You requested GET />>. Теперь измените путь на \verb|/hello| или
\verb|/path/to/file.txt|~--- сообщение изменится.

\section{Запросы и ответы}

Мы написали приложение, которое на все запросы печатает метод и путь. Кроме этих
полей, запрос содержит порт и адрес сервера, строку параметров, тип протокола,
заголовки и тело. Всё вместе~--- это неизменяемый словарь с ключами типа
\verb|keyword|. Полное описание запроса и~ответа смотрите в репозитории на
\footurl{GitHub}{https://github.com/ring-clojure/ring/blob/master/SPEC}[Ring spec][-9mm].

Здесь и далее будем писать слово \verb|keyword| по-русски:
<<кейворд>>. В~других языках тип называют токеном или тегом.

\index{HTTP!заголовки}

\mnoindent
Обратим внимание на поля запросов \verb|:headers| и \verb|:body|. Заголовки~---
это неизменяемый словарь, но его ключи~--- не кейворды, а строки. Такой словарь не
работает с разбиением по \verb|:keys|. Ниже переменная \verb|host| окажется
равна \verb|nil|:

\index{синтаксис!:keys (разбиение)}

\begin{english}
  \begin{clojure}
(defn some-handler
  [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    ...))
  \end{clojure}
\end{english}

\index{синтаксис!:strs (разбиение)}

Чтобы извлечь заголовки правильно, используйте \verb|:strs|:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host
                user-agent]} headers]
    ...))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host user-agent]} headers]
    ...))
  \end{clojure}
\end{english}

\fi

\noindent
или функцию \verb|get| со строкой:

\begin{english}
  \begin{clojure}
(get headers "host") ;; "127.0.0.1"
  \end{clojure}
\end{english}

\index{заголовки!Content-Type}

Имя заголовка всегда в нижнем регистре. В протоколе HTTP варианты
\verb|Content-Type| и \verb|content-type| одинаковы, но в Java (и поэтому в
Clojure) регистр имеет значение. Ring приводит заголовки к нижнему регистру,
чтобы избежать недоразумений.

Значения заголовков~--- тоже строки. Стандарт задаёт типы некоторых заголовков,
но Ring не выводит их. Например, \verb|Content-Length| передаёт длину тела в
байтах. Современные фреймворки приводят его к числу и помещают в отдельное
поле. По умолчанию Ring не делает ничего подобного, но это легко исправить.

Новички забывают, что ключи заголовков~--- это строки. Так появляется ошибка, когда
вместо правильного значения приходит \verb|nil|:

\begin{english}
  \begin{clojure}
(get headers :host) ;; nil
  \end{clojure}
\end{english}

Можно обработать заголовки, сменив тип ключей. Для одного случая это
нормально, но если это делает каждый обработчик, получается лишняя
работа. Приложение меняют так, чтобы в функцию приходили уже исправленные
заголовки. Техника называется middleware, и мы рассмотрим её ниже.

\index{классы!InputStream}

Поле запроса \verb|:body| опционально. Согласно HTTP, тела может не
быть. Обратите внимание на его тип: это не строка, а входящий поток~---
\verb|java.io.InputStream|. Поток~--- это источник данных, который читают только
раз. По умолчанию Ring не читает поток. Делать это или нет, остаётся на ваше
усмотрение.

\index{заголовки!Content-Length}

Чтение и разбор тела~--- это сложная операция. По заголовкам определяют тип
документа, его длину и читают нужное число байт. Из них восстанавливают данные
(JSON, XML). Технически возможно послать JSON-документ, но указать тип
\verb|text/xml|. Сервер должен быть готов к подобным сценариям.

Легче всего прочитать тело в строку функцией \verb|slurp|:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn handler [request]
 (let [content (-> request :body slurp)]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body (format "The content was %s"
                 content)}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn handler [request]
  (let [content (-> request :body slurp)]
    {:status 200
     :headers {"content-type" "text/plain"}
     :body (format "The content was %s" content)}))
  \end{clojure}
\end{english}

\fi

В современном вебе всё меньше работают с текстом: на его место приходят данные в
виде JSON. Позже мы рассмотрим, как подружить Ring с этим форматом.

\index{Ring!тело запроса}

Ответ Ring~--- это словарь с полями \verb|:status|, \verb|:headers| и
\verb|:body|:

\begin{itemize}

\item
  \verb|:status|~--- целое число, признак успеха или неудачи. Мы рассмотрели
  семантику статуса в начале главы;

\item
  \verb|:headers|~--- заголовки ответа с ключами-строками:

\index{заголовки!Location}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
{:status 302
 :headers
   {"content-length" 0
    "location" "/new/page.html"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:status 302
 :headers {"content-length" 0
           "location" "/new/page.html"}}
  \end{clojure}
\end{english}

\fi

\item
  \verb|:body|~--- тело ответа. Как и в запросе, тела может не быть. Обычно
  это строка, но может быть и файл, ресурс или поток.

\end{itemize}

\section{Маршруты}

\index{Ring!маршруты}

Мы запустили приложение и проверили в браузере. На любой запрос оно выдаёт текст
с небольшими отличиями. На практике приложение строят из обработчиков, каждый из
которых решает узкую задачу. Входящие запросы распределяют по ним согласно
правилам. Это называется маршрутизацией или роутингом.

В Clojure и Ring нет класса роутера. Его роль играет функция, которая принимает
обработчики и возвращает приложение. Оно принимает запрос и по методу и пути
подбирает нужный обработчик. Затем вызывает его с запросом и возвращает ответ.

\index{HTTP!404}

Вообразим, что по адресу \verb|/| мы бы хотели видеть название сайта, а
по~\verb|/hello|~--- приветствие. Другие адреса вернут
\spverb|404 Page not found|. Напишем обработчики:

\begin{english}
  \begin{clojure}
(defn page-index [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defn page-hello [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Hi there! Keep trying!"})

(defn page-404 [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
  \end{clojure}
\end{english}

Каждый обработчик можно запустить в виде сервера и открыть в~браузере. Осталось
связать их в единое целое.

\subsection{Наивный подход}

Сделаем самое простое, что приходит в голову. Напишем обработчик, который
находит маршрут вручную. Для этого проверим путь оператором \verb|case|:

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [uri]} request]
    (case uri
      "/"      (page-index request)
      "/hello" (page-hello request)
      (page-404 request))))
  \end{clojure}
\end{english}

Ответ функции зависит от поля запроса \verb|:uri|. Запустите приложение в
браузере и проверьте разные адреса. Это наивный подход, но он работает.

\mnoindent
Недостатки функции очевидны. Мы не учитываем метод запроса: \verb|GET /users|
и \verb|POST /users| отличаются по смыслу. Мы сравниваем пути в лоб без учёта
параметров. В правильном роутинге пути \verb|/users/1| и \verb|/users/99|
приходят в один обработчик с разным параметром \verb|id|. Код получился
шумный. Хотелось бы задать маршруты правилами, декларативно.

Эти и другие проблемы решают библиотеки. Мы рассмотрим Compojure и Bidi. Обе
строят маршруты, но их подходы ортогональны.

\subsection{Compojure}

\label{compojure}

\index{библиотеки!Compojure}

Библиотека \footurl{Compojure}{https://github.com/weavejester/compojure}[Compo-\\*jure]
предлагает макросы для описания маршрутов. Макросы похожи на таблицу правил.
Добавим зависимость в проект:

\begin{english}
  \begin{clojure}
[compojure "1.6.1"]
  \end{clojure}
\end{english}

Так выглядит приложение на Compojure. Оно чище и короче того, что мы написали
вначале.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[compojure.core
           :refer [GET defroutes]])

(defroutes app
  (GET "/" request
    (page-index request))
  (GET "/hello" request
    (page-hello request))
  page-404)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[compojure.core :refer [GET defroutes]])

(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
  \end{clojure}
\end{english}

\fi

Разберёмся, что получилось на выходе. Переменная \verb|app|~--- функция, которая
принимает запрос. Мы задали её не через \verb|def| или \verb|defn|, а~макросом
\verb|defroutes|. Он строит функцию-роутер и связывает её с~переменной
\verb|app|. С макросом получается меньше кода.

После имени следуют правила. Правило~--- это форма \tuple{метод, путь,
  переменная, выражение}. Её читают так: если метод и путь подходят текущему
запросу, связать его с переменной и выполнить выражение. Результат станет
ответом сервера.

\index{макросы!defroutes}

Compojure строит из правила функцию, которая принимает запрос. Функция
проверяет, что метод и путь запроса совпадают с заданными. Согласно первому
правилу из кода выше, для метода и пути \verb|GET /| вернуть ответ
\verb|(page-index request)|.

Макрос \verb|defroutes| оборачивает несколько правил в перебор. На каждом шаге
он берёт очередное правило и применяет к нему запрос. Первое значение, отличное
от \verb|nil|, станет ответом к текущему запросу.

Что будет, если не подошло ни одно правило? Результат \verb|nil| вызовет
ошибку сервера. Чтобы избежать \verb|nil|, к правилам добавляют ещё одно,
которое сработает всегда. Это функция \verb|page-404|: её результат не
зависит от запроса. Так мы гарантируем, что даже если запрос не подошёл по первым
двум правилам, получим ответ 404, а не ошибку типов.

Так устроен роутинг на Compojure. Приложение состоит из отдельных
обработчиков. С помощью макросов \verb|GET| и \verb|POST| их оборачивают в
правила. Правило строит функцию, которая проверяет, что метод и~путь
подходят. Если да, получим вызов обработчика с запросом.

\subsection{Продвинутые возможности}

Мы обозначили проблему: правила \texttt{GET /users\-/1} и \verb|GET /users/99|~---
это один обработчик с параметром. Его записывают так:

\index{макросы!GET}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(GET "/users/:id" [id :as request]
    (page-user request))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(GET "/users/:id" [id :as request] (page-user request))
  \end{clojure}
\end{english}

\fi

Обратите внимание на двоеточие перед \verb|id| и квадратные скобки в середине.
Часть пути с двоеточием означает параметр. На время запроса Compojure поместит
его в словарь \verb|params|.

Предположим, страница \verb|page-user| покажет имя и фамилию пользователя по
номеру из пути. Условная функция \verb|get-user-by-id| вернёт словарь
пользователя по номеру. Находим в словаре имя и фамилию и возвращаем строку.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn page-user [request]
   (let [user (-> request
                  :params
                  :id
                  get-user-by-id)
         {:keys [fname lname]} user]
     {:status 200
      :body (format "User is %s %s"
                    fname lname)}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn page-user [request]
  (let [user (-> request :params :id get-user-by-id)
        {:keys [fname lname]} user]
    {:status 200
     :body (format "User is %s %s" fname lname)}))
  \end{clojure}
\end{english}

\fi

\mnoindent
Compojure решает проблему вложенных путей. Рассмотрим приложение для учёта
товаров. По адресу \verb|/content/order/1/view| открывается карточка
товара. Страница \texttt{/content/order/\-1/edit} показывает форму редактирования
этого товара. Чтобы его обновить, нужно отправить форму по тому же пути, но
методом POST.

Очевидно, правила пересекаются. Чтобы избежать повторов, используем макрос
\texttt{con\-text}:

\index{макросы!context}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(context "/content/order/:id" [order-id]
  (GET  "/view" request
        (order-view request))
  (context "/edit" []
    (GET  "/" request
          (order-form request))
    (POST "/" request
          (order-save request))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(context "/content/order/:id" [order-id]
  (GET  "/view" request (order-view request))
  (context "/edit" []
    (GET  "/" request (order-form request))
    (POST "/" request (order-save request))))
  \end{clojure}
\end{english}

\fi

Правила в \verb|context| наследуют параметры из уровня выше. Это значит,
обработчики \verb|order-view|, \verb|order-form| и \verb|order-save|
получат параметр \verb|:order-id|.

До сих пор в качестве ответа в правилах мы писали что-то вроде
\verb|(some-handler request)|. Иногда ответ знают заранее, поэтому нет смысла
выносить его в функцию. Рассмотрим подход на примере
\verb|healthcheck|-обработчика.

Современные приложения запускают в контейнерах и облачных сервисах. Чтобы
узнать, работает приложение или нет, специальная служба опрашивает его. Простой
способ сделать это~--- послать приложению \verb|GET|-запрос по адресу
\verb|/health| и проверить статус. Тело и~заголовки ответа не играют роли.

Чтобы не создавать лишний обработчик \verb|(page-health request)|, поместим
ответ в правило:

\index{макросы!ANY}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(ANY "/health" _
     {:status 200 :body "ok"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ANY "/health" _ {:status 200 :body "ok"})
  \end{clojure}
\end{english}

\fi


Можно сделать проще: в Compojure предусмотрен случай, когда выражение~--- это
строка. Она становится телом положительного ответа:

\begin{english}
  \begin{clojure}
(ANY "/health" _ "ok")
  \end{clojure}
\end{english}

\subsection{Роутинг с Bidi}

\index{организации!JUXT}
\index{библиотеки!Bidi}

Библиотека \footurl{Bidi}{https://github.com/juxt/bidi}[Bidi] строит маршруты
по-другому. Она опирается на данные~--- списки и словари. Метод состоит из
нескольких шагов.

На первом этапе объявляют дерево маршрутов. Это комбинация векторов и словарей
по особым правилам. В листьях дерева помещают теги~--- уникальные
метки. Специальная функция принимает дерево и запрос. Она ищет ветку дерева,
которой подходят метод и путь запроса. Если ветка нашлась, результатом будут
её тег и параметры пути. Например, \verb|{:route :show-user :route-params: {:id 1}}|.

\index{middleware}

На втором этапе пишут middleware~--- промежуточный обработчик запроса. Он
принимает запрос, добавляет в него тег и передаёт дальше по цепочке.

На третьем этапе добавляют обработчик запроса. Это не функция, а мультиметод.
Его функция-диспатчер возвращает тег. Метод с тегом \verb|:default| вернёт
ответ \verb|404|, \verb|:show-user|~--- страницу пользователя и так далее.

На первый взгляд схема кажется сложной. Но однажды настроив, её легко
масштабировать. Чтобы сервер подхватил новый путь, в дерево добавляют ветку и
расширяют мультиметод.

\index{библиотеки!Bidi}

Перепишем на Bidi пример из начала главы. Добавьте зависимость:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
;; project.clj
[bidi "2.1.5"]

;; namespace
(:require [bidi.bidi :as bidi])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
[bidi "2.1.5"]                  ;; project.clj
(:require [bidi.bidi :as bidi]) ;; namespace
  \end{clojure}
\end{english}

\fi

Начнём с дерева маршрутов. Вариант с \verb|page-index|, \verb|page-hello|
и~\verb|page-404| выглядит так:

\begin{english}
  \begin{clojure}
(def routes
  ["/" {""      :page-index
        "hello" :page-hello
        true    :not-found}])
  \end{clojure}
\end{english}

\index{функции!match-route}

Проверим поиск пути по этому дереву. Функция \verb|match-route| принимает
маршруты, путь и возвращает словарь с тегом:

\begin{english}
  \begin{clojure}
(bidi/match-route routes "/hello")
{:handler :page-hello}

(bidi/match-route routes "/test")
{:handler :not-found}
  \end{clojure}
\end{english}

\index{функции!match-route}

Объединим тег с запросом. Сделаем это за один шаг функцией
\verb|match-route*|. Это альтернативная версия \verb|match-route|, которая
принимает словарь-накопитель. Его роль играет запрос.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route*
    routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route* routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
  \end{clojure}
\end{english}

\fi

Видим, что \verb|match-route*| вернула исходный запрос, но добавила в него
поле \verb|:handler|. Обернём код в middleware. Получив запрос, новый
обработчик добавит к нему поле \verb|handler| и вызовет исходный обработчик.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn wrap-handler [handler]
  (fn [req]
    (let [{:keys [uri]} req
           req* (bidi/match-route*
                  routes uri req)]
      (handler req*))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn wrap-handler [handler]
  (fn [request]
    (let [{:keys [uri]} request
          request* (bidi/match-route* routes uri request)]
      (handler request*))))
  \end{clojure}
\end{english}

\fi

Мы ещё не касались техники middleware, но вынуждены применить её сейчас. Ниже мы
рассмотрим в деталях, как она работает и почему так важна.

Проверим \verb|wrap-handler| на скорую руку. Для удобства обернём функцию
\verb|identity|, которая вернёт переданный в неё аргумент:

\begin{english}
  \begin{clojure}
(def wrapped (wrap-handler identity))

(wrapped {:request-method :get
          :uri "/hello?foo=42"})

{:request-method :get
 :uri "/hello?foo=42"
 :handler :page-hello}
  \end{clojure}
\end{english}

\index{мультиметоды!multi-handler}

Обработчик запроса~--- это мультиметод. Функция-диспатчер~--- просто ключ
\verb|:handler|.

\begin{english}
  \begin{clojure}
(defmulti multi-handler
  :handler)

(defmethod multi-handler :page-index
  [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defmethod multi-handler :not-found
  [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
  \end{clojure}
\end{english}

Обернём \verb|multi-handler| в middleware и получим финальное
приложение. Запустите веб-сервер и проверьте результат в браузере.

\begin{english}
  \begin{clojure}
(def app (wrap-handler multi-handler))
  \end{clojure}
\end{english}

Это был простой роутинг на Bidi. Теперь рассмотрим товары, их
просмотр и изменение. Новое дерево выглядит так:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(def routes
  [["/content/order/" :id]
   {"/view" {:get  :page-view}
    "/edit" {:get  :page-form
             :post :page-save}}])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def routes
  [["/content/order/" :id] {"/view" {:get  :page-view}
                            "/edit" {:get  :page-form
                                     :post :page-save}}])
  \end{clojure}
\end{english}

\fi

\mnoindent
В этой версии листья~--- уже не теги, а словари. Ключ каждого словаря~--- это метод, а
значение~--- тег. Запрос \verb|GET /content/order/1/edit| разрешается в тег
\verb|:page-form|, а POST с таким же адресом~--- в \verb|:page-save|.  На
этапе \verb|wrap-handler| запрос получит поле \texttt{:route-par\-ams}. В нашем
случае это словарь \verb|{:id "1"}|.

\index{языки!HTML}

\mnoindent
Расширим мультиметод страницами. \verb|Page-view| находит товар по номеру и
верстает его HTML-страницу. Если товара нет, вернём ответ 404 <<не
найдено>>.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (some->
                   request
                   :route-params
                   :id
                   get-order-by-id)]
    {:status 200
     :headers {"content-type"
               "text/html"}
     :body (render-order-page
             {:order order})}
    page-404))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (some-> request
                         :route-params
                         :id
                         get-order-by-id)]
    {:status 200
     :headers {"content-type" "text/html"}
     :body (render-order-page {:order order})}
    page-404))
  \end{clojure}
\end{english}

\fi

Страница \verb|:page-form| строит форму редактирования. От просмотра она
отличается шаблоном HTML. Обновление товара сложнее: нужно выбрать поля запроса
и записать их в базу. Для краткости опустим валидацию:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-save
  [req]
  (let [{:keys [params route-params]} req
        {order-id :id} route-params
        params (select-keys params
                 [:title :description
                  :price])
        location (str "/content/order/"
                   order-id "/view")]
    (jdbc/update! *db* :orders
      params ["id = ?" order-id])
    {:status 302
     :headers {"Location" location}}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-save
  [request]
  (let [{:keys [params route-params]} request
        {order-id :id} route-params
        fields [:title :description :price]
        params (select-keys params fields)
        location (format "/content/order/%s/view" order-id)]
    (jdbc/update! *db* :orders params ["id = ?" order-id])
    {:status 302
     :headers {"Location" location}}))
  \end{clojure}
\end{english}

\fi


\index{HTTP!перенаправление}

Обратите внимание: на изменение данных мы отвечаем не страницей, а
\emph{редиректом} на неё. Если страница пришла в ответ на~POST-запрос, то
при её обновлении браузер снова отправит форму. Это чревато странным
поведением на сервере. Вариант с редиректом решает проблему: браузер загрузит
страницу через GET, и побочных эффектов при обновлении не будет.

\subsection{Выбор между Compojure и Bidi}

Новичку в Clojure легче начать с Compojure. У библиотеки достойная документация
с примерами. Compojure и Ring написал один автор, поэтому проекты близки и
дополняют друг друга.

Маршруты Bidi сложны для понимания: они многословны и не интуитивны. В них легко
перепутать вектор и словарь. С другой стороны, мультиметоды несут свои
преимущества. Код становится линейным, и приложение легче расширять.

Если проект небольшой, выбирайте Compojure. Когда проект сложный и маршрутов всё
больше, рассмотрите переезд на Bidi.

\section{Middleware}

\index{middleware}

Выше мы упоминали про middleware и даже кинули пробный шар~--- написали
\verb|wrap-route|. Теперь изучим их внимательней. Это самый важный раздел в
главе.

В переводе с английского middleware означает <<промежуточный слой, середина>>. В
программировании так называют код в роли посредника. Он выполняет
предварительные шаги перед основным: приводит типы, проверяет права доступа.

\label{decorator}

\index{декораторы}

Паттерн <<декоратор>>~--- частный случай middleware. Декоратор~--- это функция
\verb|А|, которая принимает функцию \verb|B| и возвращает
функцию~\verb|C|. Говорят, что \verb|A| декорирует \verb|B|. В ходе работы
\verb|C| вызывает \verb|B|, но с~изменениями. Например, дополняет входные
или выходные данные~\verb|B|.

Рассмотрим простые декораторы. \verb|With-echo| добавляет к функции побочный
эффект: печатает аргументы и результат.

\begin{english}
  \begin{clojure}
(defn with-echo [func]
  (fn [& args]
    (apply println "The args are" args)
    (let [result (apply func args)]
      (println "The result is" result)
      result)))
  \end{clojure}
\end{english}

Вот как им пользоваться:

\begin{english}
  \begin{clojure}
(def +echo (with-echo +))
(+echo 1 2 3)
;; The args are 1 2 3
;; The result is 6
6
  \end{clojure}
\end{english}

\index{исключения!try}
\index{исключения!catch}
\index{макросы!with-catch}

\mnoindent
\verb|With-catch| оборачивает функцию в \verb|try/catch|. Если произошло
исключение, результатом будет его объект.

\begin{english}
  \begin{clojure}
(defn with-catch [func]
  (fn [& args]
    (try
      (apply func args)
      (catch Throwable e
        e))))
  \end{clojure}
\end{english}

\index{языки!Python}
\index{фреймворки!Django}

Мы уже видели запрос в Ring. У него нет полей, с которыми читатель работал в
других языках. Например, класс \verb|HttpRequest| в~Django содержит свойство
\verb|.params|. Это словарь параметров из адресной строки или тела запроса.

В Ring запрос несёт только базовую информацию. Почему в нём нет столь
важных вещей? Потому что не каждое приложение в~них нуждается. Представим, что
на каждый запрос Ring парсит адресную строку и тело. Это удобно разработчику, но
замедляет код. Не факт, что параметры нужны в запросе, но сервер потратит на них
время.

То же самое с разбором тела: это дорогая операция. Представим, что пришёл
большой JSON-документ. Мы считали его, но у пользователя нет прав на
запись. Нужно было проверить права до чтения!

Middleware играет большую роль в Ring. Параметры запроса, сессии, куки, права
доступа~--- всё это функция, которая возвращает функцию. Не придётся писать
все middleware с нуля: Ring содержит наиболее важные, нужно только подключить
их. Рассмотрим основные middleware и принципы их работы.

\subsection{Параметры запроса}

\label{ring-params}

\index{HTTP!параметры}

HTTP предусматривает данные в адресной строке. Это пары вида
\verb|"name=John&city=NY"| после знака вопроса. В коде они становятся
словарём \verb|{:name "John" :city "NY"}|.

В POST-запросах параметры помещают в тело. Так поступают из-за ограничения на
длину адреса и безопасности. Длина адреса не превышает 2048 байт, а на тело
запроса ограничений нет. Логины и~пароли нельзя пересылать в адресе, потому что
они остаются в логах и~истории браузера.

\index{модули!ring.middleware.params}
\index{HTTP!параметры}

\mnoindent
Функция \verb|wrap-params| из модуля \texttt{ring.middle\-ware.params} меняет
обработчик следующим образом. Переданный в него запрос обретает поля:

\begin{itemize}

\item
  \verb|:query-params|~--- словарь параметров из адреса;

\item
  \verb|:form-params|~--- словарь данных из тела запроса;

\item
  \verb|:params|~--- их комбинированная версия.

\end{itemize}

Пусть \verb|app|~--- ваше веб-приложение. Чтобы получить обёрнутую версию,
передайте его в \verb|wrap-params|. Результат будет финальным приложением. На
жаргоне разработчиков это называется <<врапнуть>> (англ.~wrap~--- <<обернуть>>).

\index{middleware!wrap-params}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[ring.middleware.params
           :refer [wrap-params]])
(def final-app (wrap-params app))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[ring.middleware.params :refer [wrap-params]])
(def final-app (wrap-params app))
  \end{clojure}
\end{english}

\fi

Чтобы не запутаться в именах, придерживайтесь правил. Исходное приложение
называйте \verb|app-naked| или \verb|app-raw| (голое, сырое), а~финальное~---
просто \verb|app|.

\begin{english}
  \begin{clojure}
(def app (wrap-params app-naked))
  \end{clojure}
\end{english}

Доработайте приложение так, чтобы оно учитывало параметры. Например, чтобы
параметр \verb|who| задавал имя, кого приветствовать:
\verb|/hello?who=John|. Добраться до него можно так:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn page-hello [req]
  (let [who (get-in req [:params "who"])]
    ...))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn page-hello [request]
  (let [who (get-in request [:params "who"])]
    ...))
  \end{clojure}
\end{english}

\fi

\index{классы!Keyword}

Обратите внимание, ключи \verb|:params|~--- строки. Адрес~--- это строка, и
алгоритм режет её на части. Clojure поощряет нас, когда ключи словаря~---
кейворды. Исправим это. В поставке Ring идёт middleware, которое приводит
\verb|:params| к удобному виду. С ним ключи примут тип \verb|Keyword|.

\index{middleware!wrap-keyword-params}

\begin{english}
  \begin{clojure}
(require '[ring.middleware.keyword-params
           :refer [wrap-keyword-params]])

(def app (wrap-keyword-params
           (wrap-params app-naked)))
  \end{clojure}
\end{english}

\index{макросы!\arr}

Поскольку кейворд~--- это функция, до параметра можно добраться стрелочным
оператором. Некоторым этот способ нравится больше, чем \verb|get-in|.

\begin{english}
  \begin{clojure}
(-> request :params :who)
(get-in request [:params :who])
  \end{clojure}
\end{english}

\subsection{Стек middleware}

Типичное приложение включает около десяти middleware. Если обернуть их все,
получится лесенка:

\begin{english}
  \begin{clojure}
(def app
  (wrap-something-else
    (wrap-current-user
      (wrap-session
        (wrap-keyword-params
          (wrap-params app-naked))))))
  \end{clojure}
\end{english}

\index{вложенность}

Если добавить звено посередине, оно каскадом сдвинет элементы ниже. Чтобы
победить вложенность, сделаем структуру линейной. Поможет стрелочный оператор:

\index{clojure.core!\arr (стрелочный оператор)}

\begin{english}
  \begin{clojure/lines}
(def app
  (-> app-naked
      wrap-params
      wrap-keyword-params
      wrap-session
      wrap-current-user
      wrap-something-else))
  \end{clojure/lines}
\end{english}

\index{middleware!стек}

При компиляции запись превратится в первый вариант, поэтому логика программы не
меняется. Получился список, который легко поддерживать. Назовём его
\emph{стеком} middleware.

Запись в стрелочном виде имеет особенность. Не заглядывая дальше, догадайтесь, в
каком порядке выполняются middleware. Правильный ответ: снизу вверх для запроса
и сверху вниз для ответа. Это станет ясно при мысленном разборе.

\index{middleware!порядок}

\mnoindent
Сперва запрос попадёт в \verb|wrap-something-else|. Код внутри него
вызовет обработчик, который получен из \verb|wrap-current-user|. Обработчик
внутри него~--- результат \verb|wrap-session| и так далее. Вершиной подъёма
станет \verb|app-naked|. В нём сработает основная логика приложения.

Теперь ответ спускается в обратном порядке. Сначала он пройдёт через
\verb|wrap-params| и \verb|wrap-keyword-params|. Эти два middleware не
меняют ответ и просто вернут его. \verb|Wrap-session| и
\verb|wrap-current-user|, возможно, допишут новые заголовки.
\verb|Wrap-something-else| сработает последним. Цикл пройден.

\index{языки!Python}

Представьте стек как восхождение в гору и спуск с неё. Похоже устроены
middleware в Django~--- промышленном фреймворке на Python. Их роль играют классы, а
не функции, но порядок обхода такой же.

Порядок middleware порой критичен. Некоторые из них опираются на данные из
предыдущих middleware. Рассмотрим уже знакомые \verb|wrap-params| и
\verb|wrap-keyword-params|. Последний ищет в запросе поле \verb|params| и
меняет тип ключей. Это разделение труда: одно middleware готовит данные, второе
улучшает их. Поэтому \verb|wrap-keyword-params| ставят строго после
\verb|wrap-params|.

\index{middleware!порядок}

\mnoindent
Теперь посмотрим на форму \spverb|(def app ...)| выше. В неё закралась
\textbf{ошибка}. Запрос движется снизу вверх, поэтому \verb|wrap-keyword-params|
сработает раньше \coderef{4}. Он попытается найти \verb|:params| в запросе, но
безуспешно. Далее сработает \verb|wrap-params| \coderef{3}. Он заполнит поле
словарём из~адресной строки. В~результате у \verb|:params| ключи будут
строками. Поменяйте \verb|wrap-params| и \verb|wrap-keyword-params| местами.

Неверный порядок middleware стоит часов отладки. Но есть трюк: если два и более
middleware зависят друг от друга, их можно <<схлопнуть>> в одно целое. Функция
\verb|comp| принимает функции и возвращает суперфункцию, которая применяет их
к аргументу. Напишем умный враппер параметров:

\index{clojure.core!comp}
\index{функции!композиция}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(def wrap-params+
  (comp wrap-params wrap-keyword-params))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def wrap-params+ (comp wrap-params wrap-keyword-params))
  \end{clojure}
\end{english}

\fi

Разберёмся, почему аргументы \verb|comp| идут в таком порядке. Обозначим
их \verb|foo| и \verb|bar| и перепишем выражение несколько раз. В каждом
столбике одинаковая функция, записанная по-разному.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(comp foo bar)
  \end{clojure}

\splitter

  \begin{clojure}
(fn [x]
  (foo (bar x)))
  \end{clojure}

\splitter

  \begin{clojure}
(fn [x] (-> x
            bar
            foo))
  \end{clojure}
\end{english}

\else

\begin{english}
\noindent
\begin{tabular}{ @{}p{3.2cm} @{}p{3.5cm} @{}p{3.5cm} }

  \begin{clojure}
(comp foo bar)
  \end{clojure}

&

  \begin{clojure}
(fn [x]
  (foo (bar x)))
  \end{clojure}

&

  \begin{clojure}
(fn [x] (-> x
            bar
            foo))
  \end{clojure}

\end{tabular}

\end{english}

\fi

Если \verb|x| в третьем столбике~--- это приложение, а~ \verb|foo| и
\verb|bar|~--- middleware, то всё станет ясно. Во время запроса они работают в
обратном порядке, поэтому \verb|foo| запустится раньше \verb|bar|. Значит,
на месте \verb|foo| должно быть \verb|wrap-params|, а вместо
\verb|bar|~--- \verb|wrap-keyword-params|. Если подставить их в~первый
столбик, получим то, что записали вначале.

Плюс на конце означает, что это улучшенная версия \verb|wrap-params|. Заменим
в стеке \verb|wrap-params| и \verb|wrap-keyword-params| на~версию с~
плюсом. Цепочка станет короче, а логика параметров поселилась в~отдельном месте.

Перечислим другие полезные middleware: куки, сессии и JSON.

\subsection{Cookie}

\index{HTTP!куки}

В HTTP куки~--- это маленькие кусочки информации. Между сервером и~браузером
соглашение о том, как хранить и передавать их. Если сервер выставил куки,
браузер запомнит их для этого сайта. В~следующий раз браузер отправит их на
сервер автоматически. Так продолжается до тех пор, пока не истечёт их срок
жизни или кто-то не удалит их. Удалить куки может как сервер с помощью
заголовка, так и пользователь в~настройках браузера.

Простейший случай, когда нужны куки,~--- определить, был ли уже пользователь на
сайте. В первый раз приложение ищет в запросе куки с именем
\verb|visited|. Если их нет, сервер добавит заголовок:

\begin{english}
  \begin{http}
Set-Cookie: visited=true;
  \end{http}
\end{english}

Получив куки, браузер добавит их ко всем запросам к серверу. Исходящий заголовок
выглядит так же, но без частички \verb|Set-| в имени. Приложение проверяет: если
значение истинно, клиент уже был на сайте. Это влияет на показ рекламы,
всплывающие окна и так далее.

Технически куки~--- это длинный заголовок, где поля и значения разделены точками с
запятой. Middleware \verb|wrap-cookie| упрощает работу с~этим заголовком. В
запросе мы получим словарь \verb|:cookies|, в котором два уровня с именами и
атрибутами. Чтобы выслать клиенту новые куки, добавьте изменённую копию словаря
в ответ. Ring построит из него заголовок \verb|Set-Cookie|.

Ниже страница \verb|page-seen| проверяет, видим ли мы её в первый раз.

\index{модули!ring.middleware.cookies}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure/lines}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path ["seen" :value]
        seen? (get-in cookies
                      seen-path)
        cookies* (assoc-in cookies
                   seen-path true)]
    {:status 200
     :cookies cookies*
     :body
     (if seen?
      "Already seen."
      "The first time you see it!")}))

(def app (-> page-seen
             wrap-cookies))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path ["seen" :value]
        seen? (get-in cookies seen-path)
        cookies* (assoc-in cookies seen-path true)]
    {:status 200
     :cookies cookies*
     :body (if seen?
             "Already seen."
             "The first time you see it!")}))

(def app (-> page-seen
             wrap-cookies))
  \end{clojure/lines}
\end{english}

\fi

Замечание: переменная со звёздочкой на конце означает новую версию исходной
переменной \ifx\DEVICETYPE\MOBILE\coderef{9}\else\coderef{8}\fi. Например, такой же словарь, но с новым ключом. Вместо
звёздочки иногда ставят штрих. Переменная \verb|cookies*| означает <<новые
куки на базе старых>>.

\index{middleware!wrap-keyword-cookie}

По аналогии с \verb|:params| ключи куки~--- это строки. Если поменять
\verb|"seen"| на \verb|:seen| \coderef{6}, вы промахнётесь и получите
\verb|nil|. В Ring нет аналога \verb|wrap-keyword-cookie|; такую обёртку
легко написать самому. Ниже мы покажем способ для заголовков.

Запустите приложение в браузере. После обновления страницы надпись изменится на
Already seen. Она останется даже после перезагрузки сервера, потому что флаг
хранит браузер. Только очистив куки, вы увидите: The first time you see
it. Для полноты эксперимента откройте приватную вкладку или другой браузер.

\index{безопасность!HTTP}
\index{HTTP!безопасность}

Куки тесно связаны с безопасностью. Убедитесь, что они защищены от кражи и не
раскрывают секретные данные (пароли, ключи доступа).

Атрибуты \verb|:http-only| и \verb|:secure| существенно снижают риск
кражи. Первый означает, что к куки нельзя обратиться из JavaScript. Этим вы
защититесь от вредоносных скриптов, которые читают куки и отправляют на чужой
сервер. Откройте консоль разработчика в браузере и~выполните выражение:

\begin{english}
  \begin{js}
> document.cookie
// ring-session=...; seen=true
  \end{js}
\end{english}

\noindent
Измените переменную \verb|cookies*| так, чтобы у~\verb|seen| был атрибут:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(let [cookies*
      (assoc cookies "seen"
        {:value true
         :http-only true})]
  ...)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [cookies* (assoc cookies "seen"
                      {:value true :http-only true})]
  ...)
  \end{clojure}
\end{english}

\fi

Теперь JavaScript не увидит значение \verb|seen|:

\begin{english}
  \begin{js}
> document.cookie
// ring-session=...
  \end{js}
\end{english}

Атрибут \verb|:secure| означает, что куки передаются только в безопасном
соединении по SSL. На время разработки им можно пренебречь, но в боевом запуске
он всегда истина. Приложения без SSL небезопасны, и браузеры указывают на это
пользователям.

Мы не будем задерживаться на веб-без\-оп-ас\-нос\-ти: тема слишком обширна и
заслуживает отдельной книги.

\subsection{Сессии}

\index{HTTP!сессии}

HTTP не предполагает связи между двумя запросами. Серверу неважно, откуда они
приходят~--- с соседних машин или разных континентов. Нельзя отталкиваться от
промежутка времени: кто-то читает страницу час, а другие обновляют каждую
минуту.

Разработчики пошли на уловку. Даже если клиенты сидят за одним столом,
приложение выдаст им куки с длинной случайной строкой. Браузер добавляет куки к
запросам, и сервер отличает клиентов. Технику назвали \emph{сессией}, или
\emph{сеансом}.

Под сессией понимают значения, связанные с текущим пользователем. Например,
выбранный язык, состояние виджетов, просмотренные товары. Важно, что
пользователь не обязательно авторизован. Это может быть аноним, но сервер
отличит его запросы от~остальных.

\index{middleware!wrap-session}

\verb|Wrap-session|~--- это сложное middleware, которое дополняет запрос словарём
\verb|:session|. Его ключи~--- поля сессии. Чтобы обновить сессию, её новую
версию пишут в ответ по аналогии с куки. Middleware различает \verb|nil| и
отсутствие сессии в ответе. Если поле \verb|nil|, вся сессия удаляется. Если
ключа нет, ничего не происходит.

\index{базы данных!Redis}
\index{базы данных!Memcached}

Различают \emph{бэкенды} сессии, способы хранить её физически. Это может
быть память, диск, база данных, системы Memcached и Redis или даже куки. При
выборе бэкенда учитывайте, может ли он работать на~нескольких машинах
одновременно. Что получится, если каждый запрос случайно уходит на одну из
десяти машин? Когда сессию хранят памяти, на каждой машине будет её разная
копия. Это чревато странным поведением и отладкой. Аналогично с файлами~---
машины не делят их между собой. База данных и Redis~--- это централизованные
хранилища. Они гарантируют целостность сессии для всех клиентов.

Интересно, что сессия в куки тоже работает на многих машинах. На каждый запрос
браузер передаёт полную сессию в заголовках. В~этом случае её хранит
браузер. Если пользователь очистит куки или запустит другой браузер, сессия
будет утеряна.

Из коробки Ring предлагает два бекенда сессии: память и куки. Тип хранилища
задают настройками \verb|wrap-session|. Если ничего не указывать, Ring
использует память. Чтобы подружить сессию с Redis или другой системой, расширьте
протокол \verb|SessionStore|.

Рассмотрим пример со счётчиком посещений. Будем считать, сколько раз
пользователь зашёл на сайт. Сессию храним в~памяти.

\index{модули!ring.middleware.session}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[ring.middleware.session
           :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session
                   :counter (fnil inc 0))
        counter (:counter session*)]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)"
                   counter)}))

(def app (-> page-counter
             wrap-session))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[ring.middleware.session :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session :counter (fnil inc 0))]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)" (:counter session*))}))

(def app (-> page-counter
             wrap-session))
  \end{clojure}
\end{english}

\fi

Запустите приложение и откройте браузер. Обновите страницу, и~счётчик в
сообщении увеличится с каждым просмотром. Проделайте то же самое в другом
браузере. Это будет вторая сессия, которая не зависит от первой. Убедитесь, что
просмотр в первом браузере не влияет на второй. Данные лежат в памяти, поэтому
они потеряются при новом запуске сервера.

\emph{Упражнение 1.} Выше мы считаем просмотры для всего сайта. Сделайте так,
чтобы счётчик работал в разрезе страниц. Например, главную страницу \verb|/|
смотрели пять раз, а справку \verb|/help|~--- три раза. Параметры запроса не
влияют на подсчёт.

\emph{Упражнение 2.} Поскольку сессия хранится в памяти, она потеряется при
перезапуске сервера. Изучите документацию Ring и сделайте так, чтобы сессия
хранилась в куках. Убедитесь, что перезапуск не влечёт потерю данных.

\subsection{JSON}

\index{форматы!JSON}

Формат JSON служит для передачи данных. Он различает базовые типы: числа,
строки, логический тип и коллекции любой вложенности. Это значимый плюс по
сравнению с INI или XML, где все значения~--- строки. JSON совместим с JavaScript:
если передать строку в функцию \verb|eval|, она вернёт комбинацию списков
и словарей. Эти и~другие причины сделали формат популярным. Сегодня JSON~--- это
главный способ передать данные в вебе.

Ring предлагает несколько middleware для JSON. Для удобства их~поместили
в~отдельную библиотеку. Добавьте зависимость:

\begin{english}
  \begin{clojure}
[ring/ring-json "0.4.0"]
  \end{clojure}
\end{english}

\index{middleware!wrap-json-response}
\index{HTTP!JSON}

Middleware \verb|wrap-json-response| упрощает возврат JSON-данных. Оно проверяет
поле ответа \verb|:body|: если это коллекция, её меняют на кодированную строку и
добавляют заголовок \verb|Content-Type| с типом \verb|application/json|.

Рассмотрим API для чтения пользователя. Если нашли его по номеру, вернём
словарь полей. Если нет, в ответе структура ошибки.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn page-data [request]
  (let [user-id (-> request :params :id)
        user (get-user-by-id user-id)]
    (if user
      {:status 200 :body user}
      {:status 404
       :body
       {:error_code "MISSING_USER"
        :error_msg "No such user"}})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn page-data [request]
  (let [user-id (-> request :params :id)]
    (if-let [user (get-user-by-id user-id)]
      {:status 200 :body user}
      {:status 404
       :body {:error_code "MISSING_USER"
              :error_message "No such user"}})))
  \end{clojure}
\end{english}

\fi

\noindent
В обоих случаях не нужно кодировать данные вручную~--- это делает
\verb|wrap-json-response|.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json
           :refer [wrap-json-response]])

(def app (-> page-data
             wrap-params+
             wrap-json-response))
  \end{clojure}
\end{english}

Запустите \verb|app| и переключитесь в браузер. Откройте вкладку Network в
панели разработчика. Изучите запрос к серверу, в особенности заголовки ответа и
его тело. Если это был JSON, браузер распарсит данные и покажет в виде дерева.

Для входящего JSON служат два middleware: \verb|wrap-json-body|
и~\verb|wrap-json-params|. Оба проверяют, что заголовок \verb|Content-Type|
равен \verb|application/json|. Если заголовок верный, они парсят тело с учётом
возможных исключений. При ошибке разбора получим статус 400~и текст <<JSON body
malformed>>.

Разница между middleware в том, куда они складывают
данные. \verb|Wrap-json-body| заменяет поле \verb|:body| запроса на
структуру данных. Ниже обработчик \verb|page-body| извлекает имя и город из
\verb|:body|. Тело запроса~--- уже не входящий поток, а словарь. Обратите
внимание: middleware принимает дополнительные параметры. Флаг \verb|:keywords? true|
означает, что ключи словаря станут кейвордами.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json
           :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app
  (->
    page-body
    (wrap-json-body {:keywords? true})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-body
             (wrap-json-body {:keywords? true})))
  \end{clojure}
\end{english}

\fi

\index{утилиты!cURL}
\index{HTTP!POST}

Чтобы отправить JSON серверу, понадобится специальная программа. Это может быть
утилита \verb|cURL| или графическое приложение
\footurl{Postman}{https://www.postman.com}[Post\-man][-8mm]. Пример с \verb|cURL|:

\begin{english}
  \begin{bash}
curl --request POST
     --header "Content-Type:
                 application/json"
     --data '{"username":"John",
                      "city":"NY"}'
     http://localhost:8080/
  \end{bash}
\end{english}

\mnoindent
\verb|Wrap-json-params| работает с небольшим отличием~--- оно пишет данные в
поле \verb|:json-params|. Если в данных словарь, он дополняет
\verb|:params|. Объясним, зачем это нужно.

Поле \verb|:params|~--- это общий аккумулятор параметров. Его наполняют и другие
врапперы, например \verb|wrap-params|. Некоторые API не зависят от метода и
принимают запросы одновременно через GET или POST. Соответственно, данные
находятся в адресной строке или теле запроса. Независимо от подхода получим
одинаковый словарь \verb|:params|.

У гибридного способа преимущество: запросы на чтение выполняют через GET, чтобы
применить кэширование на уровне HTTP. Запросы на изменение выполняют через POST,
который никогда не кэшируется.

В других API важно, чтобы параметры не смешивались и не заменяли друг
друга. Предположим, наш сервис работает строго по методу POST. Чтобы прочесть
только те данные, что пришли в JSON, обратимся к полю \verb|:json-params| или
\verb|:body|. Каким враппером пользоваться~--- \verb|wrap-json-body| или
\verb|wrap-json-params|, зависит от конкретного случая.

\index{middleware!wrap-json-params}

Заметим, что \verb|:params|~--- это словарь с ключами-строками. Чтобы слияние
прошло правильно, \verb|wrap-json-params| тоже оставляет ключи
строками. Исправьте ключи с помощью \verb|wrap-keyword-params| уже после
слияния.

Middleware не случайно выделяет поле \verb|:json-params|. Дело в том, что данные
в~JSON не всегда словарь: это может быть массив, который нельзя объединить с
\verb|:params|. На этот случай данные хранят в~отдельном поле.

\subsection{Свои middleware}

\index{middleware!пользовательские}

До сих пор мы использовали наработки из Ring и смежных библиотек. Рано или
поздно вам потребуются свои middleware. Рассмотрим примеры из реальных проектов.

\subsubsection*{Ключи заголовков}

\index{HTTP!заголовки}

Враппер обновляет заголовки запроса~--- меняет тип ключей со строк на
кейворды. Для этого служит функция \verb|keywordize-keys| из пакета
\verb|clojure.walk|. Заголовкам меняют тип, когда приложение часто к ним
обращается.

\index{модули!clojure.walk}
\index{функции!keywordize-keys}

В ответе ключи заголовков тоже должны быть строками. Если указать кейворд, Jetty
бросит исключение~--- его код ожидает строки. Добавим обратное действие: изменим
ключи с кейвордов на строки. Задачу решает функция \verb|stringify-keys|.

\index{функции!stringify-keys}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require
 '[clojure.walk :refer [keywordize-keys
                        stringify-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler
        (update :headers
                stringify-keys))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.walk :refer
           [keywordize-keys stringify-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler
        (update :headers stringify-keys))))
  \end{clojure}
\end{english}

\fi

Ниже по стеку приложение работает с заголовками как с кейвордами. В примере мы
находим заголовок \verb|host| с помощью \verb|:keys|, что не сработало бы
для строк. В заголовках ответа тоже кейворд. Убедитесь, что браузер покажет
сообщение жирным шрифтом, потому что тип содержимого HTML.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn app* [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    {:status 200
     :headers {:content-type "text/html"}
     :body (str "<h1>Host header:" host
                "</h1>")}))

(def app (wrap-headers-kw app*))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn app* [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    {:status 200
     :headers {:content-type "text/html"}
     :body (format "<h1>Host header: %s</h1>" host)}))

(def app (wrap-headers-kw app*))
  \end{clojure}
\end{english}

\fi

По аналогии можно сменить тип ключей для словаря \verb|:cookie|.

\subsubsection*{Идентификатор запроса}

\index{классы!UUID}
\index{идентификатор!HTTP}
\index{идентификатор!UUID}
\index{HTTP!идентификатор}
\index{заголовки!X-Request-Id}

По умолчанию запрос и ответ не связаны друг с другом. Порой трудно понять, к
какому запросу относится данный ответ и наоборот. Мы увидели в логах ответ с
кодом 500, но какой именно запрос вызвал ошибку? Важно, чтобы система могла их
сопоставить.

Для этого ввели заголовок \verb|X-Request-Id|. Чаще всего это случайный
идентификатор (UUID), строка из 36 символов. Для краткости его называют <<айди>>
(англ.~id). Если клиент не передал id в запросе, ему назначат случайный. Тот же
id вернётся в ответе. Его пишут в лог, чтобы построить цепочку событий.

\index{middleware!wrap-request-id}

Напишем обёртку для id. Заголовки~--- это кейворды, потому что выше по стеку
\verb|wrap-headers-kw|.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or
                (get-in request
                        [:headers
                         :x-request-id])
                (str
                  (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers
                     :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc :request-id uuid)
          (assoc-in [:headers
                     :x-request-id]
                    uuid)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or (get-in request [:headers :x-request-id])
                   (str (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc :request-id uuid)
          (assoc-in [:headers :x-request-id] uuid)))))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!get-in}
\index{clojure.core!assoc}
\index{clojure.core!dissoc}

Id хранят в заголовках, но дублируют в запросе и ответе в поле
\verb|:request-id|. К нему часто обращаются в логах, поэтому удобно вынести
его в переменную в начале функции:

\index{логирование!HTTP}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn some-handler [req]
  (let [{:keys [params request-id]} req]
    (log/info "Request id: %s"
              request-id)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn some-handler [request]
  (let [{:keys [params request-id]} request]
    (log/info "Request id: %s" request-id)))
  \end{clojure}
\end{english}

\fi

\subsubsection*{Текущий пользователь}

\index{HTTP!пользователь}
\index{пользователь}

Этот враппер добавляет в запрос текущего пользователя. В данном случае мы ищем
его номер в сессии. Если номер найден, читаем пользователя из базы и добавляем к
запросу. Функция \verb|get-user-by-id| вернёт словарь или
\verb|nil|. Её оборачивают в \verb|(when user-id...)|, чтобы не
обращаться в базу с пустым номером.

\index{middleware!wrap-current-user}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request
                      :session
                      :user-id)
          user (when user-id
                 (get-user-by-id
                   user-id))]
      (-> request
          (assoc :user user)
          handler))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request :session :user-id)
          user (when user-id
                 (get-user-by-id user-id))]
      (-> request
          (assoc :user user)
          handler))))
  \end{clojure}
\end{english}

\fi

\index{безопасность!сессия}
\index{HTTP!безопасность}

Middleware по стеку ниже читают пользователя из поля \verb|:user| запроса
(пример в следующем разделе).

К вопросу о безопасности: номер пользователя \emph{можно} хранить в~сессии. Она
подписана секретным ключом, поэтому только сервер знает, как её
изменить. Номер пользователя не раскрывает приватные данные. Не храните в сессии
пароли и ключи доступа.

\subsection{Прерывание стека}

\index{middleware!прерывание}

До сих пор мы работали с цепочкой middleware, где каждое звено передаёт
управление следующему. Цепь не всегда линейна: иногда её нужно прервать. В
одном из middleware мы поняли, что у пользователя нет прав. Продолжать не имеет
смысла~--- наоборот, как можно скорее оборвём стек.

\index{HTTP!400}

Middleware часто содержат условия. Например, \verb|wrap-json-params| читает тело
только если заголовок \verb|Content-Type| верного типа. Когда в нём что-то
другое, враппер ничего не делает. Разбор JSON бросит исключение, если документ
повредился из-за сбоя в сети. В этом случае \verb|wrap-json-params| не
продолжает цепочку. Оно вернёт ответ 400 JSON body malformed, и ни одно
middleware ниже по стеку не сработает.

Пусть приложение доступно только по авторизации. С~помощью
\verb|wrap-current-user| получим текущего пользователя. Это middleware только
находит пользователя, но не ограничивает доступ. Добавим ещё одно:

\index{middleware!wrap-current-user}
\index{middleware!wrap-auth-user-only}
\index{HTTP!авторизация}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers
       {"content-type" "text/plain"}
       :body "Sign in to get access."})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers {"content-type" "text/plain"}
       :body "Please sign in to access this page."})))
  \end{clojure}
\end{english}

\fi

Переход к следующему middleware под условием. Если пользователь не
авторизован, звенья ниже \verb|wrap-auth-user-only| будут отброшены.

Мы уже говорили, что цепочка middleware~--- это подъём в гору и~спуск с
неё. Если звено терпит неудачу, мы как будто срезаем верхушку: добрались до
середины, столкнулись с проблемой и повернули обратно. \emph{Общее правило:} чем
раньше мы обнаружим проблему, тем меньше потратим ресурсов. Поэтому более общие
проверки ставят выше по стеку (или ниже в операторе \arr).

\index{ошибки!HTTP}

Ещё один вариант развилки~--- перехват ошибок. Это важный обработчик, но его
нет в поставке Ring, потому что реакция на ошибки зависит от многих
факторов. Враппер копируют из проекта в проект с~небольшими изменениями.

Что случится, если при обработке запроса возникнет исключение? На этот счёт
нет чётких правил: каждый фреймворк ведёт себя по-разному. Один покажет
стек-трейс в браузере, другой вернёт HTML с~информацией для
отладки. Разработчики третьего посчитали, что показывать эти данные
небезопасно. Исключение пишут в~лог, а клиенту вернут нейтральную фразу об
ошибке.

Полезно, когда мы сами определяем, что делать с исключением. Ниже middleware,
которое ловит ошибку, пишет её в лог и возвращает ответ-заглушку:

\index{middleware!wrap-exception}

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn wrap-exception [handler]
  (fn [{:keys [uri request-method]
        :as request}]
    (try
      (handler request)
      (catch Throwable e
        (log/errorf e
          "Error, method %s, path %s"
          request-method uri)
          {:status 500
           :headers
           {"content-type" "text/plain"}
           :body "Sorry, try later."}))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn wrap-exception [handler]
  (fn [request]
    (try
      (handler request)
      (catch Throwable e
        (let [{:keys [uri request-method]} request]
          (log/errorf e "Error, method %s, path %s"
                      request-method uri)
          {:status 500
           :headers {"content-type" "text/plain"}
           :body "Sorry, please try later."})))))
  \end{clojure}
\end{english}

\fi

\index{логирование!HTTP}

Выражение \verb|log/errorf|~--- это макрос для записи ошибки. Он принимает
исключение, шаблон сообщения и параметры. Важно знать, какие были метод и путь
запроса, поэтому запишем их тоже. Это облегчит анализ логов в будущем.

Чем выше \verb|wrap-exception| в стеке, тем меньше у исключения шансов дойти
до пользователя. В идеале оно стоит на вершине цепочки, чтобы ловить все
исключения.

Иногда используют двойной перехват. Ошибки в разных частях системы заслуживают
разного подхода. Об ошибках в бизнес-логике важно знать всё. Если
пользователь не смог купить товар, запишем весь контекст, который был на момент
покупки. Но если пришёл повреждённый JSON, это техническая проблема, не
связанная с бизнесом. Исключение здесь~--- это норма, потому его не пишут в лог.

Чтобы разделить бизнес- и технические проблемы, на границах стека расставляют
разные \verb|wrap-exception|. Самое нижнее оборачивает \verb|app-naked|: оно
ловит исключения в бизнес-логике. Такую ошибку пишут в журнал максимально
подробно. На вершине стека другая, облегчённая версия \verb|wrap-exception|.
Оно подавляет технические проблемы на предварительных этапах. Его задача~--- вернуть
адекватный ответ и не засорять журнал.

\subsection{Middleware вне стека}

\index{middleware!вне стека}

Интересен сценарий, когда middleware влияет на запросы по определённому пути. В
чём недостаток \verb|wrap-auth-user-only|? Если добавить его в стек, анонимный
пользователь не увидит ничего: каждый запрос завершится с кодом 403. Главная
страница, контактные данные, форма входа~--- всё будет недоступно. Кому
нужно такое приложение?

\mnoindent
Очевидно, проверка должна касаться только части запросов. Например, тех, что
начинаются с \verb|/account|: \verb|/account/cart|, \verb|/account/orders|,
и других. Место \verb|wrap-auth-user-only| не в общем стеке, а ниже~--- на
уровне маршрута.

Реализация зависит от того, как мы строим маршруты. Compojure предлагает
middleware под названием \verb|wrap-routes|. Оно принимает правило и
\emph{другое} middleware. Последнее сработает только в том случае, если правило
подходит запросу. Столь сложная логика нужна, чтобы не вызвать middleware, пока
запрос не совпадет с правилом.

Построим отдельные маршруты с личной информацией:

\begin{english}
  \begin{clojure}
(defroutes app-account
  (GET "/cart"    _ "cart")
  (GET "/orders"  _ "orders")
  (GET "/profile" _ "profile"))
  \end{clojure}
\end{english}

\noindent
Смонтируем её на префикс \verb|/account| и обернём в проверку доступа.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/"     _ "index")
  (GET "/help" _ "help")
  (context "/account" []
    (wrap-routes app-account
                 wrap-auth-user-only)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/"     _ "index")
  (GET "/help" _ "help")
  (context "/account" []
    (wrap-routes app-account wrap-auth-user-only)))
  \end{clojure}
\end{english}

\fi

\index{функции!wrap-routes}

Теперь \verb|wrap-auth-user-only| сработает только для путей, которые
начинаются с \verb|/account|. На главной и справочной страницах проверки
доступа не будет.

Middleware, которое принимает middleware,~--- довольно крутая абстракция. Если вы
поняли, как оно работает, примите поздравления: это серьёзный рубеж.

\section{Файлы и ресурсы}

\label{http-files}

До сих пор мы возвращали в ответе строки или коллекции. Рассмотрим случай, когда
данные находятся в файле. Предположим, мобильное приложение запрашивает адреса
банкоматов и отделений. Банк хранит эти данные во внутренней сети, и у
веб-приложения нет к ним доступа. Кроме того, новые отделения и банкоматы
появляются редко, поэтому обращаться на каждый запрос в базу данных
расточительно. Раз в~неделю скрипт выгружает данные в файл и копирует на сервер,
где работает веб-приложение.

\index{файлы!выгрузка}
\index{clojure.core!slurp}

Наивное решение в том, чтобы прочитать файл функцией \verb|slurp| и~вернуть
его содержимое:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn page-terminals [request]
  {:status 200
   :headers
   {"content-type" "application/json"}
   :body (slurp "terminals.json")})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn page-terminals [request]
  {:status 200
   :headers {"content-type" "application/json"}
   :body (slurp "terminals.json")})
  \end{clojure}
\end{english}

\fi

Недостаток в том, что мы читаем файл в память целиком. Чем больше файл, тем
больше ресурсов мы потребляем. Если клиент читает данные медленно, данные будут
висеть в памяти зря. Мы не начнём ответ до тех пор, пока весь файл не
попадёт в память. Способ не подходит для больших файлов из-за расхода
памяти. Наконец, \verb|slurp| читает из файла строку, что не подходит для
двоичных файлов (картинок, PDF). В примере ниже браузер получит повреждённое
содержимое.

\begin{english}
  \begin{clojure}
(defn app [request]
  {:status 200
   :headers {"content-type" "image/png"}
   :body (slurp "/path/to/image.png")})
  \end{clojure}
\end{english}

\index{форматы!PDF}
\index{модули!clojure.java.io}

Ring допускает, чтобы телом ответа был файл, экземпляр класса
\verb|java.io.File|. Чтобы получить объект файла, путь к нему передают
в~конструктор класса или функцию \verb|file| из модуля \verb|clojure.java.io|:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(defn page-terminals
  [request]
  {:status 200
   :headers
   {"content-type" "application/json"}
   :body (io/file "terminals.json")})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(defn page-terminals
  [request]
  {:status 200
   :headers {"content-type" "application/json"}
   :body (io/file "terminals.json")})
  \end{clojure}
\end{english}

\fi

\index{заголовки!Content-Length}

Если тело~--- это файл, сервер отдаёт содержимое малыми порциями по мере того, как
клиент его читает. Сервер автоматически добавит заголовок
\verb|Content-Length| с размером файла.

Когда файлов несколько, плодить правило на каждый из них утомительно:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/terminals.json"
       req (page-terminals req))
  (GET "/departments.json"
       req (page-departments req)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/terminals.json"   request (page-terminals request))
  (GET "/departments.json" request (page-departments request)))
  \end{clojure}
\end{english}

\fi

\index{middleware!wrap-file}

Очевидно, можно сопоставить путь к файлу и директорию, где он находится. Для
этого служит middleware \verb|wrap-file|. Оно устроено так, что если запрос не
подошёл основному приложению, middleware выполнит поиск файла в указанной папке.

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[ring.middleware.file
           :refer [wrap-file]])

(def app
  (-> app-naked
      (wrap-file "/var/www/public")))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[ring.middleware.file :refer [wrap-file]])

(def app (-> app-naked
             (wrap-file "/var/www/public")))
  \end{clojure}
\end{english}

\fi

Запрос \verb|/terminals.json| проскочит мимо app, но разрешится в
одноимённый файл по пути \verb|/var/www/public/terminals.json|. Со
временем в эту папку можно добавить другие файлы и ставить на них ссылки по
именам: \verb|/manual.pdf|, \verb|/price_2020.xlsx|.

Ссылки на статичные ресурсы отделяют префиксом \verb|/static|. Кроме того,
близкие по типу файлы группируют в дочерних директориях: \verb|/static/img|,
\verb|/static/js| и так далее. Согласно правилу, физический путь к картинке
будет \verb|/var/www/public/static/img/logo.png|.

Кроме файлов, Ring работает с ресурсами JVM. Они похожи на файлы, но после
сборки приложения становятся частью uberjar. В~этом случае приложение читает
ресурсы из самого себя, а не с диска.

Преимущество ресурсов в том, что приложение не зависит от сторонних файлов. Это
делает его автономным и упрощает деплой~--- не придётся копировать статичные
файлы на сервер. С другой стороны, ресурсы нельзя обновить по требованию. Если
нужно исправить логотип или стиль CSS, которые входят в ресурсы, вы должны
собрать проект заново. Для ресурсов служит похожее middleware
\verb|wrap-resource|:

\index{middleware!wrap-resource}

\begin{english}
  \begin{clojure}
(require '[ring.middleware.resource
           :refer [wrap-resource]])

(def app (-> app-naked
             (wrap-resource "public")))
  \end{clojure}
\end{english}

По аналогии с \verb|wrap-files| оно принимает путь, относительно которого нужно
искать ресурсы. Всё, что мы говорили о префиксах, справедливо и для
ресурсов. Чтобы ссылка \verb|/static/img/logo.png| вела на ресурс, он должен
быть по пути \texttt{resources/public/static\-/img/logo.png}. Мы подробно рассмотрим
ресурсы в будущих главах \page{resources}.

Если открыть браузер и ввести путь со статичным файлом, откроется окно с
предложением сохранить файл на диск. Это не всегда то, что мы
ожидаем. Современные браузеры умеют показывать почти все известные форматы:
картинки, музыку, PDF, JSON, XML и другие. Хотелось бы увидеть файл сразу в
браузере.

Окно сохранения возникает потому, что для файлов и ресурсов заголовок
\verb|Content-Type| по умолчанию равен \verb|application/octet-stream|,
бинарный поток. Чтобы определить тип по расширению файла, добавьте ещё одно
middleware \verb|wrap-content-type|:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[ring.middleware.content-type
           :refer [wrap-content-type]])

(def mime-types
      {"json" "application/json"
       "png" "image/png"
       "xls" "application/vnd.ms-excel"})

(def app
  (-> app-naked
      (wrap-content-type
        {:mime-types mime-types})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[ring.middleware.content-type
           :refer [wrap-content-type]])

(def app
  (-> app-naked
      (wrap-content-type
       {:mime-types
         {"json" "application/json"
          "png" "image/png"
          "xls" "application/vnd.ms-excel"}})))
  \end{clojure}
\end{english}

\fi

Параметр \verb|:mime-types| принимает словарь
\footurl{MIME-типов}{https://en.wikipedia.org/wiki/MIME}[MIME types][-5mm] и
расширений. Добавьте нужные типы и проверьте, что браузер отображает файлы
корректно.

\index{HTTP!стриминг}

\section{Стриминг и проксирование}

Телом ответа может быть в том числе входящий поток, экземпляр класса
\verb|InputStream|. Особенность потока в том, что его читают один раз. Потоки
широко используются в Java, и некоторые библиотеки возвращают их
напрямую. Например, при создании PDF мы получим поток с бинарным содержимым
документа. Чтобы не писать поток во~временный файл, направим его в ответ
HTTP. Потребитель считает поток по мере загрузки в браузере.

Отдача потока называется стримингом (англ.~stream~--- <<поток>>). Поток может быть
огромных размеров, в том числе бесконечным. Например, поток изображения с камеры
потенциально не закончится никогда.

Ещё лучше потоки подходят для проксирования. Под этим словом имеют в виду
передачу данных через посредника. Предположим, внутренний сервер компании
выдаёт по запросу важные данные. Мы должны предоставить их клиентам. Однако
нельзя открывать им прямой доступ ко внутреннему ресурсу. Вместо этого мы пишем
промежуточный слой, который проверяет права доступа. Если всё в порядке, мы
посылаем HTTP-запрос во внутренний сервис и получаем поток. Он становится телом
нашего ответа клиенту. Мы не вмешиваемся в~содержимое, а только соединяем поток с
нужным потребителем.

Напишем прокси-приложение, которое вернёт главную страницу Яндекса. В
запросе мы обращаемся к ней по протоколу GET. В опциях передаём флаг
\verb|stream?|, что означает <<не читать ответ>>. В этом случае тело будет
потоком, а не не строкой HTML. Поля \verb|status| и \verb|body| ответа
Яндекса переходят в наш ответ. Это касается и заголовков, но мы возвращаем их не
все, а подмножество (в нашем случае \verb|Content-Type|).

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(require '[clj-http.client :as client])

(defn app-proxy [req]
  (let [resp (client/get "https://ya.ru"
                         {:stream? true})
        {status :status
         headers :headers
         body :body} resp]
    {:status status
     :headers (select-keys
                headers ["Content-Type"])
     :body body}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clj-http.client :as client])

(defn app-proxy [request]
  (let [response (client/get "https://ya.ru" {:stream? true})
        {:keys [status headers body]} response
        headers* (select-keys headers ["Content-Type"])]
    {:status status
     :headers headers*
     :body body}))
  \end{clojure}
\end{english}

\fi

Запустите \verb|app-proxy| в браузере. Вы увидите главную страницу Яндекса,
хотя адрес по-прежнему \verb|localhost|. Код \verb|app-proxy| можно выразить
короче с помощью стрелочного оператора:

\ifx\DEVICETYPE\MOBILE

\begin{english}
  \begin{clojure}
(defn app-proxy [request]
  (-> "https://ya.ru"
      (client/get {:stream? true})
      (select-keys [:status
                    :body :headers])
      (update :headers
        select-keys ["Content-Type"])))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn app-proxy [request]
  (-> "https://ya.ru"
      (client/get {:stream? true})
      (select-keys [:status :body :headers])
      (update :headers select-keys ["Content-Type"])))
  \end{clojure}
\end{english}

\fi

Доработайте прокси, чтобы он работал с разными сайтами. Добавьте поддержку форм
методом POST, опробуйте загрузку файлов. Какие ещё заголовки понадобятся
вдобавок к \verb|Content-Type|?

\emph{Задача для настоящих хакеров.} Вы пишете программу для мобильного
оператора. Если клиент обратился к HTML-странице по незащищённому соединению, вы
должны добавить после тега \verb|<head>| рекламный скрипт. Как это сделать
в~полёте, не сохраняя страницу в~память или на диск?

\section{Другие библиотеки}

Для веб-разработки Clojure написаны другие фреймворки и библиотеки. Если
возможностей Ring не хватает, обратитесь к проектам ниже.

\begin{itemize}

\index{библиотеки!Compojure API}
\index{организации!Metosin}
\index{веб-разработка!Swagger}

\item
  \footurl{Compojure API}{https://github.com/metosin/compojure-api}[Compo-\\*jure API][-37mm]~---
  убернадстройка над обычным Compojure. Набор макросов, чтобы описать REST
  API. Библиотека тесно связана с JSON-схемой и Swagger.

\index{библиотеки!Luminus}
\index{сайты!luminusweb.com}

\item
  \footurl{Luminus}{https://luminusweb.com}[Luminus][-28mm]~--- шаблон
  веб-приложения. Включает \verb|Compojure API| для маршрутов, модуль базы
  данных, миграции и многое другое из коробки. У проекта достойная документация
  и сообщество, куда можно обратиться за помощью.

\index{библиотеки!Pedestal}
\index{организации!Cognitect}

\item
  \footurl{Pedestal}{https://github.com/pedestal/pedestal}[Pedestal][-23mm]~--- фреймворк
  компании Cognitect. Отличается гибкой системой перехватчиков
  (англ.~\emph{interceptors}), с помощью которых вложенную логику описывают
  линейно.

\index{библиотеки!Vase}
\index{организации!Cognitect}
\index{базы данных!Datomic}
\index{форматы!EDN}

\item
  \footurl{Vase}{https://github.com/cognitect-labs/vase}[Vase][-15mm]~---
  экспериментальная обёртка над Pedestal. Задаёт логику в файле
  EDN. Тесно связана с Datomic, базой данных Cognitect.

\index{библиотеки!Duct}

\item
  \footurl{Duct}{https://github.com/duct-framework/duct}[Duct][-4mm]~--- новый
  фреймворк от создателя Ring. Проект на ранней стадии, и документации
  мало. Делает упор на модульность и~систему компонентов \page{chapter-systems}.

\index{библиотеки!Liberator}
\index{языки!Erlang}
\index{мультиметоды}

\item
  \footurl{Liberator}{https://clojure-liberator.github.io/liberator}[Liberator][2mm]~---
  аналог проекта Webmachine для Erlang. Запрос и~ответ проходят стадии, на
  каждую из которых можно задать реакцию. Предлагает систему правил на базе
  мультиметодов.

\end{itemize}

\section{Заключение}

Современный веб работает по HTTP. Это текстовый протокол на базе TCP/IP. Обмен
по HTTP проходит в две фазы: запрос и~ответ. Оба состоят из первой строки,
заголовков и тела, которого может не быть.

Для запроса важны его метод и путь, а для ответа~--- статус. С~развитием веба
появились соглашения о том, как строить HTTP API. Самое популярное называется
REST. Согласно ему, путь определяет ресурс, а метод~--- действие над ним. Данные
передают в~формате JSON.

Чтобы писать веб на Clojure, установите Ring. Это набор библиотек, в которых
самое нужное: базовые абстракции, middleware и веб-сервер. Обработчик запроса~---
это функция, которая принимает запрос и возвращает ответ. Обе сущности~--- словари.

В поставке Ring нет маршрутов, для них требуются сторонние библиотеки. Compojure
предлагает макросы, чтобы задать маршруты правилами. Bidi строит дерево тегов,
которое работает в паре с~мультиметодом.

Middleware~--- это функция, которая оборачивает другую функцию. Их цепочка
называется стеком. Его описывают стрелочным оператором: это экономит скобки и
делает запись наглядней. Middleware нужны для предварительной обработки запроса:
прочитать JSON из тела или проверить права доступа. Отдельные middleware
прерывают стек, если возникло исключение или запрос нельзя обработать.

Кроме Ring, для Clojure написаны другие фреймворки. Они задают структуру
проекта, вводят правила и соглашения. Некоторые из них повторяют аналоги в
других языках. Каждый фреймворк в чём-то лучше других, поэтому выбирайте,
отталкиваясь от задачи.
