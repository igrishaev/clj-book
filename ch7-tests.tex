\chapter{Тесты}

\index{тесты}

\label{chapter-tests}

\begin{teaser}
В последней главе мы поговорим о тестировании кода. Читатель узнает, что такое
тесты и каких видов они бывают. Обойдёмся без лишней сложности: опустим
термины вроде TDD и BDT. Покажем, что в~Clojure легко писать и
поддерживать тесты.
\end{teaser}

\section{Основные понятия}

На тему тестов написано много книг и статей, придуманы методологии. Их
сторонники отстаивают позиции в долгих спорах. Начинающих сбивает с толку
фрагментация терминов и мнений. Чтобы погрузиться в тему, расскажем о тестах
простыми словами.

\index{температура!по Цельсию}
\index{температура!по Фаренгейту}

Тест~--- это код, который проверяет другой код. Напишем функцию для перевода
температуры из Цельсия в Фаренгейта:

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
  \end{clojure}
\end{english}

\index{функции!\arr{}fahr}

Мы вызвали её несколько раз и убедились, что результаты такие же, как в
справочнике. Зафиксируем расчёты в функции проверки. Она сравнивает вызов
\verb|->fahr| с каноничными значениями. Их посчитали заранее и расценивают как
эталон.

\begin{english}
  \begin{clojure}
(defn test-fahr []
  (assert (=  68 (int (->fahr 20))))
  (assert (= 212 (int (->fahr 100)))))
  \end{clojure}
\end{english}

\index{числа!целые}
\index{числа!с плавающей запятой}

Примечание: в тесте мы сравниваем результат \verb|->fahr| с целым числом. Без
обёртки в \verb|(int ...)| функция вернёт число с плавающей запятой, которое
\footurl{не всегда равно}{https://en.wikipedia.org/wiki/Floating-point\_arithmetic}[Floating point][-6mm]
другому такому же числу. Для удобства значение приводят к целому.

Макрос \verb|assert| бросит исключение, если тело вычисляется в ложь. Пока что
\verb|(test-fahr)| работает без ошибок, потому что расчёты верны. Если изменить
формулу, получим исключение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.9) 32))

(test-fahr)
;; Assert failed:
;; (= (int (->fahr 20)) 68)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.9) 32))

(test-fahr)
;; Assert failed: (= (int (->fahr 20)) 68)
  \end{clojure}
\end{english}

\fi

Функция \verb|test-fahr| и есть тест. Она проверяет, что код \verb|->fahr|
не изменили так, что получится другой результат. В наших интересах вызвать
\verb|(test-fahr)| перед сборкой программы. Так мы не допустим, чтобы код с
ошибкой попал в производство.

\index{факториал}

Тест не знает устройства функции, которую проверяет. Мы вправе менять алгоритм
до тех пор, пока тест работает без ошибок. Предположим, мы тестируем функцию
факториала. В первой версии мы линейно умножаем числа, что неэффективно. Но уже
на этой стадии добавим тест, что $5! = 120$. Если заменить линейный алгоритм на
дерево или таблицу значений, тест пройдёт без ошибок. В противном случае это
значит, что в новом алгоритме ошибка.

\subsection{Кейсы и покрытие}

\index{тесты!кейсы}

Близкие по семантике тесты объединяются в \emph{кейсы}. Вспомним школьную задачу
с квадратным уравнением: найти корни по заданным коэффициентам $a$, $b$,
$c$. Особенность задачи в том, что её логика ветвится. В~зависимости от
параметров может быть два корня, один или ни одного.

\index{квадратное уравнение}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn square-roots [a b c]
  (let [D (- (* b b) (* 4 a c))]
    (cond
      (pos? D)
      [(/ (+ (- b) (Math/sqrt D))
          (* 2 a))
       (/ (- (- b) (Math/sqrt D))
          (* 2 a))]
      (zero? D) [(/ (- b) (* 2 a))]
      (neg? D) nil)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn square-roots [a b c]
  (let [D (- (* b b) (* 4 a c))]
    (cond
      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
      (zero? D) [(/ (- b) (* 2 a))]
      (neg? D) nil)))
  \end{clojure}
\end{english}

\fi

\index{функции!square-roots}

Чтобы проверить алгоритм, тест вызывает функцию \verb|square-roots| минимум три
раза. Подберём параметры так, чтобы сработала каждая ветка. Ещё лучше, если на
каждую ветку приходится отдельный тест, чтобы расширить его в будущем. Тесты ниже
образуют кейс, который проверяет алгоритм целиком.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn test-square-roots-two-roots []
  (let [[x1 x2] (square-roots 1 -5 6)]
    (assert
      (= [3 2]
         [(int x1) (int x2)]))))

(defn test-square-roots-one-root []
  (let [[x1 x2] (square-roots 1 6 9)]
    (assert (= [-3] [(int x1)]))
    (assert (nil? x2))))

(defn test-square-roots-no-roots []
  (assert (nil? (square-roots 2 4 7))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn test-square-roots-two-roots []
  (let [[x1 x2] (square-roots 1 -5 6)]
    (assert (= [3 2] [(int x1) (int x2)]))))

(defn test-square-roots-one-root []
  (let [[x1 x2] (square-roots 1 6 9)]
    (assert (= [-3] [(int x1)]))
    (assert (nil? x2))))

(defn test-square-roots-no-roots []
  (assert (nil? (square-roots 2 4 7))))
  \end{clojure}
\end{english}

\fi

В объектно-ориентированных языках кейсы~--- это классы, а тесты~--- их
методы. Clojure устроена проще: тест~--- это функция, а роль кейса играет
пространство.

\index{покрытие}

В тестах часто упоминают \emph{покрытие}. Так называют долю кода, которая
сработала в тесте. Предположим, мы написали тест только для двух корней. В этом
случае ветки \verb|(zero? D)| и \verb|(neg? D)| не сработают. Фреймворк считает
общее число строк и сколько из них выполнились. Покрытие~--- это отношение второй
величины к первой, число от нуля до единицы.

Некоторые библиотеки строят отчёт, где выполненные строки отмечены зелёным
(плюсом), а пропущенные~--- красным (минусом). Подсчёт покрытия~--- это трудная задача,
поэтому её выносят в расширение фреймворка. Для нашего случая мы получили бы
вывод:

\ifx\devicetype\mobile

\begin{english}
  \begin{diff}
+(defn square-roots [a b c]
+  (let [D (- (* b b) (* 4 a c))]
+    (cond
+      (pos? D)
+      [(/ (+ (- b) (Math/sqrt D))
+          (* 2 a))
+       (/ (- (- b) (Math/sqrt D))
+          (* 2 a))]
-      (zero? D) [(/ (- b) (* 2 a))]
-      (neg? D) nil)))
  \end{diff}
\end{english}

\else

\begin{english}
  \begin{diff}
+(defn square-roots [a b c]
+  (let [D (- (* b b) (* 4 a c))]
+    (cond
+      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
+                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
-      (zero? D) [(/ (- b) (* 2 a))]
-      (neg? D) nil)))
  \end{diff}
\end{english}
\fi

\ifx\devicetype\mobile

\def\covperc{80\%}

\else

\def\covperc{71\%}

\fi

\ifx\devicetype\mobile
В функции \verb|square-roots| десять строк. При запуске теста сработали восемь из
них. Покрытие составит 8/10, что дает \covperc. Считается, что покрытия
90\% достаточно, чтобы код работал надёжно. Значения ниже говорят о малом
покрытии. Это значит, в проекте встречается код без защиты от спонтанных
изменений. При попытке приблизиться к~100\% тесты становятся затратными в
поддержке. В~каждой команде следуют той величине, которая удобна процессу.
\else
В функции \verb|square-roots| семь строк. При запуске теста сработали пять из
них. Покрытие составит 5/7, что приблизительно \covperc. Считается, что покрытия
90\% достаточно, чтобы код работал надёжно. Значения ниже говорят о малом
покрытии. Это значит, в проекте встречается код без защиты от спонтанных
изменений. При попытке приблизиться к~100\% тесты становятся затратными в
поддержке. В~каждой команде следуют той величине, которая удобна процессу.
\fi

Величина в процентах не должна затмевать здравый смысл. Цифра \covperc кажется
большой только на первый взгляд. Из покрытия видно, что мы проверяем одну ветку
алгоритма из трёх. Если в двух других ошибки, мы не узнаем о них. При оценке
покрытия смотрят не на проценты, а на развилки алгоритма. Надёжный тест
гарантирует, что сработала каждая ветка.

\subsection{Не только числа}

У начинающих складывается мнение, что тесты пишут только для математических
расчётов. На самом деле тесты подходят для всех действий, которые хотят
зафиксировать. Это может быть обход коллекции, криптография, поиск в тексте.

Рассмотрим подпись HTTP-запроса. Функция \verb|sign-params| принимает словарь
параметров и секретный ключ. Алгоритм подписи следующий:

\begin{itemize}

\index{HMAC-SHA256}

\item
  отсортировать параметры по ключам;

\item
  составить строку \verb|param1=value1&param2=value2...|;

\item
  экранировать пробел, процент и другие служебные символы;

\item
  получить сигнатуру строки по алгоритму HMAC-SHA256 и секретному ключу;

\item
  вернуть словарь параметров с полем \verb|:signature|.

\end{itemize}

\index{сигнатура}

Так работает авторизация в популярных сервисах. Напишем тест для функции
подписи. Проверим, что входные параметры дополнены сигнатурой, которую посчитали
заранее.

\label{hmac-sha256}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn test-sign-params []
  (let [secret-key "fnsd809SDf2dfs3t"
        params
        {:api_key "2Ag48776s634Tsdf"
         :action :postComment
         :post_id 217
         :comment
         "This is a great article!"}
        signature "01b03dbf1fa5a4c5"]
    (assert
      (= (assoc params
           :signature signature)
         (sign-params params
           secret-key)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn test-sign-params []
  (let [secret-key "fnsd809SDf2dfs3t"
        params {:api_key "2Ag48776s634Tsdf"
                :action :postComment
                :post_id 217
                :comment "This is a great article!"}
        signature "01b03dbf1fa5a4c5"]
    (assert (= (assoc params :signature signature)
               (sign-params params secret-key)))))
  \end{clojure}
\end{english}

\fi

Заметим, что \verb|sign-params| работает не с числами, а с коллекциями
и~криптографией. Это не помешало написать для неё тест. Чтобы улучшить нашу
работу, добавьте проверку на пустой ключ, экранирование символов, кириллицу,
эмодзи и так далее.

\subsection{Что тестировать}

Иногда разработчики не понимают, какие функции нужно проверить, и~тестов не
хватает. Другая крайность~--- писать тесты строго для каждой функции. Это
приводит к их избыточности и замедляет разработку. Верное решение, как всегда,
посередине.

Тестируйте действия, которые атомарны с точки зрения логики. Подпись запроса
состоит из мелких функций: сортировки, экранирования и других. Если проверять
каждый шаг, получится слишком много кода. В будущем алгоритм подписи изменится,
и тесты удалят. И наоборот, когда тестируют огромный пласт кода, трудно понять,
почему возникла ошибка. Тест становится хрупким: малейшее изменение рушит
его. Крупные тесты разбивают на несколько поменьше.

\index{пирамида тестов}

Подробнее на вопрос отвечает \footurl{пирамида тестов}{https://martinfowler.com/bliki/TestPyramid.html}[Test Pyramid].
Это модель, где тесты разделены на слои. Чем выше слой, тем больше логики он
покрывает. Говорить о пирамиде преждевременно; мы вернёмся к ней ближе к концу
главы.

\subsection{О чистоте функций}

\index{чистые функции}

Функцию удобно тестировать, если у неё нет побочных эффектов. Это значит, что
функция не обращается к диску, сети и глобальным переменным. Результат зависит
только от входных параметров. Случайное число и~текущая дата тоже считаются
побочными эффектами.

Пусть функция читает файл. Перед запуском теста мы пишем файл в нужное место, а
потом удаляем его. Тест становится сложнее, потому что теперь зависит от
окружения. Чтобы облегчить тестирование, функцию разделяют на две: первая читает
содержимое файла и передаёт во вторую. До исправления:

\index{форматы!CSV}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn process-csv [path]
  (let [content (slurp path)]
    (for [line (clojure.string/split
                 content #"\n")]
      (remap-line line))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn process-csv [path]
  (let [content (slurp path)]
    (for [line (clojure.string/split content #"\n")]
      (remap-line line))))
  \end{clojure}
\end{english}

\fi

\noindent
и после:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn process-csv-content [content]
  (for [line (clojure.string/split
               content #"\n")]
    (remap-line line)))

(defn process-csv [path]
  (process-csv-content (slurp path)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn process-csv-content [content]
  (for [line (clojure.string/split content #"\n")]
    (remap-line line)))

(defn process-csv [path]
  (process-csv-content (slurp path)))
  \end{clojure}
\end{english}

\fi

Напишем тест для \verb|process-csv-content|. Не придётся создавать файл на
диске: функция принимает строку, которую объявим на месте.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def CONTENT
  (str "Ivan;ivan@test.ru;"
       "http://example.ru"
       \newline
       "John;john@test.com;"
       "http://example.com"))

(assert
  (= [{:name "Ivan" :email ...}
      {:name "John" :email ...}]
     (process-csv-content CONTENT)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def CONTENT
  (str "Ivan;ivan@test.ru;http://example.ru"
       \newline
       "John;john@test.com;http://example.com"))

(assert (= [{:name "Ivan" :email ...}
            {:name "John" :email ...}]
           (process-csv-content CONTENT)))
  \end{clojure}
\end{english}

\fi

Другой способ в том, чтобы заменить функцию на мультиметод. Реализация зависит
от первого аргумента. Если это файл, читаем его и~снова вызываем мультиметод со
строкой. Для строки запускаем логику разбора.

Чистая функция~--- это идеальный случай тестирования. Промышленный код трудно
изолировать от побочных эффектов, а иногда это невозможно. Чтобы тестировать код
с эффектами, прибегают к расширенным практикам: используют заглушки (стабы),
меняют объекты в~рантайме (моки). Мы рассмотрим эти и другие приёмы ниже.

Подмена среды~--- это вынужденная мера, и к ней прибегают в последнюю
очередь. Проверьте, можно ли выделить в коде чистую часть и~насколько это
затратно. Возможно, небольшое изменение в коде упростит тесты.

\subsection{Производство}

\index{сервисы!GitHub}
\index{сервисы!CircleCI}
\index{сервисы!Slack}

Тесты не только проверяют логику, но и помогают на разных стадиях
производства. Ветку с изменениями нельзя слить в мастер до тех пор, пока не
пройдут тесты. Так вы обезопасите код от случайных изменений.

Если разработчик добавил код без тестов, это снизит долю покрытия. Можно задать
правило, что при покрытии ниже порога слияние запрещено. GitHub, CircleCI и
другие сервисы гибко реагируют на ошибки в тестах. Они шлют письма, пишут
сообщения в Slack, всячески сигналят о проблеме.

Иногда тесты заменяют документацию. В открытых проектах её нехватку
компенсируют тестами, потому что на качественный текст уходит столько же
времени, сколько на разработку. Если вы не уверены, как работает функция,
возможно, её поведение прояснится в тесте.

\subsection{Устройство тестов}

Функция с макросом \verb|assert|~--- это не тест, а приближение. Она пригодится на
раннем этапе, когда автор только обозначил контуры программы. Для полноценных
тестов понадобится фреймворк~--- библиотека, которая определяет, где и как писать
тесты.

Если выполнить команду \verb|lein test| в папке проекта, запустится тестовый
фреймворк. Это сложный цикл из нескольких шагов. Рассмотрим основные из них,
чтобы читатель понял его устройство.

На первом этапе фреймворк ищет тесты в коде проекта. По-другому этап называется
test discovery. Каждый найденный тест попадает в~глобальный регистр.

Тест должен носить признак, которым он отличается от обычной функции. В примере
выше \verb|test-sign-params|~--- это именно функция, а~не тест (префикс \verb|test-|
ни на что не влияет). Далее мы рассмотрим, как превратить её в тест.

Когда тесты найдены, система определяет, какие из них вызвать. Если не заданы
фильтры, сработают все тесты. Иногда нужно выполнить их подмножество по имени
или тегу. В этом случае происходит отбор тестов.

На этапе прогона фреймворк выполняет тесты один за другим как функции. Система
фиксирует их количество и имена. Тест обёрнут в~\verb|try/catch|, чтобы
исключение не оборвало процесс. Каждая проверка оседает в накопителе. Эти
сведения необходимы, чтобы построить отчёт.

На этапе отчёта система выводит данные в консоль. Отчёт должен быть понятен
человеку. Проблемные тесты обозначены красным цветом. Для неудачных сравнений
ожидают полные формы, а не финальные значения. Например,
\verb|(= (int (->fahr 20)) 68)| вместо \verb|(= 69 68)|.

Фреймворки выводят отчёт в разных форматах. Кроме консоли это может быть файл
HTML. Систему настраивают так, что отчёт попадает на сервер по адресу
\verb|/<project>/<artifact>/tests.html|. Часть \verb|<artifact>|~--- это имя
ветки или хэш коммита.

Стандарт XUnit определяет, как записать отчёт в XML-файл. Системы вроде TeamCity
и CircleCI понимают, как показать его в удобном виде. У вас могут быть тесты на
Python, JavaScript или Clojure, но если прогон запущен с флагом \verb|--xunit|
(или подобным), отчёты будут похожи.

Это был поверхностный обзор того, как работает тестовый фреймворк. Далее мы
рассмотрим, как управлять им на каждом этапе.

\subsection{Типы тестов}

\index{тесты!модульные}

Прежде чем писать тесты, разберёмся, каких видов они бывают. Возможно, читатель
слышал термины <<юнит>>, <<интеграционные>> и другие. На первый взгляд, это
излишняя классификация. На практике тесты из разных категорий отличаются стилем,
окружением и запуском.

Понятие <<юнит-тест>> происходит от английского unit~--- модуль. Термин пришёл
из мира Java и фреймворка JUnit. Согласно ему, тесты группируют по модулям. На
каждый модуль приложения приходится одноимённый тестовый, который его проверяет.

\textbf{Юнит-тесты} фиксируют логику приложения. Это базовые, самые необходимые
тесты. Они поощряют чистые функции: чем меньше требований к окружению, тем
удобней поддержка. Юнит-тесты проверяют код по частям. Примеры с температурой и
уравнением были юнит-тестами.

\index{тесты!интеграционные}

\textbf{Интеграционные тесты} решают проблему, с которой не справляются
юнит-тесты. Даже если отдельные части проверены, это не значит, что они
согласованы друг с другом. Рассмотрим регистрацию на сайте. Это сложный процесс
из нескольких шагов:

\begin{itemize}

\item
  проверить, что почта ещё не занята;

\item
  создать временную учётную запись;

\item
  сгенерировать ссылку для подтверждения записи;

\item
  отправить письмо со ссылкой;

\item
  получить с почтового сервера последнее письмо;

\item
  найти в нём ссылку и перейти по ней;

\item
  проверить, что ссылка не подделана и не устарела;

\item
  активировать учётную запись.

\end{itemize}

Очевидно, в этом сценарии замешаны база данных, почтовый сервер и интерфейс.
Интеграционные тесты выполняют в среде, максимально близкой к реальности. Это
главное отличие от юнит-тестов: в первом случае окружение сужают, во втором
расширяют. Их труднее организовать из-за обширного состояния. Если выполнить
тест ещё раз без очистки базы, пользователь уже будет в системе, и сценарий не
пройдёт.

Ошибки в интеграционных тестах требуют расследования. Юнит-тесты выводят отчёт,
где чётко указано, какое выражение не равно чему. В интеграционных тестах
причина чаще всего не ясна. После нажатия на кнопку мы ожидали текст с просьбой
проверить почту, но он не появился. Была ли это ошибка на сервере? Пользователь
уже существует? Не заполнили нужное поле? Текст изменился, и селектор его не
находит? Ответ требует внимания человека.

\index{тесты!нагрузочные}

Чтобы проверить проект под нагрузкой, прибегают к \textbf{нагрузочному тестированию}.
Приложению посылают запросы и считают время ответа, число запросов, сколько
из них параллельны, потребление процессора и памяти. По этим данным строят
отчёты и графики.

\index{фичи}

Нагрузочное тестирование находит медленные части в проекте. С~помощью него
проверяют, насколько <<фича>> готова к запуску. Если боевой сервер держит сто
запросов в секунду, а новый раздел только двадцать, его отправят на доработку.

К другим типам относятся Smoke-, Sanity-, регрессионные тесты и~другие. Мы не
ставим цель рассмотреть их все. В этой главе изучим юнит- и интеграционные
тесты. К концу книги читателю хватит знаний, чтобы разобрать другие методики
самостоятельно.

\section{Тесты в Clojure}

Напишем тесты, которые отвечают требованиям фреймворка Clojure. За основу
возьмём функции температуры и квадратного уравнения, которые подготовили
выше. Пусть функция \verb|->fahr| находится в модуле
\verb|src/book/util.clj|. Создайте файл \verb|test/book/util_test.clj| с кодом:

\index{clojure.test!deftest}
\index{clojure.test!is}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.util-test
  (:require
   [book.util :refer [->fahr]]
   [clojure.test :refer
    [deftest testing is]]))

(deftest test-fahr
  (is (= 68 (int (->fahr 20))))
  (is (= 212 (int (->fahr 100)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.util-test
  (:require [book.util :refer [->fahr]]
            [clojure.test :refer [deftest testing is]]))

(deftest test-fahr
  (is (= 68 (int (->fahr 20))))
  (is (= 212 (int (->fahr 100)))))
  \end{clojure}
\end{english}

\fi

Получился тестовый модуль. Он импортирует \verb|->fahr| и объявляет тест
\verb|test-fahr|. Макросы \verb|is| и \verb|deftest| приходят из пакета
\verb|clojure.test|. Это тестовый фреймворк из поставки Clojure.

Шесть строк несут много новой информации, и у читателя появятся вопросы. Почему
тесты лежат в папке \verb|test|, а не \verb|src|? Разве не логично хранить тесты
рядом с тем, что они проверяют? Как система найдёт их?  Почему тест объявляют
макросом \verb|deftest|? Автор утверждал, что тест~--- это функция, или это не так?
Зачем менять \verb|assert| на \verb|is|? Это правильные вопросы, и мы ответим на
них по порядку.

В Clojure разделяют код приложения и тестов. Приложение находится в папке
\verb|src|, а тесты~--- в \verb|test|. У подхода несколько
преимуществ. Во-первых, код делится на смысловые части. Чтобы найти неисправный
тест, мы сужаем область поиска до папки \verb|test|, а не ищем по всему
проекту. Во-вторых, когда тесты отделены, снижается риск, что они попадут в
скомпилированный файл. В этом нет смысла, потому что тесты запускают только в
разработке. Мы напрасно увеличим время сборки и объём файла.

Во время тестов проект запускается с особым параметром. Он определяет, где ещё
кроме \verb|src| искать код. Это список, в котором по умолчанию строка
\verb|"src"|. В режиме тестов система добавляет к нему путь \verb|"test"|. Когда
компилятор ищет файлы, он по очереди обходит пути из списка. Позже мы узнаем,
как настроить их под нужды проекта.

\index{метаданные!в тестах}

Фреймворку нужен признак, чтобы отличить тест от обычной функции. Макрос
\verb|deftest| объявляет функцию и сообщает ей метаданные с полем
\verb|:test|. Чтобы найти тесты, фреймворк сканирует модули и~читает метаданные
каждой переменной. Если среди полей есть \verb|:test|, переменная считается
тестом.

Заметим, что \verb|deftest| не позволит задать аргументы теста. Это сделано
нарочно: в Clojure тест не зависит от внешних данных. Если тесту нужно особое
окружение, его задают фикстурами. Мы рассмотрим фикстуры в отдельном разделе.

Макрос \verb|is| отличается от \verb|assert| побочными
эффектами. \verb|Assert|~--- это чистое сравнение: получим либо \verb|nil|, либо
исключение. Макрос \verb|is| считает, сколько раз и с какими аргументами его
вызвали. Позже из этих данных фреймворк строит отчёт. Например, покажет все
выражения, которые не прошли проверку.

Мы только написали тест, но не запустили его. Clojure предлагает несколько
способов это сделать.

\subsection{Командная строка}

\index{утилиты!lein}

Самый простой вариант~--- поручить прогон тестов утилите. Если проект основан на
\footurl{Leiningen}{https://leiningen.org}[Leiningen][-3mm], запустите команду \verb|lein test|.
Потребуется время, чтобы считать код из папок \verb|src| и \verb|test|,
найти тесты и выполнить их. Вы увидите следующий отчёт:

\begin{english}
  \begin{text}
lein test book.util-test
Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
  \end{text}
\end{english}

Clojure группирует тесты по пространствам имён. Под каждым пространством
информация о том, сколько выполнено тестов (объявлений \verb|deftest|) и
проверок (вызовов \verb|is|). У нас один тест \verb|test-fahr| с~двумя~\verb|is|.

\index{тесты!failure}
\index{тесты!error}

Выражение \verb|lein test book.util-test| напечатано для того, чтобы его можно
было скопировать и запустить в терминале. Тогда сработают тесты только из модуля
\verb|book.util-test|.

Негативное поведение в тестах делится на failures
и~errors. \textbf{Failure} \eng{неудача} означает ложное утверждение. Если
сравнение в \verb|is| вернуло ложь, счётчик \verb|failures| увеличится на
единицу. Каждая неудача помнит, с какими параметрами её запустили. Если была
хотя бы одна неудача, команда \verb|lein test| завершится с ненулевым кодом.

Откройте функцию \verb|->fahr| и измените коэффициент 1.8 на 1.9. Сохраните
файл и выполните \verb|lein test|:

\begin{english}
  \begin{text}
$ lein test
lein test :only book.util-test/test-fahr

FAIL in (test-fahr) (util_test.clj:6)
expected: (= 68 (int (->fahr 20)))
  actual: (not (= 68 70))

FAIL in (test-fahr) (util_test.clj:7)
expected: (= 212 (int (->fahr 100)))
  actual: (not (= 212 222))

Ran 1 tests containing 2 assertions.
2 failures, 0 errors.
Tests failed.
  \end{text}
\end{english}

Отчёт показывает два \verb|failures|, что верно: макрос \verb|is| встречается
дважды. Обе проверки неверны, потому что опираются на \verb|->fahr|
с~ошибкой. Для каждого случая показаны исходное выражение и~результат.

Выражение с \verb|:only| выполнит только указанный тест. Это полезно, когда вы
работаете над участком кода и запускаете тест много раз.

\ifx\devicetype\mobile

\begin{english}
  \begin{bash}
$ lein test \
    :only book.util-test/test-fahr
  \end{bash}
\end{english}

\else

\begin{english}
  \begin{bash}
$ lein test :only book.util-test/test-fahr
  \end{bash}
\end{english}

\fi

\index{исключения!в тестах}

\textbf{Errors}~--- это непойманные исключения, которые случились во время работы
теста. В основном ошибки возникают, когда функцию вызывают с неверными
данными. Представим, что мы решили проверить \verb|->fahr| с \verb|nil|. Добавим
второй тест:

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (nil? (->fahr nil))))
  \end{clojure}
\end{english}

\noindent
Отчёт будет другим:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
$ lein test

ERROR in test-fahr-nil Numbers.java:3849
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException
    ... ;; truncated

Ran 2 tests containing 3 assertions.
0 failures, 1 errors.
Tests failed.
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
$ lein test
lein test :only book.util-test/test-fahr-nil

ERROR in (test-fahr-nil) (Numbers.java:3849)
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException: null
 at clojure.lang.Numbers.multiply (Numbers.java:3849)
    ... ;; truncated

Ran 2 tests containing 3 assertions.
0 failures, 1 errors.
Tests failed.
  \end{clojure}
\end{english}

\fi

\index{NPE}

Вызов \verb|(->fahr nil)| приводит к \verb|NullPointerException|. Фреймворк
оборачивает тест в \verb|try/catch| и запоминает исключение. Для ошибок отчёт
выводит стек-трейс, который мы сократили для экономии места.

Иногда мы \emph{ожидаем}, что функция бросит исключение при особых
параметрах. Чтобы записать это в виде утверждения, используют макрос
\verb|(is (thrown? ...))|. Мы рассмотрим пример с исключениями позже.

\subsection{REPL}

\index{REPL}

Код на Clojure работает относительно быстро (примерно как Java), но его загрузка
занимает от трёх до десяти секунд. Точное время зависит от объёма кода и
оборудования. Даже если вы запускаете один тест, проект стартует с нуля, что
неэффективно.

Когда вы работаете с проектом, вы подключены к REPL. Удобно выполнить тест прямо
в REPL, не запуская новый проект. В этом случае ожидание равно нулю.

Наивный способ выполнить тест~--- запустить его как функцию. Выражение
\verb|(test-fahr)| вернёт \verb|nil|, что означает, что утверждения
сработали верно. Теперь добавим в тест ошибку:

\begin{english}
  \begin{clojure}
(is (= 999 (int (->fahr 20))))
  \end{clojure}
\end{english}

Если сохранить файл и вызвать \verb|(test-fahr)|, \emph{по-прежнему} получим
результат без ошибок. Так происходит, потому что мы только сохранили файл, но не
загрузили изменения в Лисп-машину. То, как изменения в файле перетекают в REPL,
зависит от вашего окружения.

\index{Emacs}
\index{CIDER}

Если это Emacs и CIDER, выполните одно из следующих действий. Переместите курсор
за последнюю скобку \spverb|(deftest test-fahr...)| и~нажмите
\verb|C-c C-e|. Сработает команда \verb|cider-eval-last-sexp|, которая выполнит
последнее S-выражение.

Другой способ в том, чтобы выполнить на сервере весь буфер. Независимо от того,
где сейчас курсор, нажмите \verb|C-c C-k| или выполните команду
\verb|M-x cider-eval-buffer <RET>|. Действие равносильно тому, чтобы скопировать
буфер, вставить в REPL и нажать ввод.

После обновления вызов \verb|(test-fahr)| вернёт \verb|nil|, но в консоли
появятся строки:

\begin{english}
  \begin{clojure}
FAIL in (test-fahr) (util_test.clj:14)
expected: 999
  actual: (68)
  \end{clojure}
\end{english}

Если вызвать тест \verb|(test-fahr-nil)|, который всё ещё неисправен,
увидим исключение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
ERROR in test-fahr-nil Numbers.java:3849
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException
    ... ;; truncated
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
ERROR in (test-fahr-nil) (Numbers.java:3849)
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException: null
 at clojure.lang.Numbers.multiply (Numbers.java:3849)
    book.util$__GT_fahr.invokeStatic (util.clj:5)
    ... ;; truncated
  \end{clojure}
\end{english}

\fi

Это только вывод в консоль, а не брошенное исключение. Макрос \verb|deftest|
оборачивает тело в \verb|try/catch|.

Когда тест запускают как функцию, не работают \emph{фикстуры}. Это обработчики,
которые готовят среду для теста. О фикстурах мы поговорим позже; пока что
отметим, что функция \verb|test-vars| выполняет тесты с учётом фикстур. Она
принимает вектор объектов \verb|Var|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[clojure.test :refer [test-vars]])

(test-vars
  [#'test-fahr #'test-fahr-nil])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.test :refer [test-vars]])

(test-vars [#'test-fahr #'test-fahr-nil])
  \end{clojure}
\end{english}

\fi

\index{clojure.test!run-tests}

Функция \verb|run-tests| запускает все тесты пространства (текущего или
указанного). Технически она сводится к \verb|test-vars| со всеми переменными
пространства:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[clojure.test :refer [run-tests]])
(run-tests)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.test :refer [run-tests]])
(run-tests)
  \end{clojure}
\end{english}

\fi

Ещё одна функция \verb|run-all-tests| выполняет тесты для всех загруженных
пространств:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[clojure.test :refer [run-all-tests]])
(run-all-tests)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.test :refer [run-all-tests]])
(run-all-tests)
  \end{clojure}
\end{english}

\fi

Запустив это выражение, вы увидите, как фреймворк перебирает загруженные модули:

\begin{english}
  \begin{text}
Testing clojure.test
Testing clojure.core.server
Testing clojure.core.specs.alpha
Testing book.util
...
  \end{text}
\end{english}

\index{регулярные выражения}

Чтобы отбросить лишнее, в \verb|run-all-tests| передают регулярное выражение.
Пример ниже выполнит только тесты из модулей, чьи имена начинаются с book:

\begin{english}
  \begin{clojure}
(run-all-tests #"$book")
  \end{clojure}
\end{english}

\subsection{Emacs и CIDER}

\index{Emacs}
\index{CIDER}

Модуль \footurl{CIDER}{https://github.com/clojure-emacs/cider}[CIDER][1mm] для Emacs упрощает
работу с тестами. CIDER предлагает команды и комбинации клавиш, чтобы выполнить
один или несколько тестов. Он показывает отчёт об ошибках в отдельном
буфере. Вызвать тест клавишей удобнее, чем печатать команду в REPL.

Чтобы запустить один тест, поместите на него курсор и нажмите \verb|C-c C-t t|
(или \verb|M-x cider-test-run-test|). Курсор может быть в любом месте
\verb|(deftest ...)|. Если тест прошёл без ошибок, внизу появится зелёный
текст, иначе откроется буфер \verb|*cider-test-report*|.

Буфер выводит отчёт в удобной форме. Ошибки в утверждениях подсвечены красным
цветом, а непойманные исключения~--- жёлтым. Буфер интерактивен: если подвести
курсор к блоку с ошибкой и нажать Enter, соседнее окно покажет исходный код. То
же самое касается исключений: чтобы не засорять отчёт, CIDER выводит только
класс и~сообщение. По Enter откроется отдельный буфер со стек-трейсом.

Перечислим другие полезные команды:

\begin{itemize}

\item
  \verb|cider-test-rerun-failed-tests| (\verb|C-c C-t r|) выполнит только
  неудачные тесты из прошлого запуска. Полезно, чтобы не ждать весь прогон
  снова;

\item
  \verb|cider-test-run-ns-tests| (\verb|C-c C-t n|) выполнит тесты для текущего
  пространства. Чтобы сопоставить пространства с логикой и тестами, CIDER
  добавляет к имени первого \verb|-test|. Например, для \verb|book.util|
  тестовый модуль получится \verb|book.util-test|. Придерживайтесь этого
  правила, чтобы вызвать тесты было легко;

\item
  \verb|cider-test-run-project-tests| (\verb|C-c C-t p|) запускает все тесты
  текущего проекта. Команда полезна тем, что освобождает от \verb|lein test| в
  отдельном терминале.

\end{itemize}

Запуск тестов~--- это рутина. В идеале они запускаются клавишей и~не оттягивают на
себя внимание. Чтобы не терять время, изучите, как это сделать из редактора или
IDE.

\section{Полезные практики}

Тесты~--- это тоже код, и за ним нужен уход. Небрежность в тестах несёт столько же
проблем, сколько и в приложении. Приёмы ниже сделают тесты удобней в чтении и
поддержке.

\subsection{Testing}

\index{clojure.test!testing}

Макрос \verb|testing| оборачивает тело строкой. Это сообщение о том, что мы
собираемся делать:

\begin{english}
  \begin{clojure}
(deftest test-square-roots
  (testing "Two roots"
    (let [result (square-roots 1 -5 6)]
      (is (= [3 2] (mapv int result)))))
  (testing "One root"
    (let [result (square-roots 1 6 9)]
      (is (= [-3] (mapv int result)))))
  (testing "No roots"
    (is (nil? (square-roots 2 4 7)))))
  \end{clojure}
\end{english}

Сообщение важно по двум причинам: визуальной и технической. Оно разбивает код на
логические блоки, заменяет комментарии, делает тест понятнее. Если \verb|is|
не сработал, в отчёте будет сообщение, в которое он обёрнут.

Макросы \verb|testing| могут быть вложенными. Каждое сообщение наращивает
предыдущее через пробел. Тест ниже проверяет, что API \verb|createUser| вносит
пользователя в базу. Дополнительно мы убеждаемся, что пароль в базе
зашифрован. Если отбросить основной код, получим скелет из форм \verb|testing|,
из которых понятны наши намерения.

\begin{english}
  \begin{clojure}
(deftest test-some-api
  (testing "API call" ...
    (testing "HTTP response is OK" ...))
  (testing "DB checks:" ...
    (testing "common user fields" ...)
    (testing "password is hashed" ...)))
  \end{clojure}
\end{english}

\subsection{Исключения}

\index{исключения!в тестах}

Мы всё ещё не выясняли, как тестировать код с исключениями. Хотелось бы
убедиться, что вызов \verb|(->fahr nil)| бросит ошибку, а не вернёт
\verb|nil|. Если проверки нет, код не защищён от подобных изменений:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; before
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
  \end{clojure}

\splitter

  \begin{clojure}
;; after
(defn ->fahr [cel]
  (when cel
    (+ (* cel 1.8) 32)))
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }


  \begin{clojure}
;; before
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
  \end{clojure}

&

  \begin{clojure}
;; after
(defn ->fahr [cel]
  (when cel
    (+ (* cel 1.8) 32)))
  \end{clojure}

\end{tabular}

\end{english}

\fi

\index{nil}

\noindent
В этом случае \verb|nil| провалится ниже по стеку вызовов, что усложнит поиск
причины.

Наивный способ~--- обернуть вызов в \verb|try| и добавить утверждение в~ветку
\verb|catch|:

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (try
    (->fahr nil)
    (catch Throwable e
      (is true))))
  \end{clojure}
\end{english}

Отчасти это решает проблему: в случае ошибки \verb|(is true)| действительно
сработает. Однако \verb|try| не имеет обратной проверки. Если исправить
\verb|(->fahr nil)| на \verb|(->fahr 1)|, исключения не будет и тело
\verb|(catch...)| не получит управление. Когда исключение ожидают, но его нет,
это \emph{тоже ошибка}.

\index{классы!NullPointerException}

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (try
    (->fahr nil)
    (catch NullPointerException e
      (is true))))
  \end{clojure}
\end{english}

Макрос \verb|(is (thrown?...))| лишён этих недостатков. Форма \verb|thrown?|
принимает класс исключения и произвольное тело. Если брошено исключение этого
класса (с учётом наследования), внешний \verb|is| сработает положительно:

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (thrown? NullPointerException
               (->fahr nil))))
  \end{clojure}
\end{english}

Когда исключения не было, получим ошибку в утверждении. Исправьте \verb|nil|
на число и убедитесь, что тест не проходит.

\index{NPE}

Иногда проверки на класс не хватает. В больших участках кода \verb|NPE|
возникает на разных уровнях. Предположим, кто-то изменил \verb|->fahr| так, что
для \verb|nil| получим \verb|nil| (колонка справа в таблице). Этим мы расширим
область ошибки: теперь \verb|NPE| возникнет не в \verb|->fahr|, а в~функции
сложения. Это приводит к~ложному тестированию: на самом деле происходит не то,
чего ожидают.

\begin{english}
  \begin{clojure}
(let [temp-cel nil]
  (+ 1 (->fahr temp-cel)))
  \end{clojure}
\end{english}

\label{illegal-arg}

Проблему решают двумя шагами. Первый~--- исправить функцию так, чтобы она
бросила что-то более осмысленное, чем \verb|NPE|. Подойдёт специальное
исключение \verb|IllegalArgumentException|. Его дополняют сообщением о том,
что именно не так:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (if (number? cel)
    (+ (* cel 1.8) 32)
    (throw (new IllegalArgumentException
             "Fahrenheit temperature
              must be a real number"))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (if (number? cel)
    (+ (* cel 1.8) 32)
    (throw (new IllegalArgumentException
            "Fahrenheit temperature must be a real number"))))
  \end{clojure}
\end{english}

\fi

Второй шаг~--- убедиться, что исключение пришло именно из \verb|->fahr|. Форма
\verb|(is (thrown-with-msg?...))| проверяет, что текст исключения совпадает с
регулярным выражением. Тест ниже покрывает эти требования: другое
\verb|IllegalArgumentException| не пройдёт проверку.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (thrown-with-msg?
       IllegalArgumentException
       #"Fahrenheit temperature"
       (->fahr nil))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (thrown-with-msg?
       IllegalArgumentException #"Fahrenheit temperature"
       (->fahr nil))))
  \end{clojure}
\end{english}

\fi

\subsection{Пакетная проверка}

Вспомним, как выглядит \verb|test-fahr|:

\begin{english}
  \begin{clojure}
(deftest test-fahr
  (is (= 68 (int (->fahr 20))))
  (is (= 212 (int (->fahr 100)))))
  \end{clojure}
\end{english}

Оба \verb|is| отличаются только числами. Чтобы добавить проверку, придётся
копировать одну из форм. Копирование раздувает код и в~целом выходит
боком. Очевидно, из похожих \verb|(is...)| можно выделить постоянную часть и
переписать тест.

\index{clojure.test!are}

Макрос \verb|are| (англ.~множественная форма is) выполняет несколько
\verb|is| по шаблону. Он принимает форму связывания, шаблон и аргументы. Число
аргументов должно быть кратно переменным из формы связывания. На каждом шаге
макрос связывает часть аргументов с~переменными и выполняет шаблон:

\begin{english}
  \begin{clojure}
(deftest test-fahr
  (are [c f] (= c (int (->fahr f)))
    68 20
    212 100))
  \end{clojure}
\end{english}

Аргументы записывают столбиком по принципу одна строка~--- один
\verb|is|. Выше \verb|f| и \verb|c| означают цифры по Фаренгейту и
Цельсию, то есть исходное и ожидаемое значения. Выражение \verb|(int (->fahr f))|
переехало в шаблон, поэтому нет смысла копировать его.

Макрос \verb|are| удобен для небольших выражений. Со временем он становится
трудным в поддержке. В этом случае тест переписывают на \verb|doseq|, который
пробегает по данным.

Предположим, мы тестируем API для создания пользователя. Один из тестов
проверяет входные параметры. Мы ожидаем негативный ответ для случаев, когда нет
обязательного поля или оно в неверном формате. В переменную \verb|params-ok|
запишем правильные параметры:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def params-ok {:name "John Smith"
                :email "john@test.com"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def params-ok {:name "John Smith" :email "john@test.com"})
  \end{clojure}
\end{english}

\fi

Для негативных случаев объявим вектор \verb|params-variations|. Он состоит из
пар \tuple{словарь, текст}. Словарь~--- это изменения, которые добавим к
\verb|params-ok| функцией \verb|merge|. Текст описывает проблему: неверная
почта, слишком длинное имя и так далее.

\begin{english}
  \begin{clojure}
(def params-variations
  [[{:name nil}      "Empty name"]
   [{:email "dunno"} "Wrong email"]
   [{:email nil}     "No email"]
   [{:something 42}  "Extra field"]])
  \end{clojure}
\end{english}

Тест пробегает по \verb|params-variations|. На каждом шаге он вызывает
\verb|api-create-user| с испорченными параметрами. Обратите внимание, что
вызов обёрнут в \verb|testing| с сообщением. Если на одном из шагов не
сработает \verb|is|, мы узнаем причину из отчёта.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-api-create-user-bad-params
  (testing "Sending bad parameters"
    (doseq [[params* description]
            params-variations]
      (testing description
        (let [params
              (merge params-ok params*)

              response
              (api-create-user params)
              
              {:keys [status]} response]
          (is (= 400 status)))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-api-create-user-bad-params
  (testing "Sending bad parameters"
    (doseq [[params* description] params-variations]
      (testing description
        (let [params (merge params-ok params*)
              response (api-create-user params)
              {:keys [status]} response]
          (is (= 400 status)))))))
  \end{clojure}
\end{english}

\fi

Тест разделяет данные и проверку, поэтому его легко поддерживать. Если в API
появятся новые поля, расширим \verb|params-variations|, не меняя тест.

\subsection{Именование}

Начинайте имя теста с префикса \verb|test-|. С точки зрения Clojure это
необязательно: фреймворк ищет тесты по метаданным, а не по имени. Выражения ниже
останутся функцией и тестом, даже если их назвали наоборот.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; function
(defn test-if-suspended [user])

;; test
(deftest is-suspended)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn test-if-suspended [user]) ;; function
(deftest is-suspended)          ;; test
  \end{clojure}
\end{english}

\fi

Префикс необходим для навигации по коду. В модуле бывает больше тестов, чем
умещается на экран. Вперемешку с тестами идут переменные и служебные функции. С
ростом модуля станет трудно понять, где функция, а где тест. С префиксом ошибки
быть не может.

\index{Emacs!навигация}
\index{навигация}

Emacs предлагает навигацию по коду командой \verb|imenu| и её улучшенной
версией \verb|helm-imenu|. При их вызове открывается буфер со списком
определений. С вводом текста останутся только те элементы, которые его
содержат. Называйте определения так, чтобы по команде \verb|M-x helm-imenu <RET> test|
в списке остались только тесты.

В общем случае тест называют по правилу \verb|test-<what>-<case>|, где
\verb|<what>| означает то, что мы тестируем, а \verb|<case>|~--- сценарий. Например,
\verb|test-create-user-ok| означает, что создают пользователя и~ожидают
успех. Имя \verb|test-create-user-bad-params| говорит о попытке создать
пользователя с неверными параметрами. Если пользователь не смог войти в систему,
потому что подпись устарела, тест называют
\verb|test-user-login-signature-expired|.

\subsection{Порядок аргументов}

\index{тесты!ожидаемое}

Необычный вопрос: как писать правильно, \verb|(is (= 200 status))| или
\verb|(is (= status 200))|? На первый взгляд это абсурд: неужели равенство
зависит от порядка? Значения либо равны, либо нет. Но макрос \verb|is|
сложнее, чем мы думаем: он разбивает форму \verb|(= 200 status)| на ожидаемую
и фактическую части. По-английски они называются expected и actual.

Ожидаемое значение~--- это то, которое посчитали заранее. Фактическое~--- то, на которое
тест вышел самостоятельно, вызвав функцию. Число 68~--- это ожидаемое, а
\verb|(int (->fahr 20))|~--- действительное. Статус 200~--- это ожидаемое, а
\verb|(:status response)|~--- действительное.

Разделение нужно для отчётов. Когда значения не равны, хотелось бы видеть, где
мы ошиблись. Предположим, в отчёте написано \verb|failed (= 200 403)|. Как это
понимать? Ожидали успешный ответ, но не хватило прав? Или это брешь в
безопасности~--- ожидали, что доступа к странице нет, но пользователь её увидел?
Если же написано <<expected 200, got 403>>, то ясно: это первый случай, когда
не хватило прав.

Правило: ожидаемое стоит на первом месте, а действительное~--- на~втором. Пишите
\verb|(is (= 200 status))| вместо \verb|(is (= status 200))|.
Это непривычно и противоречит здравому смыслу. Как правило, фактическое~---
это скаляр, а действительное~--- выражение, поэтому хочется записать их как слева.
Увы, придётся побороть себя и писать по образцу справа:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; wrong
(= (int (->fahr 20)) 68)
  \end{clojure}

\splitter

  \begin{clojure}
;; correct
(= 68 (int (->fahr 20)))
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
;; wrong
(= (int (->fahr 20)) 68)
  \end{clojure}

&

  \begin{clojure}
;; correct
(= 68 (int (->fahr 20)))
  \end{clojure}

\end{tabular}

\end{english}

\fi

\index{библиотеки!JUnit}

Правило уходит корнями в прошлое. Фреймворк JUnit утвердил именно такой порядок
\footurl{в~методах сравнения}{https://junit.org/junit5/docs/current/user-guide/}[JUnit].
Хорошо это или плохо, судить поздно~--- принцип <<expected слева>> стал
стандартом. Аналогично работают тесты в Python, Ruby и других языках. Отдельные
фреймворки предлагают модули, чтобы <<перестать говорить как Йода>>, то~есть
поменять семантику аргументов. Это возможно и в Clojure, но сейчас мы не будем
отклоняться от темы.

\index{CIDER}

Особенность expected и actual видна при запуске тестов в CIDER. Один и тот же
тест проверяет статус ответа на 200. Пока всё хорошо, нет разницы, в каком
порядке идут аргументы \verb|is|. В случае ошибки вариант слева вносит
путаницу. Согласно ему, нормальным считается статус 404 (expected), а не 200
(actual). Вариант справа выводит статусы правильно.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; wrong
(is (= (:status response)
       200))

Fail in test-...
expected: 404
  actual: 200
    diff: - 404
          + 200
  \end{clojure}

\splitter

  \begin{clojure}
;; correct
(is (= 200
       (:status response)))

Fail in test-...
expected: 200
  actual: 404
    diff: - 200
          + 404
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
;; wrong
(is (= (:status response)
       200))

Fail in test-...
expected: 404
  actual: 200
    diff: - 404
          + 200
  \end{clojure}

&

  \begin{clojure}
;; correct
(is (= 200
       (:status response)))

Fail in test-...
expected: 200
  actual: 404
    diff: - 200
          + 404
  \end{clojure}

\end{tabular}

\end{english}

\fi

\section{Фикстуры}

\index{фикстуры}

До сих пор мы работали с простыми тестами. Они запускаются в любой момент,
потому что не зависят от ресурсов. Так бывает не всегда: чем сложнее код, тем
больше требований к базе данных, файлам и сети. Всё вместе это называется
окружением теста.

Рассмотрим, как сообщить тесту его окружение. Для этого служат фикстуры. В
широком смысле термин означает стенд, на котором испытывают изделие. В
программировании фикстура~--- это функция, которая запускается до или после
теста. Фикстура готовит окружение и очищает его. Перечислим случаи, когда
полезны фикстуры.

\index{файлы!в фикстурах}

\textbf{Файлы на диске.} Код, который мы тестируем, ищет в заданной папке файл с
данными. Фикстура создаёт файл и удаляет его после теста. Подход гарантирует,
что на диске не останется следов после работы.

\textbf{Данные в базе.} Чтобы проверить авторизацию, в базу вносят пользователя
с известным паролем. Пригодятся и другие данные: профиль, друзья, история
заказов. Фикстура пишет данные в базу и в~конце очищает её, чтобы не повлиять на
следующий тест.

\textbf{Запуск и остановка системы.} Иногда фикстура управляет глобальным
состоянием программы. Например, для интеграционного теста нужны все компоненты
(сервер, база, почта). Запуск и остановку системы логично поместить в фикстуру.

По ходу главы мы рассмотрим и другие сценарии для фикстур. Пока что разберёмся,
как они устроены технически. Фикстура~--- это функция, которая принимает
тест. Функция выполняет любые действия, в~том числе вызывает тест. Вопрос, в
какой момент это делать, остаётся на ваше усмотрение.

\index{фикстуры!база данных}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def db {...}) ;; JDBC spec

(defn fix-db-data [t]
  ;; purge tables
  (jdbc/execute! db
    "truncate users cascade;")
  (jdbc/execute! db
    "truncate orders cascade;")
  ;; add data
  (jdbc/insert! db :users user-data)
  (jdbc/insert! db
    :profile profile-data)
  ;; execute the test
  (t))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def db {...}) ;; JDBC spec

(defn fix-db-data [t]
  ;; purge tables
  (jdbc/execute! db "truncate users cascade;")
  (jdbc/execute! db "truncate orders cascade;")
  ;; add data
  (jdbc/insert! db :users user-data)
  (jdbc/insert! db :profile profile-data)
  ;; execute the test
  (t))
  \end{clojure}
\end{english}

\fi

В примере мы сначала готовим окружение: чистим таблицы, вносим данные, затем
вызываем тест. Бывает и наоборот: тест нуждается в финальных
действиях. Предположим, мы пишем промежуточные файлы на диск. Чтобы очистить
папку при выходе из теста, напишем фикстуру:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(import 'java.io.File
        'org.apache.commons.io.FileUtils)

(defn clean-dir [path]
  (FileUtils/cleanDirectory
    (new File path)))

(defn fix-clear-files [t]
  (t)
  (clean-dir "/tmp/tests/data"))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(import 'java.io.File
        'org.apache.commons.io.FileUtils)

(defn clean-dir [path]
  (FileUtils/cleanDirectory (new File path)))

(defn fix-clear-files [t]
  (t)
  (clean-dir "/tmp/tests/data"))
  \end{clojure}
\end{english}

\fi

Иногда фикстура сообщает и предварительные, и финальные шаги. В этом случае
\verb|(t)| находится где-то посередине.

Надеемся, читатель заметил, что имена фикстур начинаются с~префикса
\verb|fix-|. Для фикстур действует то же правило именования, что и для
тестов. Это особые сущности, поэтому их выделяют префиксом.

\subsection{Регистрация}

\index{фикстуры!регистрация}

Если запустить тест сейчас, фикстура не сработает. Мы только объявили фикстуру,
но не сказали фреймворку взять её в работу. Это делают регистрацией фикстуры.
Резонный вопрос: если фреймворк сам находит тесты, почему бы ему не искать и
фикстуры?

Причина в том, что фикстуры работают на разных этапах теста. Clojure выделяет
стадии \verb|:each| и \verb|:once|. Зарегистрировать фикстуру значит связать
её с одним из этих ключей. Значение \verb|:each| означает, что фикстура
работает для каждого теста из модуля. С ключом \verb|:once| фикстура
выполняется однажды в рамках пространства.

\index{фикстуры!:once}
\index{фикстуры!:each}

Одна и та же фикстура может быть \verb|:each| или \verb|:once|. Вспомним
фикстуру \verb|fix-clear-files|, которая очищает папку. Если у файлов случайные
имена, логично удалить их один раз в конце, и фикстуре указывают
\verb|:once|. Если имена одинаковы, возрастает риск коллизии (чтение и запись из
другого теста). Тогда фикстуру связывают с~ключом \verb|:each|.

Другой пример~--- фикстура базы данных. На время теста она пишет данные в
таблицы и очищает их. Если тесты только читают данные, укажем
\verb|:once|. Получим выигрыш в скорости: для тридцати тестов фикстура
сработает один раз. Для тестов на запись важно, чтобы ни один из них не влиял на
другой, поэтому фикстуру добавляют с \verb|:each|.

Функция \verb|use-fixtures| из \verb|clojure.test| принимает ключ и любое
число фикстур:

\index{clojure.test!use-fixtures}

\begin{english}
  \begin{clojure}
(use-fixtures :once
  fix-db-server fix-clear-files)

(use-fixtures :each fix-db-data)
  \end{clojure}
\end{english}

Выражения ставят в верхней части файла до тестов. Они могут быть и в конце, но
чем раньше мы увидим типы фикстур, тем лучше.

\subsection{Пример}

Чтобы исследовать порядок фикстур, добавим в них побочный эффект. Функция
\verb|fix-factory| принимает тип фикстуры, её номер и возвращает
фикстуру. Логика фикстуры в том, чтобы напечатать номер до и после теста.

\index{фикстуры!порядок}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-factory [type number]
  (fn [t]
    (println (format "%s %s starts"
               type number))
    (t)
    (println (format "%s %s ends"
               type number))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-factory [type number]
  (fn [t]
    (println (format "%s %s starts" type number))
    (t)
    (println (format "%s %s ends" type number))))
  \end{clojure}
\end{english}

\fi

\noindent
Добавим по две фикстуры каждого типа:

\begin{english}
  \begin{clojure}
(use-fixtures :once
  (fix-factory :once 1)
  (fix-factory :once 2))

(use-fixtures :each
  (fix-factory :each 3)
  (fix-factory :each 4))
  \end{clojure}
\end{english}

Если запустить тесты, увидим следующее. Фикстуры 1 и 2 с типом \verb|:once|
сработали однажды на границах. Обратите внимание, что в~конце их порядок
противоположный: сначала завершается фикстура 2, и~только потом~--- 1. Фикстуры 3 и 4
оборачивают каждый тест. Чтобы выразить процесс нагляднее, добавим отступы. С
ними видна иерархия фикстур.

\index{отступы}

\begin{english}
  \begin{clojure}
:once 1 starts
  :once 2 starts
    :each 3 starts
      :each 4 starts
        test 1
      :each 4 ends
    :each 3 ends
    :each 3 starts
      :each 4 starts
        test 2
      :each 4 ends
    :each 3 ends
  :once 2 ends
:once 1 ends
  \end{clojure}
\end{english}

\subsection{Хранение фикстур}

Пытливому читателю будет полезно узнать, где лежит информация о~фикстурах. Очевидно,
вызов \verb|use-fixtures| меняет глобальное состояние. Это не атом и не
переменная, а нечто другое, с чем мы ещё не работали,~--- метаданные
пространства. После регистрации фикстур проверьте его ключи:

\index{метаданные!в фикстурах}
\index{метаданные!в тестах}
\index{метаданные!в пространствах}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(keys (meta *ns*))
(:clojure.test/each-fixtures
 :clojure.test/once-fixtures)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(keys (meta *ns*))
(:clojure.test/each-fixtures :clojure.test/once-fixtures)
  \end{clojure}
\end{english}

\fi

В каждом из них список функций, которые передали в \verb|use-fixtures| с
\verb|:each| или \verb|:once|. Вызов \verb|use-fixtures| заменяет в метаданных
все фикстуры этого типа. Важно, что это полная замена, а не запись
в~конец. Чтобы отказаться от всех фикстур \verb|:each|, выполните:

\begin{english}
  \begin{clojure}
(use-fixtures :each)
  \end{clojure}
\end{english}

Другой способ очистить фикстуры~--- удалить форму \verb|use-fixtures| в коде и
выполнить буфер в REPL. Тогда объявление \verb|(ns...)| сработает ещё раз с
новыми метаданными.

В других языках и фреймворках выделяют ещё одну стадию фикстур~---
\verb|:session|. Такая фикстура запускается в разрезе \emph{всего прогона}
тестов. Можно сказать, это фикстура-синглтон: даже для нескольких модулей она
сработает один раз. В \verb|clojure.test| нет такой стадии. С ней пространства
были бы связаны друг с другом, что нарушает идею фреймворка. Начинающим не
хватает \verb|session|-фикстур, но мы научимся обходиться без них.

\subsection{Связанные переменные}

\index{clojure.core!binding}
\index{фикстуры!с binding}

Фикстуры особенно удобны в паре с динамическими переменными. Напомним:
динамические переменные~--- это формы \verb|def| с тегом \verb|^:dynamic| и
<<ушками>>. Макрос \verb|binding| выполняет код с новым
значением переменной. Мы рассмотрели их в главе про
изменяемость \page{dynamic-vars}.

Форма \verb|deftest| порождает функцию без аргументов. Нельзя сообщить тесту его
параметры, как обычной функции. А ведь тесту нужны файлы, база данных и многое
другое. Окружение передают в два шага. Первый~--- тест ссылается на глобальную
переменную. Второй~--- пишут фикстуру, которая оборачивает тест в \verb|binding|
с этой переменной и~нужным значением.

Предположим, мы тестируем функцию, которая принимает путь к файлу и пишет в него
картинку. Объявим фикстуру, которая на время теста свяжет переменную
\verb|*tmp-file*| со временным файлом, экземпляром \verb|java.util.File|. При
выходе из теста удалим файл, а~переменная вернётся в \verb|nil|.

\index{классы!File}
\index{файлы!временные}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(import 'java.io.File)

(defonce ^:dynamic *tmp-file* nil)

(defn fix-with-tmp-file [t]
  (let [^File tmp-file
        (File/createTempFile
          "test" "img.png")]
    (binding [*tmp-file* tmp-file]
      (t))
    (.delete tmp-file)))

(use-fixture :each fix-with-tmp-file)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(import 'java.io.File)

(defonce ^:dynamic *tmp-file* nil)

(defn fix-with-tmp-file [t]
  (let [^File tmp-file (File/createTempFile "test" "img.png")]
    (binding [*tmp-file* tmp-file]
      (t))
    (.delete tmp-file)))

(use-fixture :each fix-with-tmp-file)
  \end{clojure}
\end{english}

\fi

Частичка \verb|with| в имени фикстуры намекает на контекст. Добавляйте её,
когда фикстура обращается к \verb|binding|, \verb|with-redefs| или аналогам.

\index{форматы!PNG}
\index{изображения}
\index{классы!PngImage}

Внутри теста мы вызываем \verb|plot-chart| с некоторым набором данных и текущим
временным файлом.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines*}{firstnumber=1}
(import 'javax.imageio.ImageIO)

(deftest test-plot-chart-png
 (let [dataset [[...] [...] [...]]
       filepath (.getAbsolutePath
                          *tmp-file*)]
   (plot-chart dataset filepath)))
  \end{clojure/lines*}
\end{english}

\else

\begin{english}
  \begin{clojure/lines*}{firstnumber=1}
(import 'javax.imageio.ImageIO)

(deftest test-plot-chart-png
  (let [dataset [[...] [...] [...]]
        filepath (.getAbsolutePath *tmp-file*)]
    (plot-chart dataset filepath)))
  \end{clojure/lines*}
\end{english}

\fi

\wavebottom

\noindent
Убедимся, что функция действительно записала в него картинку. Класс
\verb|PngImage| предлагает простейший парсер PNG. Прочитаем разрешение файла и
сверим с образцом.

\wavetop

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines*}{firstnumber=8}
(let [png (ImageIO/read *tmp-file*)
      width (.getWidth png)
      height (.getHeight png)])
(is (= [640 480] [width height]))))
  \end{clojure/lines*}
\end{english}

\else

\begin{english}
  \begin{clojure/lines*}{firstnumber=7}
    (let [png (ImageIO/read *tmp-file*)
          width (.getWidth png)
          height (.getHeight png)])
    (is (= [640 480] [width height]))))
  \end{clojure/lines*}
\end{english}
\fi


\index{базы данных!Cassandra}
\index{фикстуры!база данных}

Для полноты картины рассмотрим базу данных. Пусть это будет Cassandra, а не
JDBC-драйвер. Фикстура \verb|fix-with-db| связывает \verb|*db*| с текущей
сессией. Установка сессии~--- это дорогая операция, поэтому вынесем её в разовую
фикстуру.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[qbits.alia :as alia])

(defonce ^:dynamic *db* nil)

(defn fix-with-db [t]
  (let [cluster (alia/cluster
                  {:contact-points
                   ["localhost"]})
        session (alia/connect cluster)]
    (binding [*db* session]
      (t))
    (.close session)
    (.close cluster)))

(use-fixture :once fix-with-db)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[qbits.alia :as alia])

(defonce ^:dynamic *db* nil)

(defn fix-with-db [t]
  (let [cluster (alia/cluster {:contact-points ["localhost"]})
        session (alia/connect cluster)]
    (binding [*db* session]
      (t))
    (.close session)
    (.close cluster)))

(use-fixture :once fix-with-db)
  \end{clojure}
\end{english}

\fi

Вторая фикстура готовит данные для каждого теста. Фикстуры \verb|:once|
запускаются раньше, чем \verb|:each|. Подготовка данных сработает внутри
\verb|(binding [*db* ...])| из первой фикстуры. Это значит, внутри второй мы
свободно обращаемся к \verb|*db*| как к сессии:

\index{SQL!TRUNCATE}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-db-prepare-data [t]
  (alia/execute! *db*
    "truncate project.users;")
  (alia/execute! *db*
    "truncate project.orders;")
  (alia/execute! *db*
    "insert into project.users...")
  (t))

(use-fixture :each fix-db-prepare-data)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-db-prepare-data [t]
  (alia/execute! *db* "truncate project.users;")
  (alia/execute! *db* "truncate project.orders;")
  (alia/execute! *db* "insert into project.users...")
  (t))

(use-fixture :each fix-db-prepare-data)
  \end{clojure}
\end{english}

\fi

\subsection{Мультификстуры}

\label{multi-fixture}

\index{фикстуры!множественные}

Любопытный вопрос: что произойдёт, если фикстура вызовет тест несколько раз?
Напишем такую фикстуру:

\begin{english}
  \begin{clojure}
(defn fix-multi [t]
  (t) (t) (t))

(use-fixtures :each fix-multi)
  \end{clojure}
\end{english}

\noindent
и запустим один тест. С точки зрения фреймворка прошло три теста, о чём скажет
отчёт:

\ifx\devicetype\mobile

\begin{english}
  \begin{text}
Ran 6 assertions, in 3 test functions.
0 failures, 0 errors.
  \end{text}
\end{english}

\else

\begin{english}
  \begin{text}
book.util-test: Ran 6 assertions, in 3 test functions.
0 failures, 0 errors.
  \end{text}
\end{english}

\fi

На первый взгляд, в этом нет смысла. Множественный прогон не несёт пользы, а
только потребляет ресурсы и время. Но с динамическими переменными такая фикстура
неожиданно полезна. Один и тот же тест можно выполнить в разных окружениях.

Предположим, программа работает с базой данных. В требованиях сказано, что это
может быть PostgreSQL или MySQL. Убедимся, что программа поддерживает обе
СУБД. Чтобы не дублировать тесты под каждый тип базы, логику повтора выносят в
фикстуру. Объявим подключения к базам данных:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def db-pg
  {:dbtype "postgresql" :host "..."})
(def db-mysql
  {:dbtype "mysql"      :host "..."})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def db-pg    {:dbtype "postgresql" :host "..."})
(def db-mysql {:dbtype "mysql"      :host "..."})
  \end{clojure}
\end{english}

\fi

Добавим динамическую переменную \verb|*db*|. Новая фикстура перебирает
подключения и связывает их с \verb|*db*| на каждом шаге. Когда переменная
связана, запускается тест. Он зависит от текущего подключения и поэтому
обращается либо в PostgreSQL, либо в MySQL.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *db* nil)

(defn fix-with-multi-db-backend [t]
  (doseq [db [db-pg db-mysql]]
    (binding [*db* db]
      (testing
        (format "Testing with DB %s"
          (:dbtype *db*))
        (t)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *db* nil)

(defn fix-with-multi-db-backend [t]
  (doseq [db [db-pg db-mysql]]
    (binding [*db* db]
      (testing (format "Testing with DB %s" (:dbtype *db*))
        (t)))))
  \end{clojure}
\end{english}

\fi

Вызов \verb|(t)| обёрнут в форму \verb|testing|, которая сообщает тип
базы. Если произошла ошибка, мы узнаем, с какой базой работали в тот
момент. Тест на чтение пользователя:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn test-get-user-by-id
  (let [user
        (project.orm/get-user *db* 1)]
    (is (= {:name "Ivan"} user))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn test-get-user-by-id
  (let [user (project.orm/get-user *db* 1)]
    (is (= {:name "Ivan"} user))))
  \end{clojure}
\end{english}

\fi

Перечислим другие сценарии для мультификстур. Это могут быть интеграционные
тесты в нескольких браузерах (Chrome, Firefox). Иногда нужно проверить, что
логика не зависит от формата передачи данных (JSON, Msgpack). Если программа
работает с изображениями, тесты прогоняют на разных типах файлов (PNG, JPEG) и
разрешениях.

\subsection{This is fine}

Для полноты картины учтём и обратный случай: что случится, если фикстура
\emph{не вызывает} тест?

\index{фикстуры!с подавлением}

\begin{english}
  \begin{clojure}
(defn fix-mute [t])
(use-fixtures :each fix-mute)
  \end{clojure}
\end{english}

Это приведёт к тому, что ни один тест не сработает. Фикстура не отменяет тесты:
фреймворк по-прежнему находит и выполняет их. В отчёте увидим список тестов,
но для каждого будет указано <<0~assertions>>. Если запустить тест из Emacs,
получим предупреждение:

\begin{english}
  \begin{clojure}
No assertions (or no tests) were run.
Did you forget to use ‘is’ in your tests?
  \end{clojure}
\end{english}

\index{CIDER}

CIDER считает подозрительным, что не было ни одного \verb|is|. Чтобы обмануть
CIDER, улучшим фикстуру. Добавим в неё \verb|is|, который всегда истинен. Даже
если в тесте ошибки, его тело не выполнится, а в отчёте будет один
assertion. Назовём фикстуру \footurl{\texttt{fix-this-is-fine}}{https://knowyourmeme.com/memes/this-is-fine}[This\\*is fine][-11mm]:

\begin{english}
  \begin{clojure}
(defn fix-this-is-fine [t]
  (is true))

(use-fixtures :each fix-this-is-fine)
  \end{clojure}
\end{english}

\index{люди!Джордж Оруэлл}

С её помощью мы пройдём тест Оруэлла:

\begin{english}
  \begin{clojure}
(deftest test-1984
  (testing "Sometimes they are five."
    (is (= 5 (* 2 2)) )))
;; OK, ran 1 assertions
  \end{clojure}
\end{english}

По аналогии напишите фикстуру, которая портит любой тест. Добейтесь, чтобы все
тесты завершились с ошибкой.

\subsection{Фикстуры с условиями}

\index{фикстуры!с условием}

Фикстура не только вызывает тест, но и несёт дополнительную логику. Тест может
быть обёрнут в цикл, условие или другую форму. Разберёмся с условием. В
каких случаях тест ставят под \verb|if| и какой в этом смысл?

К условной фикстуре прибегают, когда мы не знаем заранее, сможем ли выполнить
тест. Например, часть программы работает только с~базой данных
PostgreSQL. Фикстура проверяет тип подключения и~не вызывает тест, если он
заведомо не работает.

\begin{english}
  \begin{clojure}
(defn fix-pg-only [t]
  (when (= (:dbtype *db*) "postgresql")
    (t)))
  \end{clojure}
\end{english}

Фикстура молча пропускает тесты, которые не поддерживает. Если нужен сигнал об
ошибке, добавьте ложное утверждение. Обратите внимание на второй параметр
\verb|is|. Это сообщение, которое появится в отчёте для этого утверждения.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-pg-only [t]
  (let [{:keys [dbtype]} *db*]
    (if (= dbtype "postgresql")
      (t)
      (is false
        (str "Unsupported DB "
          dbtype)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-pg-only [t]
  (let [{:keys [dbtype]} *db*]
    (if (= dbtype "postgresql")
      (t)
      (is false (str "Unsupported DB " dbtype)))))
  \end{clojure}
\end{english}

\fi

Каким способом зарегистрировать фикстуру~--- \verb|:once| или \verb|:each|?
Это зависит от семантики условия. В нашем примере база не меняется от теста к
тесту, поэтому условие может быть выполнено однажды. Если фикстура проверяет
файл на диске, проверку делают для каждого теста.

Рассмотрим другие сценарии, когда фикстурам нужны условия. Это версия
операционной системы: если она ниже порога, мы не можем выполнить тест. Иногда
приложение зависит от системной утилиты, которую вызывает в отдельном
процессе. Фикстура проверяет, что утилита установлена. Когда тест работает с
большими файлами, может не хватить места на сервере CI. Перед запуском фикстура
убеждается, что места хватит.

\section{Метки и селекторы}

\index{селекторы!в тестах}

Фикстуры с условиями похожи на фильтры. С их помощью запускают не все тесты, а
часть, которая подходит окружению. Избегайте ситуаций, когда в фикстурах слишком
много условий. Clojure предлагает более удобный способ выборочного
прогона. Это метки и селекторы тестов.

Метки работают проще, чем фикстуры с условием. Это метаданные, которые сообщают
тесту при его создании. Тесту ниже назначили флаг \verb|:special| со значением
\verb|true|.

\begin{english}
  \begin{clojure}
(deftest ^:special test-special-case
  (is true))
  \end{clojure}
\end{english}

\index{синтаксис!\texttt{\^} (метаданные)}
\index{метаданные}

Напомним: выражение \verb|^:flag|~--- это сокращение от \verb|^{:flag true}|.
<<Крышка>> полезна, чтобы задать несколько флагов за один раз:

\begin{english}
  \begin{clojure}
(deftest ^:special ^:backend ^:no-db
  test-special-case
  (let [...]
    (is ...)))
  \end{clojure}
\end{english}

\noindent
Когда тегов два и больше, имя теста переносят на следующую строку, чтобы
визуально отделить от тегов.

По тегам легко догадаться, что это тест на серверную логику (\verb|backend|);
ему не нужна база данных (\verb|no-db|); это особый тест (\verb|special|). Смысл
тегов зависит от соглашений в команде. Чтобы проверить флаги, прочитаем
метаданные переменной \verb|test-special-case|. Среди прочих полей вы найдёте
\verb|:special| и остальные:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(meta #'test-special-case)
{:special true
 :backend true
 :no-db true ...}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(meta #'test-special-case)
{:special true :backend true :no-db true ...}
  \end{clojure}
\end{english}

\fi

По тегам можно выбрать часть тестов: только особые (\verb|special|) или на
серверную логику (\verb|backend|). Выборка называется селектором
тестов. Селекторы полезны по нескольким причинам.

Часть тестов отработает быстрее, чем полный набор. Если мы правим участок кода
и точно знаем, какие тесты он задевает, нет смысла запускать всё
подряд. Назначим тег и будем работать с подмножеством.

Иногда окружение не настроено должным образом, и выполнить все тесты
невозможно. Например, интеграционный тест требует браузер и~драйвер к нему,
очередь задач и почтовый сервер. Такие тесты выносят в отдельный шаг сборочной
линии. В общих чертах схема выглядит так:

\begin{itemize}

\item
  запустить минимальное окружение (база данных);

\item
  выполнить модульные тесты;

\item
  если не было ошибок, поднять дополнительное окружение (очередь задач,
  заглушки);

\item
  выполнить интеграционные тесты.

\end{itemize}

\noindent
Чем сложнее проект, тем больше в нём тестов и шагов по их запуску.

В тестовом фреймворке Clojure нет селекторов. Он запускает один тест,
пространство или всё целиком. Селекторы идут в сторонних библиотеках и
утилитах. Рассмотрим, как задать их в Leiningen.

Откройте файл \verb|project.clj|. Внутри \verb|defproject| добавьте ключ
\verb|:test-selectors|. Это словарь, где ключ~--- это метка селектора, а
значение~--- функция одного аргумента. В функцию приходят метаданные теста. Если
функция вернула ложь или \verb|nil|, тест пропускают.

Поскольку кейворд в Clojure~--- это функция, селектором может быть сам тег. Пример
ниже читается как <<набор тестов \verb|:special|, у которых тег \verb|:special|>>:

\begin{english}
  \begin{clojure}
:test-selectors {:special :special
                 :backend :backend}
  \end{clojure}
\end{english}

\noindent
Чтобы запустить тесты по селектору, передайте метку в команду \verb|test|:

\begin{english}
  \begin{bash}
$ lein test :special
  \end{bash}
\end{english}

\index{селекторы!:default}

Если метка не задана, фреймворк назначит ей \verb|:default|. Под этот селектор
подходит любой тест. Хитрость в том, что поведение \verb|:default| можно
изменить. Ниже ему задали селектор, который вернёт все
\textbf{не}~интеграционные тесты. В результате \verb|lein test| запустит только
модульные тесты. Чтобы прогнать весь проект, мы завели метку \verb|:all|,
которая вернёт истину для любого теста.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:test-selectors
  {:default (complement :integration)
   :integration :integration
   :all (constantly true)}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:test-selectors {:default (complement :integration)
                 :integration :integration
                 :all (constantly true)}
  \end{clojure}
\end{english}

\fi

Селектор может быть полноценной функцией. Предположим, часть программы
полагается на новые функции базы данных. Для каждого теста укажем минимальную
версию базы, поле \verb|:db/version| с числом. Тест считают экспериментальным,
если версия базы выше 11:

\begin{english}
  \begin{clojure}
(deftest ^{:db/version 11}
  test-db-experimental-feature
  (is true))
  \end{clojure}
\end{english}

\noindent
Ниже селектор, который вернёт подобные тесты. Запустите их командой
\verb|lein test :db-experimental|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:test-selectors
  {:db-experimental
   (fn [test-meta]
     (some-> test-meta
             :db/version
             (>= 11)))}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:test-selectors {:db-experimental
                 (fn [test-meta]
                   (some-> test-meta :db/version (>= 11)))}
  \end{clojure}
\end{english}

\fi

Можно выбрать тесты по частичному совпадению пространства и~имени. По умолчанию
\verb|lein| не предлагает \verb|regex|-селекторов: команда \verb|test| запускает
конкретный тест, пространство или всё целиком. Это легко исправить селектором:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:test-selectors
  {:test-api
   (fn [m]
     (->> m :name name
          (re-find #"^test-api")))}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:test-selectors {:test-api
                 (fn [m] (->> m :name name
                              (re-find #"^test-api")))}
  \end{clojure}
\end{english}

\fi

Он вернёт все тесты, чьи имена начинаются с \verb|test-api|. Имя переменной~--- это
символ, поэтому приводим его к строке. Заметим, что имя не содержит
пространство; последнее находится в поле \verb|:ns| и~представляет собой не
символ, а объект \verb|Namespace|. Добраться до его имени поможет функция
\verb|ns-name|. Поиск по пространству выглядит так:

\index{clojure.core!ns-name}
\index{классы!Namespace}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:test-selectors
  {:test-ns-api
   (fn [m]
     (->> m :ns ns-name name
          (re-find #"^project.api")))}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:test-selectors {:test-ns-api
                 (fn [m] (->> m :ns ns-name name
                              (re-find #"^project.api")))}
  \end{clojure}
\end{english}

\fi

Новый селектор ищет только те тесты, чьи пространства начинаются
с~\verb|project.api|. В него попадут условные \verb|project.api.user|,
\verb|project.api.oreders| и другие.

Когда тестов много, расставлять теги утомительно. Повышается риск забыть тег, и
тест выпадет из набора. Если все тесты модуля связаны по смыслу, тег назначают
не тесту, а пространству. С точки зрения \verb|lein| тест наследует теги
пространства, в котором объявлен:

\begin{english}
  \begin{clojure}
(ns ^:integration
  book.integration-test
  (:require [clojure.test :refer :all]))

(deftest test-user-login-ok
  ...)
  \end{clojure}
\end{english}

Не нужно указывать \verb|^:integration| каждому тесту, поскольку мы сделали
это на уровне модуля. Селектор интеграционных тестов не изменится: его метка и
функция равны \verb|:integration|. Тесты запускаются как обычно:

\begin{english}
  \begin{bash}
$ lein test :integration
  \end{bash}
\end{english}

\subsection{Тесты в Deps}

\index{тесты!deps.edn}
\index{утилиты!Deps}

Не все проекты на Clojure используют Lein; некоторые перешли
на~\footurl{Deps}{https://clojure.org/guides/deps\_and\_cli}[Deps][-3mm], утилиту для
управления зависимостями. С версии 1.9 Deps идёт в поставке Clojure.

\index{библиотеки!Test-runner}

Если проект работает на Deps, мы теряем возможности Lein, в том числе прогон
тестов. Чтобы компенсировать потери, в Deps подключают сторонние
библиотеки. Проект \footurl{Test-runner}{https://github.com/cognitect-labs/test-runner}[Test runner][4mm]
делает то же, что и~\verb|lein test|: находит тесты, запускает их и выводит
отчёт.

Добавьте в файл \verb|deps.edn| запись:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:aliases
{:test
 {:extra-paths ["test"]
  :extra-deps
  {com.cognitect/test-runner
   {:git/url
    "https://github.com/
         cognitect-labs/test-runner.git"
    :sha "209b64...."}}
  :main-opts
  ["-m" "cognitect.test-runner"]}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:aliases
{:test
 {:extra-paths ["test"]
  :extra-deps
  {com.cognitect/test-runner
   {:git/url "https://github.com/cognitect-labs/test-runner.git"
    :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
  :main-opts ["-m" "cognitect.test-runner"]}}
  \end{clojure}
\end{english}

\fi

\index{алиас}
\index{прoфили!deps}

Ключ \verb|:aliases|~--- это то же самое, что профили в \verb|lein|: опции, которые
включаются, если указан профиль. В ключе \verb|:extra-paths| список путей для
поиска файлов с кодом. Поле \verb|:extra-deps| указывает зависимости
в~дополнение к основным. Test-runner нужен только для тестов, поэтому он не
должен быть в глобальных зависимостях.

Библиотека загружается с GitHub; поле \verb|:sha| означает коммит или
тег. Коренное отличие Deps от Lein том, что репозиторием может быть GitHub. Ключ
\verb|:main-opts| задаёт входную точку программы. Это функция \verb|-main|
из модуля \verb|cognitect.test-runner|.

Библиотека предлагает ключи для выборки тестов с логикой <<только с этим тегом>>
(\verb|-i|,~англ.~include~--- <<включить>>) или <<без этого тега>>
(\verb|-e|,~англ.~exclude~--- <<исключить>>). Команда ниже выполнит все тесты кроме
интеграционных:

\begin{english}
  \begin{bash}
clj -Atest -e :integration
  \end{bash}
\end{english}

Селекторы в \verb|test-runner| могут быть только ключами. Произвольные функции
вроде \verb|defn| и \verb|fn| не поддерживаются. Test-runner ищет пространства
по регулярному выражению (ключ \verb|-r|, namespace-regex). С~ним можно выбрать
тесты по доменной структуре, например все дочерние модули \verb|project.api|.

\section{Проблема окружения}

\index{окружение}

До сих пор мы писали примитивные тесты, которые проверяют числа. На практике вы
столкнетесь с проблемой: в коде преобладают не вычисления, а ввод-вывод
данных. Это обращение к сторонним ресурсам: базе данных, очереди задач, HTTP
API. Такой код трудно тестировать по двум причинам.

\index{организации!Amazon}
\index{S3}

Во-первых, настроить локальное окружение стоит усилий, а иногда это
невозможно. Представим, что приложение загружает файлы в Amazon S3. Только недавно
появились проекты, которые имитируют S3 на локальной машине. Ни одна заглушка не
гарантирует точного совпадения заголовков, сообщений об ошибке и так далее. У
вас может не быть ключей и сертификатов доступа. Если открыть их всем
разработчикам, инфраструктура фирмы будет под угрозой.

Во-вторых, тесты плохо работают с данными, которые не контролируют. Если ответ
сервиса изменится, получим сломанный билд. Чтобы тест не зависел от окружения,
применяют \emph{моки} и \emph{стабы}. Разберёмся, что это такое и в чём плюсы и
минусы каждого.

\subsection{Моки}

\label{test-isolation}

\index{моки}

Мок (англ.~mock~--- <<ложный, фиктивный>>)~--- это объект, который временно
заменяет другой объект. При обращении к объекту сработает не исходный код, а
указанный. Часто моки накладывают на функции с выходом в сеть. С их помощью
проверяют, как поведёт себя код в разных ситуациях: данные получены, статус 403,
соединение не удалось.

\label{mobile-app-intro}

\index{веб-разработка}

Представим мобильное приложение для отдыха. На главном экране карта, на которую
нанесены кафе, рестораны и ближайшие события: фильмы, выставки,
фестивали. Данные приходят с сервера по протоколу HTTP в JSON. Функция
\verb|view-main-page| принимает запрос с~координатами устройства, собирает
сведения о местах и событиях и~отсылает результат:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn view-main-page [request]
  (let [location
        (-> request
            :params
            (select-keys [:lat :lon]))
        sites
        (get-sites-by-location location)
        events
        (get-events-by-location
          location)]
    {:status 200
     :body {:sites sites
            :events events}}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn view-main-page [request]
  (let [location (-> request :params (select-keys [:lat :lon]))
        sites (get-sites-by-location location)
        events (get-events-by-location location)]
    {:status 200
     :body {:sites sites :events events}}))
  \end{clojure}
\end{english}

\fi

Данные о местах и событиях приходят из условных сервисов Яндекс.Карт
и~Афиши. Функции \verb|get-sites|\textbf{...} и \verb|get-events|\textbf{...}
общаются с ними по HTTP. Так выглядит функция \verb|get-sites-by-location| для
поиска кафе и ресторанов в радиусе 300 метров:

\index{HTTP!API}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns book.views
  (:require
   [clj-http.client :as client]))

(defn get-sites-by-location
  [{:keys [lat lon]}]
  (-> {:method :get
       :url
       "https://maps.yandex.ru/search/v1"
       :as :json
       :query-params
       {:apikey "....."
        :lat lat :lon lon :distance 300
        :type "cafe,restaurant"}}
      client/request
      :body))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns book.views
  (:require [clj-http.client :as client]))

(defn get-sites-by-location
  [{:keys [lat lon]}]
  (-> {:method :get
       :url "https://maps.yandex.ru/search/v1"
       :as :json
       :query-params {:apikey "....."
                      :lat lat :lon lon :distance 300
                      :type "cafe,restaurant"}}
      client/request
      :body))
  \end{clojure}
\end{english}

\fi

Функция \verb|get-events-by-location| для событий аналогична первой. Разница в
адресе (не \verb|maps.yandex.ru|, a \verb|events.afisha.ru|) и параметрах
запроса.

Очевидно, \verb|view-main-page| обращается в сеть дважды, что затрудняет
тестирование. Понадобится два API-ключа; если запускать тесты часто, мы
исчерпаем квоты на число запросов. Настоящие данные меняются и поэтому не
подходят для тестов: завтра откроется новое кафе или закроется старое. Решим
проблему моками.

\index{clojure.core!with-redefs}

В главе про изменяемость мы работали с \verb|with-redefs| \page{with-redefs}.
Макрос заменяет переменную по её пути на что-то другое. Простейший мок подменяет
функцию с обращением в сеть на функцию с известным результатом.

Напишем тест главного экрана с двумя моками. Их данные вынесем в переменные в
\verb|let|. Функцию \verb|view-main-page| вызываем  внутри
\verb|with-redefs|, иначе эффект моков теряется.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-main-page
  (let [sites [{:name "Cafe1"}
               {:name "Cafe2"}]
        events [{:name "Event1"}
                {:name "Event2"}]]
    (with-redefs
      [book.views/get-sites-by-location
       (constantly sites)
       book.views/get-events-by-location
       (constantly events)]
      (let [request
            {:params {:lat 55.751244
                      :lon 37.618423}}
            result
            (view-main-page request)]
        (is (= {:sites sites
               :events events}
               (:body result)))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-main-page
  (let [sites [{:name "Cafe1"} {:name "Cafe2"}]
        events [{:name "Event1"} {:name "Event2"}]]
    (with-redefs
      [book.views/get-sites-by-location (constantly sites)
       book.views/get-events-by-location (constantly events)]
      (let [request {:params {:lat 55.751244
                              :lon 37.618423}}
            result (view-main-page request)]
        (is (= {:sites sites :events events}
               (:body result)))))))
  \end{clojure}
\end{english}

\fi

Мы избежали похода в сеть: тест не зависит от ключей, прав доступа и новых
заведений. Запустите его в любое время, и результат не изменится. Теперь
рассмотрим, как улучшить тест.

\subsection{Вынести данные в файл}

Переменные \verb|sites| и \verb|events|, которые якобы пришли из сторонних
сервисов, крайне скудны. Сообщите им данные из реального источника~--- скажем,
десять ресторанов и семь мероприятий. Чтобы не засорять код огромными словарями,
поместите ответы в \verb|.json|-файлы в папку ресурсов. Считайте их в переменную
модуля:

\index{файлы!для моков}

\begin{english}
  \begin{clojure}
(def data-events
  (-> "data/events.json"
      clojure.java.io/resource
      slurp
      (json/parse-string true)))
  \end{clojure}
\end{english}

На практике функция \verb|get-sites-by-location| сложнее, чем в
примере. Заведения фильтруют согласно внутренней логике. Например, исключают
кафе с низкой оценкой и те, что сейчас закрыты. Это порождает отдельный тест:
добавьте в файл кафе с низкой оценкой и~убедитесь, что его нет в ответе.

\subsection{Мок в фикстуре}

\index{фикстуры!для моков}

Если тестов несколько, оборачивать каждый в \verb|with-redefs|
утомительно. Поместим мок в фикстуру. Так мы снизим повторы в коде, и~ей~смогут
пользоваться другие тесты.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-mock-sites-events [t]
  (with-redefs [...]
    (t)))

(use-fixtures :each
  fix-mock-sites-events)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-mock-sites-events [t]
  (with-redefs [...]
    (t)))

(use-fixtures :each fix-mock-sites-events)
  \end{clojure}
\end{english}

\fi

Недостаток фикстуры в том, для всех тестов она задаёт позитивный сценарий (оба
вызова прошли без ошибок). Для полноты картины нужно проверить ошибки.

\subsection{Негативные сценарии}

\index{ошибки!недоступность}

Недоступность сервиса не должна влиять на приложение в целом. Если возникли
проблемы с кафе, пользователь увидит мероприятия, и~наоборот. Возможно, он даже
не заметит проблемы: если локации не пришли, приложение покажет старые данные.

Чтобы проверить главный экран на устойчивость, нужны сценарии:

\begin{itemize}

\item
  получили кафе, но не события;

\item
  наоборот: кафе в порядке, ошибка с событиями;

\item
  не работают оба сервиса.

\end{itemize}

Под общими словами <<не работают>> имеют в виду:

\index{HTTP!403}
\index{HTTP!429}

\begin{itemize}

\item
  проблемы доступа или квот: статусы 403 и 429;

\item
  недоступность сервиса: статусы 500 и 503;

\item
  проблемы связи: таймаут соединения или поиск хоста.

\end{itemize}

Напишем макрос \verb|with-mock|, который принимает путь к функции, результат
мока и тело, которое он оборачивает.

\index{макросы!with-mock}

\begin{english}
  \begin{clojure}
(defmacro with-mock
  [path result & body]
  `(with-redefs
     [~path (fn [& ~'_] ~result)]
     ~@body))
  \end{clojure}
\end{english}

Важно: для замены \verb|path| мы создаём функцию с помощью \verb|fn|, а не
\verb|constantly|. Дело в том, что \verb|result| может быть не только
выражением, но и произвольным кодом. \verb|Constantly|~--- это функция, поэтому её
аргументы вычисляются до того, как она сработает. Нельзя передать в неё код
c~исключением. Следующий код:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(constantly
  (throw (new Exception "error")))
;; Execution error at...
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(constantly (throw (new Exception "error")))
;; Execution error at...
;; error
  \end{clojure}
\end{english}

\fi

\index{порядок вычислений}

\noindent
бросит исключение до входа в \verb|with-redefs|. Наоборот, обёртка в
функцию откладывает исполнение кода до вызова:

\begin{english}
  \begin{clojure}
(fn [] (throw (new Exception "error")))
;; #function[eval53371/fn--53372]
  \end{clojure}
\end{english}

С помощью \verb|with-mock| собирают комбинации успехов и неудач. Тест ниже
проверяет сценарий, когда сервис кафе сработал без ошибок, а~с~событиями что-то
не так. Если запустить тест, окажется, что главный экран не ловит исключения, и
пользователь не получит ничего.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines}
(deftest test-sites-ok-events-err
  (with-mock
    book.views/get-sites-by-location
    [...]
    (with-mock
     book.views/get-events-by-location
     (throw
      (new UnknownHostException
        "DNS error"))
     (let [req {...}
           res (view-main-page req)
           {:keys [status body]} res]
       (is (= 200 status))
       (is (= {...} body))))))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(deftest test-sites-ok-events-err
  (with-mock book.views/get-sites-by-location [...]
    (with-mock book.views/get-events-by-location
      (throw (new java.net.UnknownHostException "DNS error"))
      (let [request {...}
            response (view-main-page request)
            {:keys [status body]} response]
        (is (= 200 status))
        (is (= {...} body))))))
  \end{clojure/lines}
\end{english}

\fi

Доработайте \verb|view-main-page| так, чтобы тест получил ответ со статусом
200 и полем \verb|:sites|. Добавьте тесты с другими комбинациями: ошибка
соединения в \verb|get-sites|, статусы 403 и 500, недоступность сразу двух
сервисов.

Подумайте, как улучшить \verb|with-mock|. Сейчас макросы вложены друг в друга,
что даёт отступы и лишний код \ifx\devicetype\mobile(строки 2 и 5)\else(строки 2 и 3)\fi. Сделайте так, чтобы
\verb|with-mock| был похож на \verb|let|~--- принимал форму связывания, где
нечётный элемент~--- это путь к функции, а чётный~--- результат. Тогда каскад моков
можно будет заменить на один.

\subsection{Сбор данных}

\index{моки!сбор данных}

Не заглядывая в конец главы, подумайте, как сделать мок промышленного уровня. Он
не только возвращает результат, но и:

\begin{itemize}

\item
  считает, сколько раз его вызвали;

\item
  на каждый вызов запоминает аргументы;

\item
  принимает список результатов и возвращает их поочёредно, например первый и
  второй раз словари, а на третий~--- исключение;

\item
  предлагает удобный доступ к собранным данным.

\end{itemize}

Продвинутый мок следит за особой логикой. Например, поиск ресторанов вернёт
только базовые сведения о них. Чтобы получить подробные сведения о месте, нужно
слать отдельный запрос. Чтобы трафик не рос линейно, данные извлекают только для
трёх лучших ресторанов. Мок проверяет, что функцию \verb|get-site-details|
вызвали не больше трёх раз. В конце главы мы рассмотрим библиотеки для мокинга
в~Clojure.

\subsection{Недостатки}

Кажется, что проблема ушла: тесты автономны и не зависят от третьих
сервисов. Однако у моков свои недостатки, которые нужно иметь в~виду.

Мок нарушает принцип закрытости (чёрного ящика). При написании теста мы
подглядываем в код, чтобы узнать, какие функции заменить. Это нечестно: чем
меньше тест знает о коде, который тестирует, тем он надёжней.

Мок исключает сетевое взаимодействие, что иногда выходит боком. Передача данных
по HTTP~--- это сложный процесс. Подмена запроса на функцию~--- это грубое
приближение. С его помощью нельзя предугадать возможные ошибки.

Наконец, мок повышает связанность тестов с логикой. Если переименовать функцию,
которую мокают, форма \verb|(with-redefs...)| перестанет работать. Мелкие правки
в коде повлияют на тесты, что неудобно и~неверно идеологически.

Эти проблемы решают стабы, о которых речь в следующем разделе.

\subsection{Стабы}

\index{стабы}

Стаб (англ.~stub~--- <<заглушка>>)~--- это сущность, которая заменяет часть
системы на время тестов. От моков она отличается тем, что тест не может ей
управлять. Если моку указывают, что и чем заменить, то стаб~--- это чёрный ящик с
точки зрения теста.

Удачный пример стаба~--- это локальный сервер для поиска ресторанов. По адресу
\verb|/search/v1| он вернёт данные, которые скопировали из настоящего
источника. Больше мы не будем мокать функцию \verb|get-sites-by-location|.
Изменим её так, чтобы поле запроса \verb|:url| указывало на \verb|http://127.0.0.1:8808/|.
Если запустить тест, функция запросит локальный сервер.

У подхода со стабом преимущество: он снимает зависимость теста от логики. Тест
не знает устройство кода, нужно только перенацелить запросы на другой адрес. Это
вопрос конфигурации, а логика программы не меняется.

Другое достоинство в том, что во время теста происходит \emph{настоящий} обмен
данными по сети. Да, это локальный сервер без шифрования и проверки
сертификатов. Но основная часть HTTP протекает как в~боевом запуске. Приложение
читает заголовки, тело, парсит JSON, проверяет статус. С моком мы пропускаем эти
шаги.

\index{fake}

Сервера-заглушки ещё называют фейками (англ.~fake~--- <<подделка>>). С~помощью фейка
моделируют нештатное поведение сервера. Например, долгое ожидание, медленную
передачу данных или недоступность. Достичь таких эффектов моком трудно. С его
помощью можно только бросить исключение, которое ожидают от настоящего
HTTP-клиента. Однако тесты на исключениях далеки от реального положения дел.

Технически стаб~--- это фикстура. До запуска теста она включает сервер, а после
выключает его. На роль сервера подходит Jetty или другой адаптер для Ring. Мы
подробно рассмотрели их в главе про веб-разработку \page{ring-jetty}.

Напишем фикстуру для сервера карт. Для пути \verb|/search/v1| сервер вернёт
данные в JSON, а для остальных запросов~--- 404:

\label{sites-handler}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn sites-handler* [{:keys [uri]}]
  (case uri
    "/search/v1"
    {:status 200
     :body [{:name "Cafe1"
             :address "..."}
            {:name "Cafe2"
             :address "..."}]}
    {:status 404
     :body "page not found"}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn sites-handler* [{:keys [uri]}]
  (case uri
    "/search/v1"
    {:status 200 :body [{:name "Cafe1" :address "..."}
                        {:name "Cafe2" :address "..."}]}
    {:status 404 :body "page not found"}))
  \end{clojure}
\end{english}

\fi

\index{middleware!стабы}

Обернём функцию в middleware. Мы хотим, чтобы коллекция из ответа приводилась в
JSON автоматически. Кроме того, пригодятся параметры запроса:

\begin{english}
  \begin{clojure}
(def sites-handler
  (-> sites-handler*
      wrap-keyword-params
      wrap-params
      wrap-json-response))
  \end{clojure}
\end{english}

Сервер не меняет состояние от теста к тесту, потому что мы только читаем
данные. Подключим фикстуру с ключом \verb|:once|, чтобы она сработала один
раз:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}
        server (run-jetty
                 sites-handler opt)]
    (t)
    (.stop server)))

(use-fixtures :once
  fix-fake-sites-server)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}
        server (run-jetty sites-handler opt)]
    (t)
    (.stop server)))

(use-fixtures :once fix-fake-sites-server)
  \end{clojure}
\end{english}

\fi

\index{конфигурация}

Исправим функцию \verb|get-sites-by-location| так, чтобы бекэнд обращался к
локальному хосту. Очевидно, базовый URL должен быть в~конфигурации. Вы уже
знаете, как устроена конфигурация, поэтому не будем приводить весь код. Для
краткости представим, что переменная \verb|config|~--- это словарь
параметров. Полный URL для карт построим так:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:url (str (:maps-base-url config)
        "/search/v1")}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:url (str (:maps-base-url config) "/search/v1")}
  \end{clojure}
\end{english}

\fi

Вернёмся к тесту главного экрана. Нам не нужны моки, поэтому уберём макросы
\verb|with-mock|. Прямо сейчас тест не пройдёт, потому что мы решили проблему
только с поиском заведений. Для событий код по-прежнему обращается к чужому
серверу. Чтобы проверить стаб, закомментируем события, а поле \verb|:events|
сделаем \verb|nil|. Тест пройдёт без ошибок: в поле \verb|:sites| окажутся
данные, что вернул стаб.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-main-page
  (let [request
        {:params {:lat 55.751244
                  :lon 37.618423}}
        result (view-main-page request)]
    (is (= (:body result)
           {:sites [...] :events nil}))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-main-page
  (let [request {:params {:lat 55.751244
                          :lon 37.618423}}
        result (view-main-page request)]
    (is (= (:body result) {:sites [...] :events nil}))))
  \end{clojure}
\end{english}

\fi

Раскомментируйте поиск событий и напишите для него заглушку. Оформите её в
фикстуру и убедитесь, что тест проходит.

Рассмотрим, что ещё интересного предлагают стабы. Как и в случае с моками,
удобно, когда ответы лежат в файлах. Чтобы фейковый сервер читал файл, передайте
его экземпляр в \verb|:body| \page{http-files}:

\index{файлы!в стабах}

\begin{english}
  \begin{clojure}
{:status 200
 :body (-> "data/events.json"
           clojure.java.io/resource
           clojure.java.io/file)}
  \end{clojure}
\end{english}

\noindent
В файл \verb|resources/data/events.json| запишите данные, полученные
от~реального сервера.

\index{координаты}
\index{геолокация}

Стаб всегда возвращает успешный ответ, что неудобно. Научим его негативным
сценариям. Проще всего это сделать с помощью параметров. Договоримся, что
некоторые координаты, которые посылает пользователь, особые. Для пары \tuple{0, 0}
сервер вернёт пустой результат; при \tuple{66, 66} получим ошибку
доступа. С координатами \tuple{42, 42} сервер отвечает с задержкой в 35
секунд. Перепишем \verb|sites-handler*|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn sites-handler* [request]
  (let [{:keys [uri params]} request
        {:keys [lat lon]} params]
    (case uri
      "/search/v1"
      (case [lat lon]
        [ "0"  "0"]
        {:status 200 :body []}

        ["66" "66"]
        {:status 403
         :body {:error "ACCESS_ERROR"}}

        ["42" "42"]
        (do (Thread/sleep (* 1000 35))
            {:status 200 :body []})

        {:status 200
         :body [{:name "Cafe1"
                 :address "..."}
                {:name "Cafe2"
                 :address "..."}]})
      {:status 404
       :body "page not found"})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn sites-handler* [request]
  (let [{:keys [uri params]} request
        {:keys [lat lon]} params]
    (case uri
      "/search/v1"
      (case [lat lon]
        [ "0"  "0"] {:status 200 :body []}
        ["66" "66"] {:status 403 :body {:error "ACCESS_ERROR"}}
        ["42" "42"] (do (Thread/sleep (* 1000 35))
                        {:status 200 :body []})
        {:status 200
         :body [{:name "Cafe1" :address "..."}
                {:name "Cafe2" :address "..."}]})
      {:status 404 :body "page not found"})))
  \end{clojure}
\end{english}

\fi

\index{HTTP!ожидание}

Напишите тесты для этих координат. Особенно интересен случай с~долгим ответом
для пары \tuple{42, 42}. Убедимся, что если сервис карт не отвечает, мы ждём
разумное время, а не стандартные 30 секунд. Передайте в параметры
\verb|(client/get)| поля \verb|:socket-timeout| и \verb|:connection-timeout| со
значением 5000, пять секунд. Этого хватит для боевого запуска. Замерьте
выполнение \verb|view-main-page|. Добавьте проверку, что ожидание не превышает
пять секунд с небольшой погрешностью около 100 миллисекунд.

Тест на экстремальный случай: что произойдёт, если сервер недоступен? Чтобы
смоделировать ситуацию, у теста должен быть доступ к серверу. Поместим его в
динамическую переменную:

\index{недоступность}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *server* nil)

(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}]
    (binding [*server*
              (run-jetty
                sites-handler opt)]
      (t)
      (.stop *server*))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *server* nil)

(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}]
    (binding [*server*
              (run-jetty sites-handler opt)]
      (t)
      (.stop *server*))))
  \end{clojure}
\end{english}

\fi

Напишем тест, в котором временно отключим сервер. В конце его нужно включить,
чтобы не задеть остальные тесты.

\begin{english}
  \begin{clojure}
(deftest test-the-website-is-down
  (.stop *server*)
  (let [request {:params {:lat 1 :lon 2}}
        result (view-main-page request)]
    (is (= (:body result) {...})))
  (.start *server*))
  \end{clojure}
\end{english}

В обработчике запроса получим ошибку Connection refused. Доработайте код,
чтобы пользователю ушёл пустой результат.

\subsection{Ресурсы и пути}

\label{resources}

\index{JVM!ресурсы}
\index{файлы!ресурсы}

Мы упомянули, что данные для моков или стабов хранят в файлах. Так мы не
засоряем код объёмными словарями. Файлы в папке \verb|resources| называются
ресурсами приложения. У них особая роль: при сборке jar-файла ресурсы становятся
его частью. Код из jar читает ресурсы, словно это файлы рядом на диске.

Мы поместили файл \verb|events.json| в папку \verb|resources/data| и читали
как ресурс. Проблема в том, что файл нужен только для тестов. Если собрать
проект, \verb|events.json| попадёт в jar-файл, что напрасно увеличит его
объём.

Чтобы отбросить лишние ресурсы при сборке, в проекте указывают
\verb|:resource-paths|. Это вектор, в котором перечислены пути для поиска
ресурсов. По умолчанию он равен \verb|["resources"]|. При слиянии профилей
векторы соединяются в один. Если другой профиль задал ресурсы иначе:

\begin{english}
  \begin{clojure}
:resource-paths ["resources_test"],
  \end{clojure}
\end{english}

\noindent
то в итоге программа ищет ресурсы в обеих папках. Для боевой сборки оставим
только \verb|resources|, чтобы не вбирать ресурсы для тестов.

\index{env-директория}

Путь \verb|resources_test| выбран неудачно. Более удобный способ связать файлы
и окружение~--- это \emph{env-директория}. На её первом уровне находятся папки с
именами профилей, а в них~--- \verb|src| и \verb|resources| с~кодом и
ресурсами, которые относятся к этому профилю.

Создайте папки и переместите ресурсы для теста:

\ifx\devicetype\mobile

\begin{english}
  \begin{bash}
$ mkdir -p env/test/resources/data
$ mv resources/data/events.json \
     env/test/resources/data/
  \end{bash}
\end{english}

\else

\begin{english}
  \begin{bash}
$ mkdir -p env/test/resources/data
$ mv resources/data/events.json env/test/resources/data/
  \end{bash}
\end{english}

\fi

\noindent
Получилась структура:

\begin{english}
  \begin{bash}
$ tree env
  \end{bash}
\end{english}

\dirtree{%
 .1 env.
 .2 dev.
 .3 resources.
 .2 test.
 .3 resources.
 .4 data.
 .5 events.json.
}

\linegap

\noindent
Задайте профили в проекте:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:profiles {:test {:resource-paths
                  ["env/test/resources"]}
           :dev {:resource-paths
                 ["env/test/resources"]}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:profiles {:test {:resource-paths ["env/test/resources"]}
           :dev  {:resource-paths ["env/test/resources"]}}
  \end{clojure}
\end{english}

\fi

На первый взгляд, странно, что для \verb|:dev| и \verb|:test| мы указали один
и тот же путь. По умолчанию REPL запускается с профилем \verb|dev|, но не
\verb|test|. В разработке у нас не будет доступа к ресурсам из
\verb|env/test|. Это влечёт неудобства: мы исправили код и вызвали тест из
REPL, но он не проходит из-за путей.

\index{REPL}

Если вам не нравятся повторы в конфигурации, запустите REPL с~ключом
\verb|with-profile +test|. Плюс перед профилем означает \emph{добавить} его к
стандартному. Без плюса профиль \emph{заменит} его.

\index{профили!lein}

Обратите внимание: вы переместили файл между папками, но для JVM это один и тот
же ресурс \verb|data/events.json|. Код его загрузки не изменился:

\begin{english}
  \begin{clojure}
(def data-events
  (-> "data/events.json"
      clojure.java.io/resource
      slurp
      (json/parse-string true)))
  \end{clojure}
\end{english}

Любознательным читателям предлагаем эксперимент. Скомпилируйте \verb|uberjar|
с разными ресурсами: в первый раз как обычно, а во второй~--- с опцией
\verb|:resource-paths|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:profiles
  {:uberjar {:resource-paths
             ["env/test/resources"]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:profiles {:uberjar {:resource-paths ["env/test/resources"]}
  \end{clojure}
\end{english}

\fi

После сборки сохраните файл \verb|target/uberjar/<project>.jar| в~другую папку,
чтобы не затереть его во второй раз. Распакуйте оба архива командой \verb|jar|:

\begin{english}
  \begin{bash}
$ jar xf <project>.jar
  \end{bash}
\end{english}

Среди файлов из второго архива вы найдёте \verb|data/events.json|. Убедитесь,
что его нет в первом архиве. Вашу программу распакует любой желающий, поэтому в
ресурсах не должно быть приватных данных вроде паролей и ключей. Это касается и
данных для тестирования~--- включить их в jar будет ошибкой.

Пользуясь случаем, изучите другие файлы из jar, их структуру и~содержимое.

\subsection{База данных}

\index{тесты!база данных}

При написании тестов вы столкнётесь с проблемой: почти каждое действие требует,
чтобы в базе лежали особые данные. Для создания пользователя нужен
администратор. Чтобы добавить участника в~группу, нужна эта группа. Чтобы
оформить заказ, нужны товары, история покупок для расчёта скидки и многое
другое. Чем шире логика приложения, тем больше нужно данных для теста.

Если каждый каждый раз готовить данные вручную, с тестами начнутся
проблемы. Нужна единая точка входа, чтобы каждый тест имел доступ к одинаковым
данным. В идеале данные декларативны и~находятся в файле. Чтобы добавить запись,
мы исправляем файл, а не код. Когда тесты закончились, содержимое базы
исчезает. Недопустимо, чтобы тест зависел от изменений, выполненных в другом
тесте.

В этом разделе мы рассмотрим, как работать с базой на время тестов. Начнём с
первого шага~--- подготовки базы. Под этим понимают создание таблиц, индексов и
других сущностей \emph{без вставки} данных.

\index{утилиты!createuser}
\index{утилиты!createdb}

Базу создают до запуска тестов. Способ зависит от того, как она работает:
локально или в Docker. Если локально, вызовем несколько утилит. Ниже мы
обращаемся к \verb|createuser| и \verb|createdb| из поставки PostgreSQL:

\begin{english}
  \begin{bash}
$ createuser book_test -S -W
$ createdb -O book_test book_test
  \end{bash}
\end{english}

Первая команда готовит пользователя с именем \verb|book_test|. Ключ~\verb|-S|
означает, что это \emph{супер}пользователь, обладатель высших
привилегий. Супердоступ нужен, чтобы включать расширения базы: триграммный
поиск, прогрев индексов и другие.

Вторая команда создаёт одноимённую пустую базу. Ключ \verb|-O| (owner) задаёт
владельца базы. Владелец имеет полный доступ ко всем её сущностям. В боевом
запуске приложению выделяют минимальные права вплоть до отдельных таблиц, но для
тестов это неважно.

\index{Docker}

Если база работает в Docker, обратитесь к главе про системы. Там мы узнали, как
задать параметры базы в .yaml-файле и переменными среды \page{docker-db}.

\index{SQL!миграции}
\index{библиотеки!Migratus}

Пустую базу наполняют таблицами. Если приложение ведёт миграции, их запускают до
тестов из командной строки. Команда \verb|migratus| доступна из одноимённой
библиотеки и \footurl{плагина к~Lein}{https://github.com/yogthos/migratus-lein}[Migratus][-7mm]
для управления миграциями.

\begin{english}
  \begin{clojure}
$ lein migratus migrate
$ lein test
  \end{clojure}
\end{english}

Прогона миграций можно избежать, если скопировать их в папку образа
\verb|/docker-entrypoint-initdb.d|. Образ устроен так, что при запуске
выполнит все sql-файлы из этой папки. Убедитесь, что скопировали только
\verb|up|-миграции, иначе их \verb|down|-версии сведут пользу на нет.

Таблицы и индексы готовы, остались данные. Перечислим способы их вставки и
очистки во время тестов.

\subsubsection*{Ручная вставка}

В простом случае данные для тестов хранят в виде коллекции. Специальная функция
пробегает по списку словарей; каждый словарь~--- это запись в базе. Функцию
оборачивают в фикстуру, которая запускает тест после вставки записей:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def db-data
 [[:users {:name "Ivan"
           :email "ivan@test.com"}]
  [:users {:name "Juan"
           :email "Juan@test.com"}]
  [:groups {:name "Python fans"
            :topics 6}]
  [:groups {:name "Clojure fans"
            :topics 7}]])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def db-data
  [[:users {:name "Ivan" :email "ivan@test.com"}]
   [:users {:name "Juan" :email "Juan@test.com"}]
   [:groups {:name "Python fans" :topics 6}]
   [:groups {:name "Clojure fans" :topics 7}]])
  \end{clojure}
\end{english}

\fi

\index{JDBC!insert"!}

Здесь и ниже мы полагаем, что переменная \verb|*db*| означает подключение к
базе. Не важно, откуда пришла эта переменная: читатель знаком с системами и
конфигурацией и вправе задать \verb|*db*| на своё усмотрение.

\begin{english}
  \begin{clojure}
;; loader
(defn load-data []
  (doseq [[table row] db-data]
    (jdbc/insert! *db* table row)))

;; fixture
(defn fix-db-data [t]
  (load-data)
  (t))
  \end{clojure}
\end{english}

Для каждой записи нужно знать её таблицу. Это может быть первый элемент пары
\tuple{таблица, запись} или поле метаданных. Когда записей одного типа много,
таблица становится избыточной. Сгруппируем записи по таблицам и вставим не по
одной, а разом, что быстрее.

\index{JDBC!insert-multi"!}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def db-data
  [[:users [{:name "Ivan"
             :email "ivan@test.com"}
            {:name "Juan"
             :email "Juan@test.com"}]]
  [:groups [{:name "Dog fans"
             :topics 6}
            {:name "Cat fans"
             :topics 7}]]])

(defn load-data []
 (doseq [[table rows] db-data]
  (jdbc/insert-multi! *db* table rows)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def db-data
  [[:users [{:name "Ivan" :email "ivan@test.com"}
            {:name "Juan" :email "Juan@test.com"}]]
   [:groups [{:name "Dog fans" :topics 6}
             {:name "Cat fans" :topics 7}]]])

(defn load-data []
  (doseq [[table rows] db-data]
    (jdbc/insert-multi! *db* table rows)))
  \end{clojure}
\end{english}

\fi

Структура \verb|db-data| напоминает словарь, но всё же им не является. Мы
намеренно используем вектор, чтобы гарантировать порядок обхода. Как мы увидим
далее, очерёдность загрузки важна.

\subsubsection*{Вставка из CSV}

\index{форматы!CSV}

Когда записей ещё больше, словари становятся неудобны. Ключи словаря занимают
половину его описания. Для тысячи записей мы столько же раз укажем ключи. Если
структура данных одинакова, их хранят в виде массива, а ключи указывают один
раз.

Именно так устроен формат \footurl{CSV}{https://en.wikipedia.org/wiki/Comma-separated\_values}[CSV].
Это текст, где каждая строка означает запись, а поля разделены запятой.
В первой строке обычно идёт заголовок~--- имена полей с тем же разделителем.

У CSV несколько преимуществ. Записи~--- это массивы, а не словари, поэтому имена
полей не повторяются. CSV компактней JSON и аналогов. С ним работают табличные
редакторы Excel и OpenOffice. Можно открыть CSV как электронную таблицу,
добавить или удалить столбец, пересчитать ячейки формулой и сохранить результат.

\index{SQL!INSERT}

Отдельные базы читают и пишут CSV напрямую. На больших объёмах вставка из CSV
работает быстрее, чем обычный \verb|INSERT|.

Предположим, нам скинули данные о пользователях в CSV. Поместим их в ресурс
\verb|data/users.csv|. Несколько первых строк:

\begin{english}
  \begin{text}
name,age,email
ivan,34,ivan@test.me
juan,39,juan@example.com
ioan,19,ioan@dunno.org
  \end{text}
\end{english}

\index{SQL!COPY}

Составим запрос с командой \verb|COPY|. Это особый оператор, который работает в
PostgreSQL. Укажем таблицу, путь к CSV-файлу и его свойства. Под свойствами
понимают разделитель, формат файла и~признак заголовка. Разделителем могут быть
не только запятая, но и точка с~запятой или табуляция. Если заголовка нет,
считается, что поля идут в том же порядке, что и в таблице.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(jdbc/execute! *db*
 "COPY users(name, age, email)
  FROM
  '.../env/test/resources/data/users.csv'
  DELIMITER ',' CSV HEADER")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(jdbc/execute! *db*
 "COPY users(name, age, email)
  FROM '/Users/ivan/work/book/env/test/resources/data/users.csv'
  DELIMITER ',' CSV HEADER")
  \end{clojure}
\end{english}

\fi

Заметим, что запрос ожидает полный путь к файлу, что мешает командной
работе. Вряд ли ваши коллеги держат проект в папке
\verb|/Users/ivan/work/book|. На практике полный путь к файлу вычисляют из
относительного.

Если в запросе нет ошибок, и файл на месте, и пользователю хватает прав, в
таблице \verb|users| окажутся данные из файла. Аналогично работает сброс
таблицы в файл: оператор \verb|FROM| заменяют на \verb|TO|.

\index{Gzip}
\index{классы!GZIPInputStream}
\index{классы!CopyManager}

Выполним загрузку из CSV силами Clojure. Усложним задачу тем, что в файле очень
много записей и потому он сжат алгоритмом GZip. Это полезная практика: все
большие файлы в репозитории должны быть сжаты. Чтобы читать такой файл на лету
(не выгружая во временную папку), понадобятся классы:

\begin{english}
  \begin{clojure}
(:import java.io.FileInputStream
         java.util.zip.GZIPInputStream
         org.postgresql.copy.CopyManager)
  \end{clojure}
\end{english}

Класс \verb|CopyManager|~--- это обёртка над командой \verb|COPY|. Его конструктор
принимает соединение с базой. Уточним: именно открытое TCP-соединение, а не
словарь. Функция \verb|jdbc/get-connection| вернёт соединение из словаря
\ifx\devicetype\mobile(строки 2--3)\else(строка~2)\fi. Метод \verb|copyIn| ожидает
SQL-запрос и поток данных CSV. Поток получим из ресурса \verb|data/users.csv.gz|,
пропустив его через серию функций и классов \ifx\devicetype\mobile(строки 5--10)\else(строки 4--8).\fi
\verb|GZIPInputStream| оборачивает поток и~при чтении декодирует данные в полёте.
В конце работы закрываем соединение с базой.

\index{JDBC!get-connection}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines}
(defn load-data-gz []
  (let [conn
        (jdbc/get-connection *db*)
        copy (CopyManager. conn)
        stream
        (-> "data/users.csv.gz"
            clojure.java.io/resource
            clojure.java.io/file
            FileInputStream.
            GZIPInputStream.)]
   (.copyIn copy
     "COPY users(name, age, email)
      FROM STDIN
      (FORMAT CSV, HEADER true)"
     stream)
   (.close conn)))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(defn load-data-gz []
  (let [conn (jdbc/get-connection *db*)
        copy (CopyManager. conn)
        stream (-> "data/users.csv.gz"
                   clojure.java.io/resource
                   clojure.java.io/file
                   FileInputStream.
                   GZIPInputStream.)]
    (.copyIn copy "COPY users(name, age, email)
                   FROM STDIN (FORMAT CSV, HEADER true)"
             stream)
    (.close conn)))
  \end{clojure/lines}
\end{english}

\fi

Нельзя загрузить один файл сразу в несколько таблиц. Соблюдайте правило: один
файл~--- одна таблица. Если файлов несколько, перепишите функцию так, чтобы она
принимала путь к файлу и имя таблицы. Импорт \emph{очень больших} данных
(миллион и больше) можно вести параллельно. Для этого CSV разбивают на несколько
потоков, каждый из которых читает свою часть файла. Их загружают одновременно
с~помощью футур и \verb|pmap|.

\subsubsection*{Проблема ключей}

\index{ключи!первичный}
\index{ключи!внешний}

\index{Primary Key}
\index{Foreign Key}

Таблицы редко существуют сами по себе. Чаще всего они связаны: пользователь
ссылается на профиль, заказ на пользователя и так далее. Для этого служат
\emph{первичный} и \emph{внешний} ключи. Первичный ключ (PK, Primary Key)~--- это
поле, которое однозначно определяет запись в~таблице. Внешний ключ (FK, Foreign
Key)~--- это поле, которое ссылается на первичный ключ другой таблицы. Вместе они
называются \emph{отношением} таблиц.

\index{счётчики!в базе данных}

Как правило, первичные ключи~--- это целые числа с автоматической нумерацией. Чтобы
добавить запись в таблицу, не нужно подбирать новый PK: база ведёт для него
уникальный счётчик. Для очередной записи он вырастет на единицу. Имя счётчика в
PostgreSQL строится по шаблону \verb|<table>_<pk>_seq|, например
\verb|users_id_seq|.

Чтобы связать записи, задайте их PK и FK одинаковые значения. Ниже пользователь
ссылается на группу; ключ группы взяли случайно.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def group-id 3)
(jdbc/insert! *db* :groups
  {:id group-id :name "Clojure users"})
(jdbc/insert! *db* :users
  {:group_id group-id :name "Ivan"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def group-id 3)
(jdbc/insert! *db* :groups {:id group-id :name "Clojure users"})
(jdbc/insert! *db* :users {:group_id group-id :name "Ivan"})
  \end{clojure}
\end{english}

\fi

Проблема в том, что заданный вручную PK может вступить в~конфликт со
счётчиком. Предположим, при вставке в \verb|groups| счётчик был равен
нулю. Поскольку мы задали \verb|id| явно, счётчик не увеличился. Теперь нужны
ещё три группы. Нам не важен их \verb|id|, поэтому не будем указывать его при
вставке. База присвоит записям ключ из счётчика. Две первые группы получат
значения 1 и 2. Для третьей возникнет ошибка:

\index{конфликты ключей}

\ifx\devicetype\mobile

\begin{english}
  \begin{text}
ERROR: duplicate key violates
       unique constraint 'groups_pkey'
DETAIL: Key (id)=(3) already exists
  \end{text}
\end{english}

\else

\begin{english}
  \begin{text}
ERROR: duplicate key violates unique constraint 'groups_pkey'
DETAIL: Key (id)=(3) already exists
  \end{text}
\end{english}

\fi

Ключ 3 в конфликте с записью, которую мы добавили раньше. Избежать этого можно
двумя способами: коррекцией счётчиков и~особой загрузкой данных. Разница в том,
кто контролирует счётчики: вы или база данных.

Под ручной коррекцией имеют в виду следующее. В тестовых данных явно указывают
первичные ключи. Для удобства некоторые из них выносят в переменную. Если на
администратора ссылаются несколько сущностей, вынесем его ключ в переменную:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def id-user-admin 1)

(def db-data
  [[:users [{:id id-user-admin
             :name "Ivan"}]]
   [:profiles [{:id 1
                :user_id id-user-admin
                :avatar "..."}]
    :posts [{:id 1
             :user_id id-user-admin
             :title "New book"}
            {:id 2
             :user_id id-user-admin
             :title "Some post"}]]])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def id-user-admin 1)

(def db-data
  [[:users [{:id id-user-admin :name "Ivan"}]]
   [:profiles [{:id 1 :user_id id-user-admin :avatar "..."}]
    :posts [{:id 1 :user_id id-user-admin :title "New book"}
            {:id 2 :user_id id-user-admin :title "Some post"}]]])
  \end{clojure}
\end{english}

\fi

\index{счётчики!сброс}

После вставки исправим счётчики так, чтобы они перескочили значения, которые мы
использовали. Предположим, в тестовый набор входит семь пользователей, и мы
назначили им ключи от 1 до 7. Если установить счётчик в 100, он уже не вернётся
к числам от 1 до 7. Новые записи в \verb|users| получат ключи 101, 102 и так
далее. Чтобы сбросить счётчик, выполните запрос:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(jdbc/execute! *db*
  "ALTER SEQUENCE users_id_seq
   RESTART WITH 100")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(jdbc/execute! *db*
  "ALTER SEQUENCE users_id_seq RESTART WITH 100")
  \end{clojure}
\end{english}

\fi

Если первичный ключ называется \verb|id| (что рекомендуется), нужно знать
только имя таблицы. Чтобы не перечислять таблицы вручную, получим их из массива
\verb|db-data|. Добавьте в конец \verb|load-data| вызов функции:

\index{SQL!ALTER SEQUENCE}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn restart-db-ids []
  (let [value 100
        tables (set (map first db-data))
        query "ALTER SEQUENCE %s_id_seq
               RESTART WITH %s"]
    (doseq [table tables]
      (jdbc/execute! *db*
        (format query
          (name table) value)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn restart-db-ids []
  (let [value 100
        tables (set (map first db-data))
        query "ALTER SEQUENCE %s_id_seq RESTART WITH %s"]
    (doseq [table tables]
      (jdbc/execute! *db* (format query (name table) value)))))
  \end{clojure}
\end{english}

\fi

Он подхватит все таблицы из \verb|db-data| и выставит счётчики в 100. На
больших данных из CSV эту цифру придётся увеличить на порядок или два. Если
потребуется, по \verb|id| вы отличите исходную запись от добавленной в
процессе. Запрос \verb|DELETE ... WHERE id > 100| удалит записи, которые
попали в базу после <<накрутки>> счётчиков.

Теперь рассмотрим загрузчик. В этом случае полагаются на ключи, которые вернула
база данных. Конкретные их значения не важны. Главное, чтобы у связанных записей
первичный и внешний ключи совпадали. Для этого пойдём на хитрость.

Для начала удалим первичные ключи из тестовых данных. Ни в~одном словаре нет
поля \verb|:id| с конкретным значением. Сущностям, на которые нужно ссылаться,
присвоим псевдонимы. Проще всего это сделать через метаданные. В полях, которые
ссылаются на другие записи, вместо чисел укажем псевдоним.

\index{метаданные}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; users
^{:db/alias :users/admin}
 {:name "Ivan" :email "ivan@test.com"}

;; posts
{:user_id :users/admin
 :title "New book"}
{:user_id :users/admin
 :title "Some post"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
;; users
^{:db/alias :users/admin}
 {:name "Ivan" :email "ivan@test.com"}

;; posts
{:user_id :users/admin :title "New book"}
{:user_id :users/admin :title "Some post"}
  \end{clojure}
\end{english}

\fi

Загрузчик объявляет атом с пустым словарём и наполняет его в~процессе. Если у
записи псевдоним, мы связываем его с ключом, который вернула база. Например, при
вставке первого словаря получили \verb|id|, равный 5. Атом станет
\verb|{:users/admin 5}|.

Дополнительно загрузчик ищет ссылки в словаре перед записью. Если значение
поля~--- кейворд, считаем, что это внешний ключ. В профиле встречается поле
\verb|:user_id| со значением \verb|:users/admin|. Очевидно, нужно заменить
его на то, что лежит в атоме по этому ключу (5). Если в атоме нет ключа,
бросить исключение.

\index{базы данных!MariaDB}

Напишите загрузчик самостоятельно. Имейте в виду, что ответ
\verb|jdbc/insert!| зависит от типа базы данных. Привёдем примеры для
популярных баз PostgreSQL и MariaDB (форк MySQL):

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(jdbc/insert! *db*
  :users {:name "Ivan"})
({:id 5 :name "Ivan"}) ;; for PostgreSQL
({:generated_key 6})   ;; for MariaDB
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(jdbc/insert! *db* :users {:name "Ivan"})
({:id 5 :name "Ivan"}) ;; for PostgreSQL
({:generated_key 6})   ;; for MariaDB
  \end{clojure}
\end{english}

\fi

Результат вставки~--- это список с одним элементом. Если вы поддерживаете обе базы,
пригодится универсальный поиск ключа:

\begin{english}
  \begin{clojure}
(defn insert->pk [result]
  (let [[row] result
        {:keys [id generated_key]} row]
    (or id generated_key)))
  \end{clojure}
\end{english}

\subsubsection*{Удаление данных}

\index{фикстуры!очистка данных}
\index{SQL!DELETE FROM}

Очистка базы столь же важна, как и наполнение. Она должна занимать минимум
усилий и не оставлять артефактов.

Наивный способ очистить базу~--- выполнить \verb|DELETE FROM <table>| для всех
таблиц, с которыми работают тесты. Проблема \verb|DELETE| в том, что он
учитывает зависимость ключей. Нельзя удалить пользователя, если на него
ссылается профиль. Придётся вызвать \verb|DELETE| в правильном порядке:
сначала для \verb|profiles|, затем для \verb|users|. Чем больше таблиц, тем
сложнее запомнить порядок.

\index{SQL!ON DELETE}

Читатель, знакомый с PostgreSQL, возразит: каскадное удаление возможно при
помощи \verb|ON DELETE| в описании ключа. Это продвинутая техника, и сейчас
мы не будем о ней говорить. Нас интересует, как очистить данные независимо от
того, как заданы ключи и ссылки.

\index{SQL!TRUNCATE}

Команда \verb|TRUNCATE| \eng{подрезать} нужна для быстрой очистки таблицы. В
отличие от \verb|DELETE|, она не вызывает триггеры и не сканирует всю
таблицу. \verb|TRUNCATE| принимает несколько таблиц за раз. Её~преимущество в
каскадном режиме. Если передан флаг \verb|CASCADE|, все таблицы из графа связей
тоже очищаются. Каскадная очистка пары таблиц вызывает цепную реакцию по всей
базе.

\index{функции!fix-db-data}

Напишем функцию очистки. Она посылает запрос, в котором через запятую указаны
таблицы из данных для тестов. Добавьте её в~фикстуру \verb|fix-db-data| после
вызова \verb|(t)|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn delete-data []
  (let [tables (set (map first db-data))
        tables-comma
        (str/join "," (map name tables))
        query
        (format "TRUNCATE %s CASCADE"
          tables-comma)]
    (jdbc/execute! *db* query)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn delete-data []
  (let [tables (set (map first db-data))
        tables-comma (str/join "," (map name tables))
        query (format "TRUNCATE %s CASCADE" tables-comma)]
    (jdbc/execute! *db* query)))
  \end{clojure}
\end{english}

\fi

\subsubsection*{Транзакция с откатом}

\index{транзакции!в тестах}

\index{SQL!BEGIN}
\index{SQL!COMMIT}

Другой способ избавиться от изменений в базе~--- обернуть действия с ней в
особую транзакцию. Она завершается оператором не \verb|COMMIT|, а
\verb|ROLLBACK|, что значит <<откатить команды>>. С точки зрения базы это
выглядит так:

\begin{english}
  \begin{sql}
BEGIN;
INSERT INTO users ...
INSERT INTO profiles ...
UPDATE users SET name=...
ROLLBACK;
  \end{sql}
\end{english}

При выходе из транзакции мы не увидим эффекта \verb|INSERT|, \verb|UPDATE| и
других изменений.

В пакет JDBC входит функция \verb|db-set-rollback-only!|. Она принимает
транзакционное соединение и выставляет ему флаг \verb|rollback|. Если флаг
установлен, JDBC завершает блок откатом.

\index{макросы!with-db-transaction}

Вы уже знакомы с макросом \verb|with-db-transaction|: внутри него действует
транзакционное соединение, которое получают из JDBC-спеки. Наш макрос
\verb|with-db-rollback| делает то же самое, но устанавливает откат:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defmacro with-db-rollback
  [[t-conn & bindings] & body]
  `(jdbc/with-db-transaction
     [~t-conn ~@bindings]
     (jdbc/db-set-rollback-only!
       ~t-conn)
     ~@body))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defmacro with-db-rollback
  [[t-conn & bindings] & body]
  `(jdbc/with-db-transaction [~t-conn ~@bindings]
     (jdbc/db-set-rollback-only! ~t-conn)
     ~@body))
  \end{clojure}
\end{english}

\fi

\noindent
Макрос в действии:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(with-db-rollback [tx *db*]
  (println "Inserting the data...")
  (jdbc/insert! tx
    :users {:name "Ivan"})
  (let [...]
    (do-something-with-db tx)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-db-rollback [tx *db*]
  (println "Inserting the data...")
  (jdbc/insert! tx :users {:name "Ivan"})
  (let [...]
    (do-something-with-db tx)))
  \end{clojure}
\end{english}

\fi

Следите за тем, чтобы все действия с базой протекали через \verb|tx|, а~не
\verb|*db*|. Изменения в рамках обычного соединения останутся в базе. Этим
страдает загрузчик \verb|load-data|, который ссылается на глобальную переменную
\verb|*db*|. Если загрузчик <<упал>> на середине, половина данных останется в
базе. Чтобы загрузка была в транзакции, передайте параметр или свяжите
\verb|*db*| формой \verb|binding|.

Случай с параметром: \verb|load-data| принимает \verb|tx|, который мы
установили на вершине теста.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (load-data tx) ;; takes a parameter
    (let [user
          (get-user-by-name tx "Ivan")]
      (is (= "Ivan" (:name user))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (load-data tx) ;; takes a parameter
    (let [user (get-user-by-name tx "Ivan")]
      (is (= "Ivan" (:name user))))))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!binding}

Вариант с динамической переменной. В этом случае мы считаем, что все функции
ссылаются на \verb|*db*|. Внутри макроса она станет транзакционным соединением
с откатом.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (binding [*db* tx]
      (load-data) ;; no parameters
      (let [user
            (get-user-by-name "Ivan")]
        (is (= "Ivan" (:name user)))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (binding [*db* tx]
      (load-data) ;; no parameters
      (let [user (get-user-by-name "Ivan")]
        (is (= "Ivan" (:name user)))))))
  \end{clojure}
\end{english}

\fi

Выбор зависит от того, как в проекте работают с базой. Решение с откатом
подходит для Mount и похожей архитектуры, где база~--- это глобальная
переменная. Подумайте, как написать фикстуру с макросом
\verb|with-db-rollback|. Будет ли она работать с системой компонентов? Что
необходимо в этом случае?

\section{Тестирование веб-приложений}

\index{тесты!для веб-приложений}

Тесты на отдельные функции необходимы, но не недостаточны. Они защищают проект от
случайных изменений, но не обещают, что система устойчива. Поднимемся выше и
рассмотрим, как тестировать приложение целиком.

В главе про веб-разработку мы пришли к важному выводу. На~каждом уровне
веб-приложение~--- это функция одного аргумента. Обработчик запроса, маршруты и
цепочка middleware~--- это функции, которые принимают запрос и возвращают
ответ \page{http-all-function}.

Чтобы написать тест, составим запрос и вызовем приложение как функцию. Проверим
статус ответа на успех (200, 201) или неудачу (404, 403). Если это ответ с JSON,
прочитаем данные из тела и сравним с~образцом.

Вспомним приложение из первой главы \page{compojure}. Отдельные страницы мы
соединили в маршруты с помощью Compojure. Получилось <<голое>> приложение. Оно
многого не умеет, в том числе читать параметры, работать с JSON, сессиями и так
далее. Эти возможности добавляют middleware, в которые оборачивают приложение.

\index{middleware}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defroutes app-naked
  (GET "/"
    request (page-index request))
  (GET "/hello"
    request (page-hello request))
  page-404)

(def app
  (-> app-naked
      wrap-session
      wrap-keyword-params
      wrap-params
      wrap-json-body
      wrap-json-response))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defroutes app-naked
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)

(def app
  (-> app-naked
      wrap-session
      wrap-keyword-params
      wrap-params
      wrap-json-body
      wrap-json-response))
  \end{clojure}
\end{english}

\fi

Напишем несколько тестов для приложения. Для экономии места сверим только статус
ответа, не заглядывая в \verb|body|. Проверим главную страницу:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-app-index
  (let [request {:request-method :get
                 :uri "/"}
        response (app request)
        {:keys [status body]} response]
    (is (= 200 status))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-app-index
  (let [request {:request-method :get :uri "/"}
        response (app request)
        {:keys [status body]} response]
    (is (= 200 status))))
  \end{clojure}
\end{english}

\fi

\noindent
и путь, которого нет в маршрутах:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-app-page-not-found
  (let [request {:request-method :get
                 :uri "/missing"}
        response (app request)
        {:keys [status body]} response]
    (is (= 404 status))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-app-page-not-found
  (let [request {:request-method :get :uri "/missing"}
        response (app request)
        {:keys [status body]} response]
    (is (= 404 status))))
  \end{clojure}
\end{english}

\fi

\index{моки}

Как видно из примеров, писать тесты для веб-приложения нетрудно. Если страница
обращается в сеть, вызов <<мокают>> или запускают стаб, как мы делали это с
поиском кафе и событий для мобильного приложения \page{mobile-app-intro}.
Перечислим несколько новых приёмов, которые облегчат вашу работу.

\subsubsection*{Приложение целиком}

Избегайте ситуации, когда тест вызывает не приложение, а один из~обработчиков
\coderef{3}:

\begin{english}
  \begin{clojure/lines}
(deftest test-page-handler
  (let [req {:request-method :get}
        res (some-page-handler req)
        {:keys [status]} res]
    (is (= 200 status))))
  \end{clojure/lines}
\end{english}

Даже если страница работает, нет гарантии, что запрос пройдёт сквозь стек
middleware. В боевых проектах он несёт важную логику, в~том числе проверку
доступа. Убрав middleware из теста, вы обманываете себя. Обработчик, который вы
тестируете, должен быть максимально <<заряжен>>, то есть близок к настоящему
приложению.

\subsubsection*{Библиотека запросов}

Выше мы объявили запрос в виде словаря. Это удобно, когда нет параметров или
тела. Если странице нужны параметры, придётся писать их вручную, что нечитаемо и
тяжело в поддержке.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:request-method :get
 :uri
 "/users/?page=2&order=
                 date_added&name=ivan"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:request-method :get
 :uri "/users/?page=2&order=date_added&name=ivan"}
  \end{clojure}
\end{english}

\fi

\index{библиотеки!Ring-mock}

Чтобы избежать ошибок, подключите
\footurl{Ring-mock}{https://github.com/ring-clojure/ring-mock}[Ring\\*mock][1mm]~--- библиотеку
запросов к Ring-приложению. Она покрывает основные сценарии в~тестах. Функция
\verb|request| принимает метод и путь. Если добавить словарь параметров, то
для \verb|GET| они станут частью адреса, а для \verb|POST|~--- его
телом. Библиотека берёт на себя URL-кодирование. Функция \verb|json-body|
подготовит тело с потоком, в который записана коллекция.

Рассмотрим несколько примеров. \verb|GET|-запрос по адресу \verb|/help| :

\begin{english}
  \begin{clojure}
(mock/request :get "/help")
  \end{clojure}
\end{english}

\noindent
Поиск фильмов с параметрами:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(mock/request :get "/movies"
  {:search "batman" :page 1})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(mock/request :get "/movies" {:search "batman" :page 1})
  \end{clojure}
\end{english}

\fi

\index{HTTP!POST}
\index{классы!ByteArrayInputStream}
\index{заголовки!Content-Type}

\noindent
Отправка формы методом POST. Тело запроса станет потоком байт, классом
\verb|ByteArrayInputStream|. Заголовок \verb|Content-Type| примет значение
\verb|application/x-www-form-urlencoded|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(mock/request :post "/users"
  {:name "Ivan" :email "test@test.com"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(mock/request :post "/users"
              {:name "Ivan" :email "test@test.com"})
  \end{clojure}
\end{english}

\fi

\index{HTTP!API}

\noindent
Случай для стороннего API. Ресурс \verb|/users| ожидает не поля формы, а~JSON.
Функция \verb|json-body| дополняет запрос телом и заголовками:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(-> (mock/request :post "/users")
    (mock/json-body
      {:name "Ivan"
       :email "test@test.com"}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(-> (mock/request :post "/users")
    (mock/json-body {:name "Ivan" :email "test@test.com"}))
  \end{clojure}
\end{english}

\fi

\noindent
Эти и другие функции смотрите в документации проекта.

\subsubsection*{Проверка тела}

Выше мы проверяли только статус ответа. На практике статуса недостаточно: число
200 ещё не говорит, что пришло именно то, что нужно. Проверка тела зависит от
его типа. Если это текст или HTML, хватает регулярного выражения. Например, по
фразе Login мы определим, что на этой странице пользователь не авторизован.

\index{форматы!JSON}

Интереснее вариант с JSON, когда мы тестируем API. Нужно восстановить из тела
коллекцию и сравнить с образцом. Обратимся к~приложению \verb|sites-handler|,
которое мы написали в качестве заглушки для поиска кафе \page{sites-handler}.
Выполним к нему запрос:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [request (mock/request
                :get "/search/v1"
                {:lat 11 :lon 22})
      response (sites-handler request)
      body (-> response
               :body
               (json/parse-string
                 true))]
  (is (= {...} body)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [request (mock/request :get "/search/v1"
                            {:lat 11 :lon 22})
      response (sites-handler request)
      body (-> response :body (json/parse-string true))]
  (is (= {...} body)))
  \end{clojure}
\end{english}

\fi

Недостаток в том, что мы сравниваем данные как есть. Некоторые поля ответа
меняются, например даты или \verb|id|. Мы уже выяснили, что \verb|id|~--- это
ключ с автонумерацией. Однажды записи удалят и загрузят повторно, и номера
изменятся.

Перед сравнением лишние поля исключают с помощью \verb|dissoc|
и~\verb|map|. Представим, что поиск кафе вернул результат:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:sites [{:name "Site1"
          :date-updated "2019-11-12"
          :id 42}
         {:name "Site2"
          :date-updated "2019-11-10"
          :id 99}]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:sites [{:name "Site1" :date-updated "2019-11-12" :id 42}
         {:name "Site2" :date-updated "2019-11-10" :id 99}]}
  \end{clojure}
\end{english}

\fi

\index{итерация!for}

\noindent
Напишем функцию, которая очистит тело от лишних полей.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn clean-sites [body]
 (update body :sites
  (fn [sites]
   (for [site sites]
    (dissoc site :id :date-updated)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn clean-sites [body]
  (update body :sites
          (fn [sites]
            (for [site sites]
              (dissoc site :id :date-updated)))))
  \end{clojure}
\end{english}

\fi

\noindent
Теперь данные сравнивают не в лоб, а с помощью функции:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(is (= {:sites [{:name "Site1"}
                {:name "Site2"}]}
       (clean-sites body)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(is (= {:sites [{:name "Site1"} {:name "Site2"}]}
       (clean-sites body)))
  \end{clojure}
\end{english}

\fi

Иногда проверяют не конкретные значения, а структуру ответа. Это удобно, когда в
ответе объёмные списки и словари. В таком случае пользуются спекой или
JSON-схемой. Преимущества спеки в том, что она лояльна к новым полям. Если в
ответ добавили поле, спека не выдаст ошибку.

\index{spec!в тестах}
\index{spec!valid?}
\index{spec!assert}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [response (...) ;; get the response
      body (-> response
               :body
               (json/parse-string
                 true))]
  (is (s/valid? :api.search/result
                body)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [response (...) ;; get the response
      body (-> response :body (json/parse-string true))]
  (is (s/valid? :api.search/result body)))
  \end{clojure}
\end{english}

\fi

Функция \verb|s/valid?| вернёт истину или ложь, что неудобно для тестов. Если
данные неверны, придётся вывести их на экран для расследования. Замените
\verb|s/valid?| на макрос \verb|s/assert|, который бросит исключение. Так
вы сразу увидите данные \verb|explain| в отчёте.

\index{веб-разработка}

Затраты на спеку окупаются в будущем. Ей проверяют входные параметры, генерируют
данные для тестов, описывают REST API (Swagger, RAML).

\section{Тестирование систем}

\index{системы!тестирование}

Коротко о том, как пишут тесты в проектах с системами, о которых мы говорили в
прошлой главе \page{chapter-systems}. Напомним, система~--- это набор компонентов со
связями между ними. Покрыть тестами каждый компонент нетрудно; проблемы
возникают при их взаимодействии. В проекте обязательно должен быть тест, где
система работает как единое целое.

\subsection{Фикстура}

\index{фикстуры!с системой}

Во время тестов кто-то должен запустить систему и остановить её. На эту роль
подходит фикстура. Предположим, система и функции \verb|start!| и \verb|stop!|
находятся в модуле \verb|system.clj|. Напишем фикстуру \verb|fix-system|:

\begin{english}
  \begin{clojure}
(defn fix-system
  [t]
  (system/start!)
  (t)
  (system/stop!))
  \end{clojure}
\end{english}

Внутри теста в переменной \verb|system/system| будет рабочая система. Другие
фикстуры, например для работы с базой, могут обратиться к компонентам
напрямую. Важно, чтобы в \verb|use-fixtures| они шли в~правильном порядке
(левее~--- раньше), иначе получим \verb|NPE| и другие странности. Фикстура ниже
готовит данные в базе для каждого теста:

\index{NPE}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-db-data
  [t]
  (let [{:keys [db]} system/system]
    (prepare-test-data db)
    (t)
    (clear-test-data db)))

(use-fixtures :once
  fix-system fix-db-data)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-db-data
  [t]
  (let [{:keys [db]} system/system]
    (prepare-test-data db)
    (t)
    (clear-test-data db)))

(use-fixtures :once fix-system fix-db-data)
  \end{clojure}
\end{english}

\fi

Фикстура \verb|fix-db-data| нарушает правило, согласно которому к~системе нельзя
обращаться напрямую и вынимать из неё компоненты. В этом плане для тестов
действуют послабления. Тесты~--- это не промышленный код, поэтому на небольшие
нарушения закрывают глаза.

\subsection{Обращение к системе}

Когда система работает, к ней обращаются как к полноценному серверу, а не к~функции.
Чтобы проверить API, мы посылаем настоящий HTTP-запрос и читаем
ответ. Для этого нужна клиентская библиотека. Если сервер проверяет права
доступа, мы должны построить заголовок авторизации и добавить в запрос.

Напишем тест для условного API, которое вернёт заказы пользователя. Чтобы не
обрушить на вас лавину кода, разделим тест на~логические блоки. Сначала добавим
в базу пользователя с открытым и закрытым ключом. Для краткости пропустим
вставку заказов. Результат вставки в~базу неважен, поэтому затеним его
подчёркиванием.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines*}{firstnumber=1}
(deftest test-api-orders-ok
  (let [public-key "my_public_key"
        secret-key "slk6Da7sD2G4g"
        {:keys [db]} system/system
        _ (jdbc/insert! db :users
            {:public_key public-key
             :secret_key secret-key})
  \end{clojure/lines*}
\end{english}

\else

\begin{english}
  \begin{clojure/lines*}{firstnumber=1}
(deftest test-api-orders-ok
  (let [public-key "my_public_key"
        secret-key "slk6Da7sD2G4g"
        {:keys [db]} system/system
        _ (jdbc/insert! db :users {:public_key public-key
                                   :secret_key secret-key})
  \end{clojure/lines*}
\end{english}

\fi

\wavebottom

Предполагается, что внутри теста система уже работает за счёт фикстуры. Её ключ
\verb|db| ссылается на открытое подключение к базе. Далее составим параметры
запроса HTTP. Закрытый ключ не участвует в параметрах~--- с его помощью получим
их отпечаток (хэш) по алгоритму HMAC~SHA256. Если вы забыли, как работает
подпись ключом, вернитесь в начало главы \page{hmac-sha256}. Из отпечатка строим
заголовок авторизации:

\wavetop

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines*}{firstnumber=8}
    params {:command :listOrders
            :public_key public-key
            :ordering "date_created"
            :sort "desc"
            :page 2}
    signature (params->sha256hmac
                params secret-key)
    auth-header (str "HMAC_SHA256="
                  signature)
  \end{clojure/lines*}
\end{english}

\else

\begin{english}
  \begin{clojure/lines*}{firstnumber=7}
        params {:command :listOrders
                :public_key public-key
                :ordering "date_created"
                :sort "desc"
                :page 2}
        signature (params->sha256hmac params secret-key)
        auth-header (str "HMAC_SHA256=" signature)
  \end{clojure/lines*}
\end{english}

\fi

\wavebottom

В третьем блоке мы передаём адрес, параметры и~заголовки в~HTTP-клиент. В~этот
момент происходит настоящий сетевой запрос. Сервер вычисляет сигнатуру и
сравнивает с той, что прислал клиент. Если они равны, получим статус 200 и JSON
с заказами в~теле ответа.

\wavetop

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines*}{firstnumber=17}
    response
    (client/get
      "http://127.0.0.1:8080/api"
      {:query-params params
       :headers {:authentication
                 auth-header}})
    {:keys [status body]} response]
(is (= 200 status))
(is (= {:orders [...]} body))))
  \end{clojure/lines*}
\end{english}

\else

\begin{english}
  \begin{clojure/lines*}{firstnumber=14}
        response (client/get "http://127.0.0.1:8080/api"
                   {:query-params params
                    :headers {:authentication auth-header}})
        {:keys [status body]} response]
    (is (= 200 status))
    (is (= {:orders [...]} body))))
  \end{clojure/lines*}
\end{english}

\fi

Даже в сокращении тест занимает много места. Чтобы улучшить читаемость, выносите
как можно большей действий в фикстуры и~вспомогательные функции. Например,
создание пользователя и~заказов совершенно точно должно быть в фикстуре, иначе
этот код разбредётся по всем тестам. Подготовку запроса (подпись, заголовок)
поместите в~функцию, которая выполнит эти шаги самостоятельно.

\subsection{Состояние}

Фикстура \verb|fix-system| неслучайно стоит под ключом \verb|:once|. Запуск
и остановка системы занимают много времени. В наших интересах прогнать как можно
больше тестов, пока система работает. Если делать это поштучно, процесс
затянется надолго. При запуске теста из CIDER тоже придётся ждать, пока
сработает \verb|fix-system|.

Кажется, что две-три секунды это немного. Но представьте, что работаете над
задачей и запускаете тест раз за разом,~--- подобные паузы
раздражают. Рассмотрим, как избавиться от ожидания.

\index{системы!состояние}
\index{метаданные}

Потребуется два шага. Первый~--- улучшить систему, чтобы она знала о своём
состоянии: включена она сейчас или выключена. Проще всего это сделать полем в
метаданных. Вынесем имя поля в отдельную переменную. Перепишем \verb|start!|,
чтобы в метаданных системы появился флаг со значением \verb|true|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def state-field ::started?)

(defn start! []
  (let [sys
        (-> system
            component/start-system
            (with-meta
              {state-field true}))]
    (alter-var-root
      #'system (constantly sys))))

(defn started? []
  (some-> system meta (get state-field)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def state-field ::started?)

(defn start! []
  (let [sys (-> system
                component/start-system
                (with-meta {state-field true}))]
    (alter-var-root #'system (constantly sys))))

(defn started? []
  (some-> system meta (get state-field)))
  \end{clojure}
\end{english}

\fi

Функция \verb|started?| вернёт флаг из метаданных текущей системы. Аналогично
изменим \verb|stop!|, чтобы флаг становился ложью.

Второй шаг~--- перед тем, как включить систему в фикстуре, проверим, была ли она
уже запущена. Если нет, фикстура работает как обычно: запуск, тест,
остановка. Если система \emph{уже работает}, значит, кто-то сделал это
вручную. В этом случае фикстура только выполнит тест, что гораздо быстрее.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fixture-system [t]
  (let [started-manually?
        (system/started?)]
    (when-not started-manually?
      (start!))
    (t)
    (when-not started-manually?
      (stop!))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fixture-system [t]
  (let [started-manually? (system/started?)]
    (when-not started-manually?
      (start!))
    (t)
    (when-not started-manually?
      (stop!))))
  \end{clojure}
\end{english}

\fi

Выполните в REPL \verb|(system/start!)|. Теперь вызывайте тест сколько угодно
раз~--- система включена постоянно, и не придётся ждать её запуска.

\section{Интеграционные тесты}

\index{тесты!интеграционные}
\index{пирамида тестов}

Не протяжении главы мы постепенно усложняли тесты. С каждым шагом они всё
меньше зависят от технических деталей и делают упор на бизнес-логику. Принцип
называют \footurl{пирамидой тестов}{https://martinfowler.com/bliki/TestPyramid.html}[Test Pyramid].
В её основании юнит-тесты~--- множество отдельных проверок. Поднимаясь к вершине,
мы абстрагируемся от технических деталей. В какой-то момент тестируют не функции,
а всё приложение.

\index{библиотеки!Selenium}
\index{интерфейс}

Каждый уровень требует специальных знаний. Читатель готов к~тому, чтобы
подняться на последний этаж~--- освоить \emph{интеграционное}
тестирование. По-другому его ещё называют UI- или Selenium-тестами в честь
одноимённого фреймворка. В этих тестах запросы шлют не программно, а имитируют
действия человека. Для этого управляют браузером или телефоном: вводят данные в
форму, нажимают кнопку и проверяют, что появились нужные элементы.

Интеграционные тесты работают медленно, потому что включают полный цикл
приложения. Это загрузка страницы, выполнение скриптов, реакция браузера. Если
возникнет ошибка, её трудно расследовать из-за длины цепи. Представьте, что вы
нажали на кнопку, но ничего не произошло. Возможны десятки причин, почему кнопка
не работает, причём как на сервере, так и на клиенте.

Рассмотрим, как писать UI-тесты на Clojure. На этапе подготовки запускают
систему и наполняют базу тестовыми данными. Далее тест берёт контроль над
браузером и командует им. Например, открывает страницу \verb|http://127.0.0.1:8080/|
и щёлкает по ссылкам. В любой момент мы получим адрес страницы, её заголовок
и HTML-код. В тест добавляют формы \verb|(is (= ...))|, чтобы проверить,
на какой странице мы оказались или что видит пользователь.

Тест не всегда обращается именно к локальному серверу. Некоторые тесты пишут для
сервисов, которые развёрнуты в инфраструктуре фирмы. Это так называемые
стейджинги \eng{staging}~--- сервера, которые работают как в промышленном
запуске, но доступны только разработчикам. При их деплое в базу добавляют
специальную учётную запись, которой пользуется интеграционный тест.

Чтобы управлять браузером, нужны драйвер и библиотека к нему. Под драйвером
понимают утилиту командной строки. Когда драйвер запущен, он принимает запросы
по протоколу HTTP. Одновременно драйвер запускает браузер в режиме марионетки, и
между ними образуется связь. Драйвер~--- это посредник между тестом и браузером. Он
переводит HTTP-запросы в бинарный протокол браузера и наоборот.

\index{утилиты!chromedriver}
\index{утилиты!geckodriver}
\index{утилиты!safaridriver}

Каждый браузер работает со своим драйвером. Для Chrome он называется
\verb|chromedriver|, для Firefox~--- \verb|geckodriver|. Одноимённые утилиты
ставятся из пакетных менеджеров \verb|apt|, \verb|yum| или
\verb|brew|. Пользователи Windows скачают бинарные файлы с сайта
проектов. Драйвер к Safari называется \verb|safaridriver|. С версии 13 он
идёт в комплекте с~Mac~OS.

\index{библиотеки!Etaoin}

Для работы с драйвером подойдёт библиотека \footurl{Etaoin}{https://github.com/igrishaev/etaoin}[Etaoin].
Добавьте её в зависимости профиля \verb|:dev| (только для разработки и тестов):

\begin{english}
  \begin{clojure}
:dev {:dependencies [[etaoin "0.3.6"]]}
  \end{clojure}
\end{english}

Убедитесь, что драйвер находится по одному из путей, указанных в~\verb|PATH|,
например \verb|/usr/local/bin|. Для этого выполните \verb|chromedriver| или
\verb|geckodriver| с ключом \verb|--version| в терминале. Другой способ
проверить утилиту~--- вызвать \verb|where| с её именем. Путь до драйвера можно
задать в опциях библиотеки, но проще положить его в \verb|PATH|.

\index{переменные!PATH}

Напишем первый тест. Представим, что локальный сервер работает на порту
8080. Тест открывает форму входа, заполняет поля и~нажимает кнопку
Login. Браузер обновляет страницу, появляется приветствие. Видны элементы
интерфейса, которые прежде были скрыты (ссылки My profile, Logout).


\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(ns project.integration-tests
  (:require [etaoin.api :as e]))

(deftest test-ui-login-ok
  (e/with-chrome {} driver
    (e/go driver
      "http://127.0.0.1:8080/login")
    (e/wait-visible driver
      {:fn/has-text "Login"})
    (e/fill driver
      {:tag :input :name :email}
      "test@test.com")
    (e/fill driver
      {:tag :input :name :password}
      "password")
    (e/click driver
      {:tag :button :fn/text "Login"})
    (e/wait-visible driver
      {:fn/has-text "Welcome"})
    (is (e/visible? driver
          {:tag :a
           :fn/text "My profile"}))
    (is (e/visible? driver
          {:tag :button
           :fn/text "Logout"}))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(ns project.integration-tests
  (:require [etaoin.api :as e]))

(deftest test-ui-login-ok
  (e/with-chrome {} driver
    (e/go driver "http://127.0.0.1:8080/login")
    (e/wait-visible driver {:fn/has-text "Login"})
    (e/fill driver {:tag :input :name :email} "test@test.com")
    (e/fill driver {:tag :input :name :password} "password")
    (e/click driver {:tag :button :fn/text "Login"})
    (e/wait-visible driver {:fn/has-text "Welcome"})
    (is (e/visible? driver {:tag :a :fn/text "My profile"}))
    (is (e/visible? driver {:tag :button :fn/text "Logout"}))))
  \end{clojure}
\end{english}

\fi

Разберём отдельные выражения. Форма \verb|with-chrome|~--- это макрос, который
запускает Chrome на время исполнения кода. Макрос нужен, чтобы выключить драйвер
при выходе или в случае ошибки. Без него пришлось бы добавить
\verb|try/finally|, что порождает вложенность и~в~целом неудобно:

\index{вложенность}
\index{браузеры}

\begin{english}
  \begin{clojure}
(let [driver (e/chrome)]
  (try
    (e/go driver "http://...")
    (e/click driver {:tag :button})
    (finally
      (e/quit driver))))
  \end{clojure}
\end{english}

Выражение \verb|(e/quit driver)| освобождает занятые ресурсы: закрывает окно
браузера и завершает процесс драйвера.

Функция \verb|wait-visible| ждёт до тех пор, пока элемент не появится на
экране. Отрисовка страницы~--- это долгая операция. Из-за особенностей
веб-технологий она может быть медленной даже на мощном железе. Если не отделить
команды ожиданием, между ними будет разница в несколько миллисекунд. Браузер
либо не успеет выполнить первое действие, либо отбросит второе.

Ожидание в UI-тестах встречается часто. Основное время уходит на то, чтобы
получить отклик от системы. \verb|Wait-visible|~--- это лишь одна из семейства
\verb|wait|-функций. В них входят \verb|wait-has-text| (дождаться текст на
экране), \verb|wait-has-class| (ждать, пока у элемента не появится класс) и
другие.

\index{селекторы!CSS}
\index{селекторы!XPath}

Драйвер ищет элементы на странице с помощью \emph{селекторов}. Это выражения на
языках \footurl{CSS}{https://www.w3schools.com/cssref/css\_selectors.asp}[CSS][0mm] и
\footurl{XPath}{https://www.w3schools.com/xml/xpath\_syntax.asp}[XPath][24mm]. Мы не
будем разбирать их синтаксис: это долго и заслуживает отдельной главы.

Для краткости рассмотрим альтернативу: на элемент можно сослаться по
словарю. Ключи \verb|tag| и \verb|id| означают имя тега и идентификатор. Другие
ключи означают атрибуты тега. В примере выше селектор
\spverb|{:tag :input :name :email}| станет строкой
\verb|.//input[@name="email"]| на языке XPath.

\index{языки!XPath}

Ключ \verb|index| ссылается на $i$-й элемент в случаях, когда селектор нашёл их
несколько. Например, \spverb|{:tag :button :index 1}| вырождается
в~\verb|.//button[1]|. Индекс считают от нуля. Ключи с пространством \verb|fn|
особые: они означают вызов функции XPath. Ниже ключ \verb|:fn/has-class|
вызывает \verb|contains| на имени класса. Получим все ссылки, у которых есть
класс active.

\begin{english}
  \begin{clojure}
{:tag :a :fn/has-class "active"}
;; .//a[contains(@class, "active")]
  \end{clojure}
\end{english}

При помощи словаря можно сослаться на любой элемент страницы. Если путь к
элементу слишком сложен, добавьте ему класс или идентификатор. В особых случаях
элемент ищут в рамках другого элемента, чтобы сузить выборку. Эти и другие
случаи описаны в документации к библиотеке.

Наконец, если вы не доверяете браузеру, можно получить текущий HTML функцией
\verb|e/get-source|. Это важное отличие от пункта меню <<показать код
страницы>>, где видно исходный HTML \emph{до начала} работы скриптов. Далее вы
парсите разметку средствами Clojure или Java и выполняете свои проверки. Для
парсинга подойдут библиотеки
\footurl{Hickory}{https://github.com/davidsantiago/hickory}[Hickory][-12mm] и
\footurl{JSoup}{https://jsoup.org}[JSoup][12mm].

\index{HTML}

Наш тест можно улучшить по следующим пунктам.

\textbf{Конфигурация.} Порт 8080 <<захардкожен>> в теле теста. Мы уже знаем, что
подобные значения приходят из конфигурации. Исправьте тест так, чтобы и сервер,
и драйвер работали с одинаковым портом.

\index{фикстуры!with-chrome}

\textbf{Фикстура.} Вспомним, как работает \verb|with-chrome|: он создаёт новый
драйвер, выполняет тело и выключает его. Это напоминает систему: если каждый
тест обёрнут в \verb|with-chrome|, мы теряем время на включение и запуск
драйвера.

Сделаем так, чтобы драйвер работал на протяжении всего прогона. Объявим
динамическую переменную и~фикстуру, которая связывает драйвер на время
тестов. Подключим её с ключом \verb|:once|:

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *driver* nil)

(defn fix-chrome [t]
  (e/with-chrome {...} driver
    (binding [*driver* driver]
      (t))))

(use-fixtures :once fix-chrome)
  \end{clojure}
\end{english}

\textbf{Второй браузер.} Тесты работают в Chrome, но руководство ставит
задачу~--- убедиться, что мы поддерживаем Firefox. Всё, что мы написали для
Chrome, нужно выполнить в другом браузере, при этом код нельзя копировать.

Поможет мультификстура, с которой мы знакомились на середине
главы \page{multi-fixture}. Она пробегает по списку \emph{типов} браузеров,
ключам \verb|:chrome| и~\verb|:firefox|. Макрос \verb|with-driver|~--- это общий
случай \verb|with-chrome|. Отличие в том, что \verb|with-driver| ожидает первым
аргументом тип браузера. На каждом шаге фикстура связывает драйвер
с~динамической переменной и выполняет тест.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-multi-driver [t]
  (doseq [driver-type [:chrome :firefox]]
    (e/with-driver driver-type {} driver
      (binding [*driver* driver]
        (testing (format "Browser %s"
                   (name driver-type))
          (t))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-multi-driver [t]
  (doseq [driver-type [:chrome :firefox]]
    (e/with-driver driver-type {} driver
      (binding [*driver* driver]
        (testing (format "Browser %s" (name driver-type))
          (t))))))
  \end{clojure}
\end{english}

\fi

Тесты сработают в обоих браузерах. Для ясности мы обернули тест сообщением о
том, в каком браузере его вызывают. Чтобы добавить новый браузер, например
Safari, добавьте его ключ в вектор \verb|driver-type|.

\index{фикстуры!обход}

Заметим, что обход тестов и браузеров отличается от типа фикстуры. Если это
\verb|:once|, \emph{все} тесты сработают сначала в Chrome, а потом в~Firefox
(прогон в разрезе браузера). Если \verb|:each|, \emph{каждый} тест сначала
сработает в Chrome, а затем в Firefox (в разрезе теста).

На первый взгляд это ничего не меняет, но со временем видна польза каждого
подхода. Если наша цель~--- убедиться, что тесты проходят в~принципе, выполним набор
сначала в одном браузере, потом в другом. Если работаем над совместимостью,
нужна другая стратегия: брать тесты под одному и проверять во всех
браузерах. Задайте фикстуре нужный тип в зависимости от цели.

\textbf{Пакетные действия.} Ещё один способ улучшить тесты~--- вынести
одинаковые задачи в фикстуру или функцию. Предположим, каждый тест начинается с
авторизации и заканчивается выходом из системы. Чтобы не копировать код этих
действий, напишем фикстуру \verb|fix-login-logout| и зарегистрируем с ключом
\verb|:each|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn fix-login-logout [t]
  (doto *driver*
    (e/go "http://127.0.0.1:8080/login")
    (e/fill {:tag :input :name :email}
      "test@test.com")
    (e/click
      {:tag :button :fn/text "Login"}))
  (t)
  (doto *driver*
    (e/click {:tag :button
              :fn/text "Logout"})
    (e/wait-has-text "Login")))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn fix-login-logout [t]
  (doto *driver*
    (e/go "http://127.0.0.1:8080/login")
    (e/fill {:tag :input
             :name :email} "test@test.com")
    (e/click {:tag :button
              :fn/text "Login"}))
  (t)
  (doto *driver*
    (e/click {:tag :button
              :fn/text "Logout"})
    (e/wait-has-text "Login")))
  \end{clojure}
\end{english}

\fi

Выносите сложные действия в функции. Например, выбор даты в~виджете календаря
может занять до десяти команд. Напишите условную функцию
\verb|set-widget-date|, которая принимает драйвер, селектор поля и дату,
которую нужно ввести.

\index{макросы!doto}

\textbf{Используйте doto.} Когда несколько форм принимают одинаковый первый
аргумент, их объединяют в макрос \verb|doto|. Он подставит \verb|*driver*| на
второе место в каждый список тела. С \verb|doto| код становится короче и
чище. Каждая функция Etaoin принимает драйвер, поэтому их легко группировать в
\verb|doto|.

\section{Другие решения}

Перечислим сторонние библиотеки для тестов. Мы не будем изучать их подробно:
ограничимся кратким описанием и примером. Подробности ищите в документации к
проектам.

\subsection{Продвинутые моки}

\index{библиотеки!Mockery}
\index{моки}

На минуту вернёмся к мокам~--- подмене функций через \verb|with-redefs|. Макрос
слишком многословен, чтобы работать с ним напрямую. Появились библиотеки,
которые описывают мокинг короче и выразительнее. Одна из них называется
\footurl{Mockery}{https://github.com/igrishaev/mockery}[Mockery][-3mm].
Библиотека предлагает макрос \verb|with-mock|:

\begin{english}
  \begin{clojure}
(with-mock mock
  {:target :project.path/get-geo-point
   :return {:lat 14.23 :lng 52.52}}
  (get-geo-point "cafe" "200m"))
  \end{clojure}
\end{english}

Первый аргумент~--- это символ, с которым связано хранилище мока. Ключ \verb|:target|
задаёт путь к объекту, который нужно заменить, а~\verb|:return|~---
результат. Выше мы <<замокали>> функцию \verb|get-geo-point|, которая, судя по
названию, обращается к сервису карт.

Внутри макроса \verb|mock|~--- это атом со словарём. Он наполняется данными по~мере
того, как вызывают цель: сколько раз к ней обратились и с какими
аргументами. Ниже мы добавили проверки, что функцию вызвали один раз с
параметрами cafe и 200m.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [{:keys [called?
              call-count
              call-args]} @mock]
  (is called?)
  (is (= 1 call-count))
  (is (= '("cafe" "200m") call-args)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [{:keys [called? call-count call-args]} @mock]
  (is called?)
  (is (= 1 call-count))
  (is (= '("cafe" "200m") call-args)))
  \end{clojure}
\end{english}

\fi

\index{библиотеки!Spy}

Библиотека \footurl{Spy}{https://github.com/alexanderjamesking/spy}[Spy] работает
по-другому. Одноимённая функция порождает <<шпионскую>> версию исходной. Шпион
ведёт себя как оригинал, но накапливает аргументы и результаты. Вызов исходной
функции не влияет на шпионский клон. Позже шпиона <<допрашивают>> на предмет
того, какие данные он собрал.

\begin{english}
  \begin{clojure}
(require '[spy.core :as spy])

(def spy+ (spy/spy +))
(mapv spy+ [1 2 3] [4 5 6])

(spy/calls spy+)
;; [(1 4) (2 5) (3 6)]
(spy/responses spy+)
;; [5 7 9]
  \end{clojure}
\end{english}

\index{обратные зависимости}
\index{dependency indirection}

\index{die-fn}
\index{функция смерти}

Spy полезен, когда функции передают в параметрах. В широком смысле техника
называется dependency indirection, обратные зависимости. Не старший объект
решает, что вызывать, а наоборот~--- ему говорят, с чем работать.

Предположим, мы пишем тесты на чтение конфигурации с параметром
\verb|:die-fn|. Если ошибок нет, функция смерти не вызывается. Когда
в~конфигурации ошибка, должен быть вызов с~исключением и~меткой. Чтобы написать
тест, в~\verb|load-config| передают шпиона. Он не вызывает исключение, но
фиксирует факт вызова, что позже проверяют в~утверждении.

\begin{english}
  \begin{clojure}
(require '[spy.assert :as assert])

(deftest test-config-error-die-fn-called
  (let [spy-die-fn (spy/spy)]
    (load-config {:program-name :test
                  :spec ::broken-config
                  :die-fn spy-die-fn})
    (assert/called? spy-die-fn)))
  \end{clojure}
\end{english}

Обёртка \verb|spy| может быть без аргументов. В этом случае она вернёт
функцию произвольной арности. Модуль \verb|assert| предлагает макросы для
проверок в тестах: вызвано хотя бы раз, точное число раз, именно с этими
аргументами и так далее. На нижнем уровне они сводятся к~\verb|is| с~понятным
сообщением.

\subsection{Альтернативный синтаксис}

\index{библиотеки!Midje}

Проект \footurl{Midje}{https://github.com/marick/Midje}[Midje] предлагает другой
синтаксис для тестов. В этой библиотеке работают с \emph{фактами}. Факт~--- это
набор проверок, сгруппированных по смыслу. Запишем факты о функции
\verb|split|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(facts "about split"
 (str/split "a/b" #"/") => ["a" "b"]
 (str/split "" #"irrelvant") => [""])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(facts "about split"
 (str/split "a/b/c" #"/") => ["a" "b" "c"]
 (str/split "" #"irrelvant") => [""])
  \end{clojure}
\end{english}

\fi

\index{продвинутое равенство}
\index{extended equality}

Стрелка между выражениями~--- это оператор, который называется extended
equality, продвинутое равенство. От обычного \verb|=| он отличается тем, что
работает с разными типами. С его помощью величины сравнивают короче. Например,
форма \verb|1 => even?| сводится к \verb|(even? 1)|. \verb|Midje| предлагает и
другие, более сложные стрелки для коллекций и~макросов.

\subsection{Вывод XUnit}

\index{библиотеки!Test2junit}

Плагин \footurl{Test2junit}{https://github.com/ruedigergad/test2junit}[Test to~JUnit] пишет отчёт
в файл XML формата XUnit. Системы интеграции вроде CircleCI или Jenkins
отображают его в понятном виде. Графический отчёт легче читать, чем вывод
консоли: ошибки выделены красным, стектрейсы спрятаны под выпадающие
элементы. Добавьте плагин в Lein и задайте путь, куда писать файлы.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:plugins [[test2junit "1.1.2"]]
:test2junit-output-dir
  "target/test2junit"
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:plugins [[test2junit "1.1.2"]]
:test2junit-output-dir "target/test2junit"
  \end{clojure}
\end{english}

\fi

Чтобы использовать плагин, выполните \verb|lein test2junit|. Вы не увидите
обычных сообщений в консоли, потому что теперь они направлены в файл. После
прогона тестов проверьте, что появился XML-отчёт.

Системы интеграции выделяют особую папку, в которой оседают логи и прочие
файлы~--- артефакты. С их помощью расследуют неудачные сборки. Сервер хранит
папку некоторое время, чтобы можно было исследовать её позже. Как правило, путь
к~артефактам указывает переменная среды \verb|CI_ARTEFACTS| или с похожим
именем. Чтобы сохранить отчёт о тестах, скопируйте его вручную после
прогона. Другой способ~--- сразу нацелить плагин на нужный путь в настройках.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
:test2junit-output-dir
  (or (System/getenv "CI_ARTEFACTS")
      "target/test2junit")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
:test2junit-output-dir (or (System/getenv "CI_ARTEFACTS")
                           "target/test2junit")
  \end{clojure}
\end{english}

\fi

\noindent
Убедитесь, что плагин подхватывает переменную:

\ifx\devicetype\mobile

\begin{english}
  \begin{bash}
$ CI_ARTEFACTS=/some/custom/path \
    lein test2junit
  \end{bash}
\end{english}

\else

\begin{english}
  \begin{bash}
$ CI_ARTEFACTS=/some/custom/path lein test2junit
  \end{bash}
\end{english}

\fi

\subsection{Генерация данных}

\index{библиотеки!Test.check}
\index{генерация данных}
\index{spec!gen}

Иногда тестам нужен большой объём данных: сто, двести тысяч записей или
миллион. При этом данные должны быть разнообразны~--- не подойдёт один и тот же
набор, загруженный тысячу раз. Поможет библиотека
\footurl{Test.check}{https://github.com/clojure/test.check}[Test check][-5mm]. Модуль \verb|gen|
производит случайные данные по заданным правилам. Особенно полезна генерация
записей. Объявим пользователя с тремя полями:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defrecord User
  [user-name user-id active?])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defrecord User [user-name user-id active?])
  \end{clojure}
\end{english}

\fi

Чтобы получить случайную запись, нужно произвести три случайных величины и
передать в конструктор \verb|->User|. Модуль предлагает всевозможные генераторы
и их комбинации. Нас устроит кортеж из непустой строки, натурального числа и
булева:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
 '[clojure.test.check.generators
   :as gen])

(def gen-fields
  (gen/tuple
    (gen/not-empty
      gen/string-alphanumeric)
    gen/nat
    gen/boolean))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.test.check.generators :as gen])

(def gen-fields
  (gen/tuple (gen/not-empty gen/string-alphanumeric)
             gen/nat
             gen/boolean))
  \end{clojure}
\end{english}

\fi

Когда генератор готов, из него получают данные:

\begin{english}
  \begin{clojure}
(gen/generate gen-fields)
["rw2AJ124fm9w91La3M58Bqt5" 14 true]
  \end{clojure}
\end{english}

\noindent
Каждый вызов порождает новый вектор. Чтобы получить запись, усложним выражение:

\begin{english}
  \begin{clojure}
(apply ->User (gen/generate gen-fields))
#user.User{:user-name "dfgJKSHF3"
           :user-id 7
           :active? true}
  \end{clojure}
\end{english}

Spec, которой мы посвятили главу \page{chapter-spec}, идёт ещё дальше. Она
предлагает генераторы на базе Test.check, где шаблоны задают
спекой. Раскрывается ещё одно свойство спек: кроме проверки, они подходят для
тестовых данных. Предположим, мы задали пользователя с~тремя полями:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :user/id int?)
(s/def :user/name string?)
(s/def :user/active? boolean?)

(s/def ::user
  (s/keys :req-un [:user/id
                   :user/name
                   :user/active?]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :user/id int?)
(s/def :user/name string?)
(s/def :user/active? boolean?)

(s/def ::user (s/keys :req-un [:user/id
                               :user/name
                               :user/active?]))
  \end{clojure}
\end{english}

\fi

\noindent
Функция \verb|s/gen| строит по спеке генератор. Пример его работы:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(gen/generate (s/gen ::user))
{:id 88546920
 :name "Z4MO7GH80k3mRD"
 :active? true}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(gen/generate (s/gen ::user))
{:id 88546920, :name "Z4MO7GH80k3mRD", :active? true}
  \end{clojure}
\end{english}

\fi

Вместо случайных величин можно задать варианты (список имён, фамилий,
городов). Сейчас имя пользователя~--- это машинная строка, что некрасиво. Поменяем
спеку \verb|:user/name| на множество имён. Когда множество большое, его выносят
в ресурс EDN и читают при загрузке модуля.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :user/name
  #{"Ivan" "Juan" "Huan" "Ioann"})

{:id 274 :name "Juan" :active? true}
{:id 557 :name "Huan" :active? true}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :user/name #{"Ivan" "Juan" "Huan" "Ioann"})

{:id 274 :name "Juan" :active? true}
{:id 557 :name "Huan" :active? true}
  \end{clojure}
\end{english}

\fi

Возможности Spec обширны. С её помощью порождают связанные данные, например
пользователей, которые ссылаются на профили, и~наоборот. Спеки могут быть любой
вложенности, что открывает поле для экспериментов. В особых случаях спеке
сообщают свой алгоритм генерации. К нему прибегают, если спека очень сложна и
стандартный алгоритм не может подобрать данные.

\section{Заключение}

Тест~--- это код, который проверяет другой код. Тест защищает проект от
неоговорённых изменений. Без тестов появляется эффект бабочки: правка в одном
месте ломает другое.

\index{покрытие}

Различают несколько видов тестов. В основном работают с юнит-тестами, которые
ещё называют модульными. Они проверяют функции из одноимённого пространства. С
юнит-тестами связан термин <<покрытие>>. Это доля кода, который сработал во
время тестов. При анализе покрытия смотрят не только величину в
процентах. Важно, чтобы все ветки алгоритма приняли участие.

Чтобы подготовить тест к запуску, применяют фикстуры. Это функции, которые
вызывают тест до или после каких-то действий. Различают одно- и многоразовые
фикстуры, \verb|:once| и \verb|:each|. Фикстуры разнообразны: это может быть
запись в базу, локальный сервер, система компонентов. Иногда фикстура вызывает
тест несколько раз в цикле.

Чтобы выполнить часть тестов, нужны теги и селекторы. Тег~--- это поле метаданных
теста. Селектор~--- функция, которая принимает метаданные и возвращает истину
или ложь. Тесты группируют в~наборы, потому что не всегда можно выполнить их все
в текущем окружении. Поскольку кейворд ведёт себя как функция, селектор и
тег чаще всего совпадают.

Если код обращается в сеть, помогут моки и стабы. Мок~--- это подмена кода в момент
исполнения. Например, функцию \verb|get-events| заменяют на
\verb|(constantly {...})| с известными данными. Стаб~--- это полноценный сервер на
локальном порту. Функцию \verb|get-events| нацеливают на локальный хост с
помощью конфигурации. Сервер отдаёт данные, которые скопировали из настоящего
источника. Чтобы не засорять код большими словарями, их выносят в ресурсы.

Ресурсы~--- это файлы в одноимённой папке проекта. У них особая роль: при сборке они
попадают в архив jar. Проект настраивают так, что в режиме тестов видны
дополнительные пути для их поиска. Убедитесь, что при сборке \verb|uberjar| в
него не попали данные для тестов.

Негативные сценарии важны в той же степени, что и позитивные. Проверяйте
неверные параметры и права доступа. Чтобы не повторяться, выносите повторы в
списки и пробегайте по ним в \verb|doseq|. Если вы \emph{ожидали} ошибку, но
её не было, это \emph{тоже} ошибка. Для таких ситуаций служит
макрос \verb|(is (thrown?...))|.

Интеграционные тесты проверяют программу целиком. Они имитируют действия
человека, поэтому занимают больше времени. Тест управляет браузером или
телефоном. Типичный сценарий теста~--- нажать на элемент и проверить, что
появился или исчез другой элемент. Интеграционные тесты д\'{о}роги в поддержке,
поэтому их пишут в~последнюю очередь.

Clojure предлагает различные библиотеки и утилиты для тестов. Из коробки
доступен Clojure.test, базовый фреймворк. Утилита Lein содержит команду для
прогона тестов. Сторонники Deps.edn пользуются Test-runner. Другие решения
меняют синтаксис тестов, отчётность, упрощают подмену функций.

Не злоупотребляйте библиотеками. Перед тем как браться за них, убедитесь, что
выжали всё из стандартного фреймворка.
