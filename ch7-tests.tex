\chapter{Тесты}

\index{тесты}

\label{chapter-tests}

\begin{teaser}
В последней главе мы поговорим о тестировании кода. Читатель узнает, что такое
тесты и каких видов они бывают. Обойдёмся без лишней сложности: опустим
термины вроде TDD и BDT. Покажем, что в~Clojure легко писать и
поддерживать тесты.
\end{teaser}

\section{Основные понятия}

На тему тестов написано много книг и статей, придуманы методологии. Их
сторонники отстаивают позиции в долгих спорах. Начинающих сбивает с толку
фрагментация терминов и мнений. Чтобы погрузиться в тему, расскажем о тестах
простыми словами.

\index{температура!по Цельсию}
\index{температура!по Фаренгейту}

Тест~--- это код, который проверяет другой код. Пусть мы написали функцию для
перевода температуры из Цельсия в Фаренгейта:

\begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
\end{clojure}

\index{функции!\arr{}fahr}

Мы вызвали её несколько раз и убедились, что результаты такие же, как в
справочнике. Зафиксируем расчёты в функции проверки. Она сравнивает вызов
\code{->fahr} с каноничными значениями. Их посчитали заранее и расценивают как
эталон.

\begin{clojure}
(defn test-fahr []
  (assert (=  68 (int (->fahr 20))))
  (assert (= 212 (int (->fahr 100)))))
\end{clojure}

\index{числа!целые}
\index{числа!с плавающей запятой}

Примечание: в тесте мы сравниваем результат \code{->fahr} с целым числом. Без
обёртки в \code{(int ...)} функция вернёт число с плавающей запятой, которое
\footurl{не всегда равно}{https://en.wikipedia.org/wiki/Floating-point\_arithmetic}[Floating point]
другому такому же числу. Для удобства значение приводят к целому.

Макрос \code{assert} бросит исключение, если тело вычисляется в ложь. Пока что
\code{(test-fahr)} работает без ошибок, потому что расчёты верны. Если изменить
формулу, получим исключение:

\ifnarrow

\begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.9) 32)) ;; 1.8 -> 1.9

(test-fahr)
;; Assert failed:
;; (= (int (->fahr 20)) 68)
\end{clojure}

\else

\begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.9) 32)) ;; 1.8 -> 1.9

(test-fahr)
;; Assert failed: (= (int (->fahr 20)) 68)
\end{clojure}

\fi

Функция \code{test-fahr} и есть тест. Она проверяет, что код \code{->fahr}
не изменили так, что получится другой результат. В наших интересах вызвать
\code{(test-fahr)} перед сборкой программы. Так мы не допустим, чтобы код с
ошибкой попал в производство.

\index{факториал}

Тест не знает устройства функции, которую проверяет. Мы вправе менять алгоритм
до тех пор, пока тест работает без ошибок. Предположим, мы тестируем функцию
факториала. В первой версии мы линейно умножаем числа, что неэффективно. Но уже
на этой стадии добавим тест, что $5! = 120$.

\begin{clojure}
(defn fact [n]
  (reduce * (range 1 (inc n))))

(defn test-fact []
  (assert (= 120 (fact 5))))
\end{clojure}

Если заменить линейный алгоритм на дерево или таблицу значений, тест пройдёт без
ошибок. В противном случае это значит, что в новом алгоритме ошибка.

\begin{clojure}
(defn fact [n]
  (case n
    1 1
    2 2
    3 6
    4 24
    5 120))

(test-fact) ;; no errors
\end{clojure}

\subsection{Кейсы и покрытие}

\index{тесты!кейсы}

Близкие по семантике тесты объединяются в кейсы \eng{набор, вариант}. Вспомним
школьную задачу с квадратным уравнением: найти корни по заданным коэффициентам
$a$, $b$, $c$. Особенность задачи в том, что её логика ветвится. В~зависимости
от параметров может быть два корня, один или ни одного.

\index{квадратное уравнение}

\ifnarrow

\begin{clojure}
(defn square-roots [a b c]
  (let [D (- (* b b) (* 4 a c))]
    (cond
      (pos? D)
      [(/ (+ (- b) (Math/sqrt D))
          (* 2 a))
       (/ (- (- b) (Math/sqrt D))
          (* 2 a))]
      (zero? D) [(/ (- b) (* 2 a))]
      (neg? D) nil)))
\end{clojure}

\else

\begin{clojure}
(defn square-roots [a b c]
  (let [D (- (* b b) (* 4 a c))]
    (cond
      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
      (zero? D) [(/ (- b) (* 2 a))]
      (neg? D) nil)))
\end{clojure}

\fi

\index{функции!square-roots}

Чтобы проверить алгоритм, тест вызывает функцию \code{square\-/roots} минимум три
раза. Подберём параметры так, чтобы сработала каждая ветка. Ещё лучше, если на
каждую ветку приходится отдельный тест, чтобы расширить его в будущем. Тесты ниже
образуют кейс, который проверяет алгоритм целиком.

\ifnarrow

\begin{clojure}
(defn test-square-roots-two-roots []
  (let [[x1 x2] (square-roots 1 -5 6)]
    (assert
      (= [3 2]
         [(int x1) (int x2)]))))

(defn test-square-roots-one-root []
  (let [[x1 x2] (square-roots 1 6 9)]
    (assert (= [-3] [(int x1)]))
    (assert (nil? x2))))

(defn test-square-roots-no-roots []
  (assert (nil? (square-roots 2 4 7))))
\end{clojure}

\else

\ifafive

\begin{clojure}
(defn test-square-roots-two-roots []
  (let [[x1 x2] (square-roots 1 -5 6)]
    (assert (= [3 2] [(int x1) (int x2)]))))
\end{clojure}

\pagebreakafive

\begin{clojure}
(defn test-square-roots-one-root []
  (let [[x1 x2] (square-roots 1 6 9)]
    (assert (= [-3] [(int x1)]))
    (assert (nil? x2))))

(defn test-square-roots-no-roots []
  (assert (nil? (square-roots 2 4 7))))
\end{clojure}

\else

\begin{clojure}
(defn test-square-roots-two-roots []
  (let [[x1 x2] (square-roots 1 -5 6)]
    (assert (= [3 2] [(int x1) (int x2)]))))

(defn test-square-roots-one-root []
  (let [[x1 x2] (square-roots 1 6 9)]
    (assert (= [-3] [(int x1)]))
    (assert (nil? x2))))

(defn test-square-roots-no-roots []
  (assert (nil? (square-roots 2 4 7))))
\end{clojure}

\fi

\fi

В объектно-ориентированных языках кейсы~--- это классы, а тесты~--- их методы. В
Clojure более простой подход: тест~--- это функция, а роль кейса играет
пространство.

\index{покрытие}

В тестах часто упоминают \emph{покрытие}. Так называют долю кода, которая
сработала в тесте. Фреймворк считает общее число строк и сколько из них
выполнились. Покрытие~--- это отношение второй величины к первой, число от нуля
до единицы.

Предположим, мы написали тест только для двух корней. В этом случае ветки
\code{(zero? D)} и \code{(neg? D)} не сработают, и доля покрытия уменьшится.

Некоторые библиотеки строят отчёт, где выполненные строки отмечены зелёным
(плюсом), а пропущенные~--- красным (минусом). Подсчёт покрытия~--- трудная
задача, поэтому её выносят в расширение фреймворка. Для нашего случая мы
получили бы вывод:

\ifnarrow

\begin{diff}
+(defn square-roots [a b c]
+  (let [D (- (* b b) (* 4 a c))]
+    (cond
+      (pos? D)
+      [(/ (+ (- b) (Math/sqrt D))
+          (* 2 a))
+       (/ (- (- b) (Math/sqrt D))
+          (* 2 a))]
-      (zero? D) [(/ (- b) (* 2 a))]
-      (neg? D) nil)))
\end{diff}

\else

\begin{diff}
+(defn square-roots [a b c]
+  (let [D (- (* b b) (* 4 a c))]
+    (cond
+      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
+                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
-      (zero? D) [(/ (- b) (* 2 a))]
-      (neg? D) nil)))
\end{diff}

\fi

\ifnarrow

\def\covperc{80\%}

\else

\def\covperc{71\%}

\fi

\ifnarrow
В функции \code{square-roots} десять строк. При запуске теста сработали восемь из
них. Покрытие составит 8/10, что дает \covperc. Считается, что покрытия
90\% достаточно, чтобы код работал надёжно. Значения ниже говорят о малом
покрытии. Это значит, в проекте встречается код без защиты от спонтанных
изменений. При попытке приблизиться к~100\% тесты становятся затратными в
поддержке. В~каждой команде следуют той величине, которая удобна процессу.
\else
В функции \code{square-roots} семь строк. При запуске теста сработали пять из
них. Покрытие составит 5/7, что приблизительно \covperc. Считается, что покрытия
90\% достаточно, чтобы код работал надёжно. Значения ниже говорят о малом
покрытии. Это значит, в проекте встречается код без защиты от спонтанных
изменений. При попытке приблизиться к~100\% тесты становятся затратными в
поддержке. В~каждой команде следуют той величине, которая удобна процессу.
\fi

Величина в процентах не должна затмевать здравый смысл. Цифра \covperc кажется
большой только на первый взгляд. Из покрытия видно, что мы проверяем лишь одну
ветку алгоритма из трёх. Если в двух других ошибки, мы не узнаем о них. При
оценке покрытия смотрят не на проценты, а на развилки алгоритма. Надёжный тест
гарантирует, что сработала каждая ветка.

\subsection{Не только числа}

У начинающих складывается мнение, что тесты пишут только для математических
расчётов. На самом деле тесты подходят для всех действий, которые хотят
зафиксировать. Это может быть обход коллекции, криптография, поиск в тексте.

Рассмотрим подпись HTTP-запроса. Функция \code{sign-params} принимает словарь
параметров и секретный ключ. Алгоритм подписи следующий:

\begin{itemize}

\index{HMAC-SHA256}

\item
  отсортировать параметры по ключам;

\item
  составить строку \code{param1=value1\&param2\-=va\-lue2...};

\item
  экранировать пробел, процент и другие служебные символы;

\item
  получить сигнатуру строки по алгоритму \code{HMAC-SHA256} и секретному ключу;

\item
  вернуть словарь параметров с полем \code{:sig\-na\-tu\-re}.

\end{itemize}

\index{сигнатура}

Так работает авторизация в популярных сервисах. Напишем тест для функции
подписи. Проверим, что входные параметры дополнены сигнатурой, которую посчитали
заранее.

\ifafive\vspace{15mm}\pagebreak[4]\fi

\label{hmac-sha256}

\ifnarrow

\begin{clojure}
(defn test-sign-params []
  (let [public-key "2Ag48776s634Tsdf"
        secret-key "fnsd809SDf2dfs3t"
        params
        {:api_key public-key
         :action :postComment
         :post_id 217
         :comment
         "This is a great article!"}
        signature "01b03dbf1fa5a4c5"]
    (assert
      (= (assoc params
           :signature signature)
         (sign-params params
           secret-key)))))
\end{clojure}

\else

\begin{clojure}
(defn test-sign-params []
  (let [public-key "2Ag48776s634Tsdf"
        secret-key "fnsd809SDf2dfs3t"
        params {:api_key public-key
                :action :postComment
                :post_id 217
                :comment "This is a great article!"}
        signature "01b03dbf1fa5a4c5"]
    (assert (= (assoc params :signature signature)
               (sign-params params secret-key)))))
\end{clojure}

\fi

Заметим, что \code{sign-params} работает не с числами, а с коллекциями
и~криптографией. Это не помешало написать для неё тест. Чтобы улучшить нашу
работу, добавьте проверку на пустой ключ, экранирование символов, кириллицу,
эмодзи и так далее.

\subsection{Что тестировать}

Иногда разработчики не понимают, какие функции нужно проверить, и~тестов не
хватает. Другая крайность~--- писать тесты строго для каждой функции. Это
приводит к их избыточности и замедляет разработку.

Подпись запроса состоит из мелких функций: сортировки, экранирования и слияния
строк. Если проверять каждый шаг, получится слишком много кода. В будущем
алгоритм нельзя будет оптимизировать без изменений в тестах.

И наоборот, когда тестируют огромный пласт кода, трудно понять, почему возникла
ошибка. Предположим, мы послали серверу запрос, но получили ответ 500. Этот тест
слишком хрупкий: малейшее изменение рушит его. Крупные тесты разбивают на
несколько поменьше.

Верное решение, как всегда, посередине. Тестируйте действия, которые атомарны с
точки зрения логики. Подпись запроса~--- один из шагов по взаимодействию с
сервером. Для успешной работы хватит и того, что он возвращает верные данные без
оглядки на технические детали.

\index{пирамида тестов}

Подробнее на вопрос о том, что и как тестировать, отвечает
\footurl{пирамида тестов}{https://martinfowler.com/bliki/TestPyramid.html}[Test Pyramid].
Это модель, где тесты разделены на слои. У каждого слоя своя семантика. Чем выше
слой, тем больше логики он покрывает. Говорить о пирамиде сейчас преждевременно; мы
вернёмся к ней ближе к концу главы.

\subsection{О чистоте функций}

\index{чистые функции}

Функцию удобно тестировать, если у неё нет побочных эффектов. Это значит, что
функция не обращается к диску, сети и глобальным переменным. Результат зависит
только от входных параметров. Случайное число и~текущая дата тоже считаются
побочными эффектами.

Пусть функция читает файл. Перед запуском теста мы пишем файл в нужное место, а
потом удаляем его. Тест становится сложнее, потому что теперь зависит от
окружения. Чтобы облегчить тестирование, функцию разделяют на две: первая читает
содержимое файла и передаёт во вторую. До исправления:

\index{форматы!CSV}

\ifnarrow

\begin{clojure}
(require '[clojure.string :as str])

(defn process-csv [path]
  (let [content (slurp path)]
    (for [line (str/split content #"\n")]
      (remap-line line))))
\end{clojure}

\else

\begin{clojure}
(require '[clojure.string :as str])

(defn process-csv [path]
  (let [content (slurp path)]
    (for [line (str/split content #"\n")]
      (remap-line line))))
\end{clojure}

\fi

\noindent
и после:

\ifnarrow

\begin{clojure}
(defn process-csv-content [content]
  (for [line (str/split content #"\n")]
    (remap-line line)))

(defn process-csv [path]
  (process-csv-content (slurp path)))
\end{clojure}

\else

\begin{clojure}
(defn process-csv-content [content]
  (for [line (str/split content #"\n")]
    (remap-line line)))

(defn process-csv [path]
  (process-csv-content (slurp path)))
\end{clojure}

\fi

Напишем тест для \code{process-csv-content}. Это будет проще, потому что не
нужно создавать файл на диске. Функция принимает строку, которую объявим на
месте.

\ifnarrow

\begin{clojure}
(def CONTENT
  (str "Ivan;ivan@test.ru;"
       "http://example.ru"
       \newline
       "John;john@test.com;"
       "http://example.com"))

(assert
  (= [{:name "Ivan" :email ...}
      {:name "John" :email ...}]
     (process-csv-content CONTENT)))
\end{clojure}

\else

\begin{clojure}
(def CONTENT
  (str "Ivan;ivan@test.ru;http://example.ru"
       \newline
       "John;john@test.com;http://example.com"))

(assert (= [{:name "Ivan" :email ...}
            {:name "John" :email ...}]
           (process-csv-content CONTENT)))
\end{clojure}

\fi

Другой способ в том, чтобы заменить функцию на мультиметод. Его реализация
зависит от первого аргумента. Если это файл, читаем его и вызываем мультиметод
повторно со строкой. Для строки запускаем логику её разбора.

Чистая функция~--- идеальный случай тестирования. Промышленный код трудно
изолировать от побочных эффектов, а иногда это невозможно. Чтобы тестировать код
с эффектами, прибегают к расширенным практикам: используют заглушки (стабы),
меняют объекты в~рантайме (моки). Мы рассмотрим эти и другие приёмы ниже.

Подмена среды~--- это вынужденная мера, и к ней прибегают в последнюю
очередь. Для начала проверьте, можно ли выделить в коде чистую часть и~насколько
это затратно. Вероятно, небольшое изменение в коде упростит тесты. И
наоборот~--- если код плохо поддаётся тестированию, это говорит о его неудачной
структуре.

\subsection{Производство}

\index{сервисы!GitHub}
\index{сервисы!CircleCI}
\index{сервисы!Slack}

Тесты не только проверяют логику, но и помогают на разных стадиях
производства. Ветку с изменениями нельзя слить в мастер до тех пор, пока не
пройдут тесты. Так вы обезопасите код от случайных изменений.

Если разработчик добавил код без тестов, это снизит долю покрытия. Можно задать
правило, что при покрытии ниже порога слияние запрещено. GitHub, CircleCI и
другие сервисы гибко реагируют на ошибки в тестах. Они шлют письма, пишут
сообщения в чат, всячески сигналят о проблеме.

Иногда тесты заменяют документацию. В открытых проектах её нехватку компенсируют
тестами, потому что на качественный текст уходит столько же времени, сколько на
разработку. Если вы не уверены, как работает функция, возможно, её поведение
прояснится из тестов.

\subsection{Устройство тестов}

Функция с макросом \code{assert} не дотягивает до полноценного теста. Это
приближение, которое пригодится на раннем этапе, когда автор только обозначил
контуры программы. Для полноценных тестов понадобится фреймворк~--- библиотека,
которая определяет, где и как писать тесты.

Если выполнить команду \code{lein test} в папке проекта, запустится тестовый
фреймворк. Это сложный цикл из нескольких шагов. Рассмотрим основные из них,
чтобы читатель понял его устройство.

На первом этапе фреймворк ищет тесты в коде проекта. По-другому этап называется
test discovery. Каждый найденный тест попадает в~глобальный реестр.

Тест должен носить признак, которым он отличается от обычной функции. В примере
выше \code{test-sign-params}~--- это именно функция, а~не тест (префикс \code{test-}
ни на что не влияет). Далее мы рассмотрим, как превратить её в тест.

Когда тесты найдены, система определяет, какие из них вызывать. Если не заданы
фильтры, сработают все тесты. Иногда нужно выполнить их подмножество по имени
или тегу. В этом случае происходит отбор тестов.

На этапе прогона фреймворк выполняет тесты один за другим как функции. Система
фиксирует их количество и имена. Тест обёрнут в~\code{try/catch}, чтобы
исключение не остановило процесс. Каждое утверждение (то, что мы помещаем в
\code{assert}) оседает в накопителе. Эти сведения нужны, чтобы построить отчёт.

На этапе отчёта система выводит данные в консоль для анализа. Отчёт должен быть
понятен человеку. Проблемные тесты обозначены красным цветом. Для неудачных
утверждений ожидают их полные формы, а не финальные значения. Например,
\code{(= (int (->fahr 20)) 68)} вместо \code{(= 69 68)}.

Фреймворк выводит отчёт в разных форматах. Кроме консоли это может быть файл
HTML, богатый на визуальные средства. Систему настраивают так, что отчёт
попадает на сервер по адресу \code{/<project>/<arti\-fact>/tests.html}. Часть
\code{<artifact>}~--- это имя ветки или хэш коммита.

Стандарт XUnit определяет, как записать отчёт в XML-файл. Системы вроде TeamCity
и CircleCI понимают, как показать его в удобном виде. У вас могут быть тесты на
Python, JavaScript или Clojure, но если прогон запущен с флагом \code{--xunit}
(или подобным), отчёты будут похожи.

Это был поверхностный обзор того, как работает тестовый фреймворк. Далее мы
рассмотрим, как управлять каждым его шагом.

\subsection{Типы тестов}

\index{тесты!модульные}

Прежде чем писать тесты, разберёмся, каких видов они бывают. Возможно, читатель
слышал термины <<юнит>>, <<интеграционные>> и другие. На первый взгляд, это
излишняя классификация. На практике тесты из разных категорий отличаются стилем,
окружением и запуском.

Понятие <<юнит-тест>> происходит от английского unit~--- модуль. Термин пришёл
из мира Java и фреймворка JUnit. Согласно ему, тесты группируют по модулям. На
каждый модуль приложения приходится одноимённый тестовый, который его проверяет.

\textbf{Юнит-тесты} фиксируют логику приложения. Это базовые, самые необходимые
тесты. Они поощряют чистые функции: чем меньше требований к окружению, тем проще
с ними работать. Юнит-тесты проверяют код по частям. Примеры с температурой и
уравнением были юнит-тестами.

\index{тесты!интеграционные}

\textbf{Интеграционные тесты} решают проблему, с которой не справляются
юнит-тесты. Даже если мы проверим отдельные части, это не значит, что они
согласованы друг с другом. Рассмотрим регистрацию на сайте. Это сложный процесс
из нескольких шагов:

\begin{itemize}

\item
  проверить, что почта ещё не занята;

\item
  создать временную учётную запись;

\item
  сгенерировать ссылку для подтверждения записи;

\item
  отправить письмо со ссылкой;

\item
  получить с почтового сервера последнее письмо;

\item
  найти в нём ссылку и перейти по ней;

\item
  проверить, что ссылка не подделана и не устарела;

\item
  активировать учётную запись.

\end{itemize}

Очевидно, в этом сценарии замешаны база данных, почтовый сервер и интерфейс, что
выходит за рамки обычных тестов. Интеграционные тесты выполняют в среде,
максимально близкой к реальности. Это главное отличие от юнит-тестов: в первом
случае окружение сужают, во втором расширяют. Интеграционные тесты сложнее
организовать из-за обширного состояния. Например, если выполнить тест ещё раз
без очистки базы, пользователь уже будет в системе, и сценарий не пройдёт.

Ошибки в интеграционных тестах требуют глубокого исследования. Юнит-тесты
выводят отчёт, где ясно указано, какое выражение не равно чему. В интеграционных
тестах причина чаще всего скрыта. После нажатия на кнопку мы ожидали увидеть
текст, но он не появился. Была ли это ошибка на сервере?  Пользователь уже
существует? Не заполнили нужное поле? Текст изменился, и селектор его не
находит? Ответ требует внимания человека.

\index{тесты!нагрузочные}

Чтобы проверить проект под нагрузкой, прибегают к \textbf{нагрузочному тестированию}.
Приложению посылают запросы и считают время ответа, число запросов, сколько
из них параллельны, потребление процессора и памяти. По этим данным строят
отчёты и графики.

\index{фичи}

Нагрузочное тестирование находит медленные части в проекте. С~помощью него
проверяют, насколько <<фича>> готова к запуску. Если боевой сервер держит сто
запросов в секунду, а новый раздел только двадцать, его отправят на доработку.

К другим типам относятся Smoke-, Sanity-, регрессионные тесты и~другие. Мы не
ставим цель рассмотреть их все. В этой главе мы изучим две основные
категории~--- юнит- и интеграционные тесты. К концу книги читателю хватит
знаний, чтобы разобрать другие методики самостоятельно.

\section{Тесты в Clojure}

Напишем тесты, которые отвечают требованиям фреймворка Clojure. За основу
возьмём функции температуры и квадратного уравнения, которые подготовили
выше. Пусть функция \code{->fahr} находится в модуле
\code{src/book/util\-.clj}. Создайте файл \code{test/book/util\_test.clj} с кодом:

\index{clojure.test!deftest}
\index{clojure.test!is}

\ifnarrow

\begin{clojure}
(ns book.util-test
  (:require
   [book.util :refer [->fahr]]
   [clojure.test :refer
    [deftest testing is]]))

(deftest test-fahr
  (is (= 68 (int (->fahr 20))))
  (is (= 212 (int (->fahr 100)))))
\end{clojure}

\else

\begin{clojure}
(ns book.util-test
  (:require
    [book.util :refer [->fahr]]
    [clojure.test :refer [deftest testing is]]))

(deftest test-fahr
  (is (= 68 (int (->fahr 20))))
  (is (= 212 (int (->fahr 100)))))
\end{clojure}

\fi

Получился тестовый модуль. Он импортирует \code{->fahr} и объявляет тест
\code{test-fahr}. Макросы \code{is} и \code{deftest} приходят из пакета
\code{clojure.test}. Это тестовый фреймворк из поставки Clojure.

Шесть строк несут много новой информации, и у читателя появятся вопросы. Почему
тесты лежат в папке \code{test}, а не \code{src}? Разве не логично хранить тесты
рядом с тем, что они проверяют? Как система найдёт их?  Почему тест объявляют
макросом \code{deftest}? Если мы говорили, что тест~--- функция, то зачем
макрос? Почему \code{assert} заменили на \code{is}? Это правильные вопросы, и мы
ответим на них по порядку.

В Clojure разделяют код приложения и тестов. Приложение находится в папке
\code{src}, а тесты~--- в \code{test}. У подхода несколько
преимуществ. Во-первых, код делится на смысловые части. Чтобы найти неисправный
тест, мы сужаем область поиска до папки \code{test}, а не ищем по всему
проекту. Во-вторых, когда тесты отделены, снижается риск, что они попадут в
скомпилированный файл. В этом нет смысла, потому что тесты запускают только в
разработке. Иначе напрасно увеличим время сборки и объём файла.

При запуске проект учитывает параметр, который определяет, где искать код. По
умолчанию это вектор с одним значением~--- строкой \code{"src"}. В режиме тестов
система добавляет к нему путь \code{"test"}. Когда компилятор ищет файлы, он по
очереди обходит пути из списка. Позже мы узнаем, как настроить список под нужды
проекта.

\index{метаданные!в тестах}

Фреймворку нужен признак, по которому он отличит тест от обычной функции. Эту
задачу решает макрос \code{deftest}. Он объявляет функцию и сообщает ей
метаданные с полем \code{:test}. Чтобы найти тесты, фреймворк сканирует модули
и~читает метаданные каждой переменной. Если среди полей есть \code{:test},
переменная считается тестом.

Заметим, что \code{deftest} не позволит задать аргументы теста. Это сделано
нарочно: в Clojure тест не зависит от внешних данных. Если тесту нужно особое
окружение, его задают фикстурами. Мы рассмотрим фикстуры в отдельном разделе.

Макрос \code{is} отличается от \code{assert} побочными
эффектами. \code{As\-sert}~--- это чистое сравнение: получим либо \code{nil}, либо
исключение. Макрос \code{is} считает, сколько раз и с какими аргументами его
вызвали. Позже из этих данных фреймворк строит отчёт. Например, покажет все
выражения, которые не прошли проверку.

\subsection{Командная строка}

Мы только написали тест, но не запустили его. Clojure предлагает несколько
способов это сделать.

\index{утилиты!lein}

Самый простой вариант~--- поручить прогон тестов утилите. Если проект основан на
\footurl{Leiningen}{https://leiningen.org}[Leiningen], запустите команду \code{lein test}.
Потребуется время, чтобы считать код из папок \code{src} и \code{test},
найти тесты и выполнить их. Вы увидите следующий отчёт:

\begin{text}
lein test book.util-test
Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
\end{text}

Clojure группирует тесты по пространствам имён. Под каждым пространством указана
информация о том, сколько выполнено тестов (объявлений \code{deftest}) и
проверок (вызовов \code{is}). У нас один тест \code{test-fahr} с~двумя макросами
\code{is}.

\index{тесты!failure}
\index{тесты!error}

Выражение \code{lein test book.util-test} напечатано для того, чтобы его можно
было скопировать и запустить в терминале. Тогда сработают тесты только из модуля
\code{book.util-test}.

Негативное поведение в тестах делится на failures
и~errors. \textbf{Failure} \eng{неудача} означает ложное утверждение. Если
сравнение в \code{is} вернуло ложь, счётчик \code{failures} увеличится на
единицу. Каждая неудача помнит, с какими параметрами её запустили. Если была
хотя бы одна неудача, команда \code{lein test} завершится с ненулевым кодом.

Откройте функцию \code{->fahr} и измените коэффициент 1.8 на 1.9. Сохраните файл
и выполните \code{lein test}. Вывод консоли:

\begin{text}
$ lein test
lein test :only book.util-test/test-fahr

FAIL in (test-fahr) (util_test.clj:6)
expected: (= 68 (int (->fahr 20)))
  actual: (not (= 68 70))

FAIL in (test-fahr) (util_test.clj:7)
expected: (= 212 (int (->fahr 100)))
  actual: (not (= 212 222))

Ran 1 tests containing 2 assertions.
2 failures, 0 errors.
Tests failed.
\end{text}

Отчёт показывает два \code{failures}, что верно: макрос \code{is} встречается
дважды. Обе проверки неверны, потому что опираются на \code{->fahr}
с~ошибкой. Для каждого случая показаны исходное выражение и~результат.

Выражение с \code{:only} из второй строки выполнит только указанный тест. Это
полезно, когда вы работаете над участком кода и запускаете тест много раз.

\ifnarrow

\begin{bash}
$ lein test \
    :only book.util-test/test-fahr
\end{bash}

\else

\begin{bash}
$ lein test :only book.util-test/test-fahr
\end{bash}

\fi

\index{исключения!в тестах}

\textbf{Errors}~--- это непойманные исключения, которые случились во время работы
теста. В основном ошибки возникают, когда функцию вызывают с неверными
данными. Представим, что мы решили проверить \code{->fahr} с \code{nil}. Добавим
второй тест:

\begin{clojure}
(deftest test-fahr-nil
  (is (nil? (->fahr nil))))
\end{clojure}

\noindent
Отчёт будет другим:

\ifnarrow

\begin{clojure}
$ lein test

ERROR in test-fahr-nil Numbers.java:3849
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException
    ... ;; truncated

Ran 2 tests containing 3 assertions.
0 failures, 1 errors.
Tests failed.
\end{clojure}

\else

\begin{clojure}
$ lein test
lein test :only book.util-test/test-fahr-nil

ERROR in (test-fahr-nil) (Numbers.java:3849)
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException: null
 at clojure.lang.Numbers.multiply (Numbers.java:3849)
    ... ;; truncated

Ran 2 tests containing 3 assertions.
0 failures, 1 errors.
Tests failed.
\end{clojure}

\fi

\index{NPE}

Вызов \code{(->fahr nil)} приводит к исключению
\code{Null\-Pointer\-Exception}. Фреймворк оборачивает тест в \code{try/catch}
и запоминает его. Для ошибок отчёт выводит стек-трейс, который мы сократили для
экономии места.

Иногда мы ожидаем, что функция бросит исключение при особых параметрах. Чтобы
записать это в виде утверждения, используют макрос \code{(is (thrown? ...))}. Мы
рассмотрим пример с исключениями позже.

\subsection{REPL}

\index{REPL}

Код на Clojure работает относительно быстро (примерно как Java), но его загрузка
занимает от трёх до десяти секунд. Точное время зависит от объёма кода и
оборудования. Даже если вы запускаете один тест, проект стартует с нуля, что
неэффективно.

Когда мы работаем с проектом, то подключаемся к его сеансу REPL. Удобно
выполнить тест прямо в REPL, не запуская новый проект. В этом случае ожидание
равно нулю.

Наивный способ выполнить тест~--- запустить его как функцию. Выражение
\code{(test-fahr)} вернёт \code{nil}, что означает, что утверждения
сработали верно. Теперь добавим в тест ошибку:

\begin{clojure}
(is (= 999 (int (->fahr 20))))
\end{clojure}

Если сохранить файл и вызвать \code{(test-fahr)}, по-прежнему получим результат
без ошибок. Так происходит, потому что мы только сохранили файл, но не загрузили
изменения в Лисп-машину. То, как изменения в файле перетекают в REPL, зависит от
вашего окружения.

\index{Emacs}
\index{CIDER}

Если это Emacs и CIDER, выполните одно из следующих действий. Переместите курсор
за последнюю скобку формы \code{(deftest test-fahr...)} и~нажмите
\code{C-c C-e}. Сработает команда \code{cider\-/eval-last-sexp}, которая
выполнит последнее S-выражение.

Другой способ в том, чтобы выполнить на сервере весь буфер. Независимо от того,
где сейчас курсор, нажмите \code{C-c C-k} или выполните команду
\code{M-x cider-eval-buffer <RET>}. Действие равносильно тому, чтобы скопировать
буфер, вставить в REPL и нажать ввод.

После обновления вызов \code{(test-fahr)} вернёт \code{nil}, но в консоли
появятся строки:

\begin{clojure}
FAIL in (test-fahr) (util_test.clj:14)
expected: 999
  actual: (68)
\end{clojure}

Если вызвать тест \code{(test-fahr-nil)}, который всё ещё неисправен,
увидим исключение:

\pagebreaklarge

\ifnarrow

\begin{clojure}
ERROR in test-fahr-nil Numbers.java:3849
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException
    ... ;; truncated
\end{clojure}

\else

\begin{clojure}
ERROR in (test-fahr-nil) (Numbers.java:3849)
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException: null
 at clojure.lang.Numbers.multiply (Numbers.java:3849)
    book.util$__GT_fahr.invokeStatic (util.clj:5)
    ... ;; truncated
\end{clojure}

\fi

Это только вывод в консоль, а не брошенное исключение. Макрос \code{deftest}
оборачивает тело теста в \code{try/catch}, чтобы вызов был безопасным.

Вызов теста как функции не претендует на полноценный запуск, потому что при
таком способе мы пропускаем подготовительные шаги. Что именно входит в эти шаги
мы рассмотрим позже. Пока что отметим, что функция \code{test-vars} выполняет
тесты с учётом всех стадий. Она принимает вектор объектов \code{Var}:

\ifnarrow

\begin{clojure}
(require
  '[clojure.test :refer [test-vars]])

(test-vars
  [#'test-fahr #'test-fahr-nil])
\end{clojure}

\else

\begin{clojure}
(require '[clojure.test :refer [test-vars]])

(test-vars [#'test-fahr #'test-fahr-nil])
\end{clojure}

\fi

\index{clojure.test!run-tests}

Функция \code{run-tests} запускает все тесты пространства (текущего или
указанного). Технически она сводится к двум шагам: найти все переменные тестов в
пространстве и передать их в \code{test-vars}.

\ifnarrow

\begin{clojure}
(require
  '[clojure.test :refer [run-tests]])
(run-tests)
\end{clojure}

\else

\begin{clojure}
(require '[clojure.test :refer [run-tests]])
(run-tests)
\end{clojure}

\fi

Ещё одна функция \code{run-all-tests} выполняет тесты для всех загруженных
пространств:

\ifnarrow

\begin{clojure}
(require
  '[clojure.test :refer [run-all-tests]])
(run-all-tests)
\end{clojure}

\else

\begin{clojure}
(require '[clojure.test :refer [run-all-tests]])
(run-all-tests)
\end{clojure}

\fi

Запустив это выражение, вы увидите, как фреймворк перебирает загруженные модули,
в том числе из поставки Clojure и сторонних библиотек.

\begin{text}
Testing clojure.test
Testing clojure.core.server
Testing clojure.core.specs.alpha
Testing book.util
...
\end{text}

\index{регулярные выражения}

Чтобы отбросить лишнее, в \code{run-all-tests} передают регулярное выражение.
Пример ниже выполнит только тесты из модулей, чьи имена начинаются с book:

\begin{clojure}
(run-all-tests #"^book")
\end{clojure}

\subsection{Emacs и CIDER}

\index{Emacs}
\index{CIDER}

Модуль \footurl{CIDER}{https://github.com/clojure-emacs/cider}[CIDER] для
Emacs упрощает работу с тестами. CIDER предлагает команды и комбинации клавиш,
чтобы выполнить один или несколько тестов прямо в REPL. Он показывает отчёт об
ошибках в отдельном буфере. Вызвать тест клавишей удобнее, чем печатать команду
вручную.

Чтобы запустить один тест, поместите на него курсор и нажмите \code{C-c C-t t}
(или \code{M-x cider-test-run-test}). Курсор может быть в любом месте
\code{(deftest ...)}. Если тест прошёл без ошибок, внизу появится зелёный
текст, иначе откроется буфер \code{*cider-test-report*}.

Буфер выводит отчёт в удобной форме. Ошибки в утверждениях подсвечены красным
цветом, а непойманные исключения~--- оранжевым. Буфер интерактивен: если
подвести курсор к блоку с ошибкой и нажать Enter, соседнее окно покажет исходный
код. То же самое касается исключений: чтобы не засорять отчёт, CIDER выводит
только класс и~сообщение. По Enter откроется отдельный буфер со стек-трейсом.

Перечислим другие полезные команды:

\begin{itemize}

\item
  \code{cider-test-rerun-failed-tests} (клавиши \code{C-c C-t r}) выполнит
  только неудачные тесты из прошлого запуска. Полезно, чтобы не ждать весь
  прогон снова;

\item
  \code{cider-test-run-ns-tests} (\code{C-c C-t n}) выполнит те тесты, что
  соответствуют текущему пространству. Чтобы сопоставить пространства логики и
  тестов, CIDER добавляет к имени первого \code{-test}. Например, для
  \code{book.util} тестовый модуль получится
  \code{book.util-test}. Придерживайтесь этого правила, чтобы вызвать тесты было
  легко;

\item
  \code{cider-test-run-project-tests} (\code{C-c C-t p}) запускает все тесты
  текущего проекта. Того же эффекта можно добиться командой \code{lein test} в
  отдельном терминале.

\end{itemize}

Запуск тестов~--- это рутинное действие. В идеале они запускаются клавишей и~не
оттягивают на себя внимание. Чтобы не терять время, изучите возможности вашего
редактора или IDE.

\section{Полезные практики}

Тесты~--- тоже код, и за ним нужен уход. Небрежность в тестах несёт столько же
проблем, сколько и в приложении. Приёмы ниже сделают тесты удобней в чтении и
поддержке.

\subsection{Testing}

\index{clojure.test!testing}

Макрос \code{testing} оборачивает произвольный код строкой. Это сообщение о том,
что мы собираемся делать:

\begin{clojure}
(deftest test-square-roots
  (testing "Two roots"
    (let [result (square-roots 1 -5 6)]
      (is (= [3 2] (mapv int result)))))
  (testing "One root"
    (let [result (square-roots 1 6 9)]
      (is (= [-3] (mapv int result)))))
  (testing "No roots"
    (is (nil? (square-roots 2 4 7)))))
\end{clojure}

Сообщение важно по двум причинам: визуальной и технической. Оно разбивает код на
логические блоки, заменяет комментарии, делает тест понятнее. Если \code{is}
не сработал, в отчёте будет сообщение, в которое он обёрнут.

Макросы \code{testing} могут быть вложенными. Каждое новое сообщение наращивает
предыдущее через пробел. Тест ниже проверяет, что API \code{createUser} вносит
пользователя в базу. Дополнительно мы убеждаемся, что пароль в базе
зашифрован. Если отбросить основной код, получим скелет из форм \code{testing},
из которых понятны наши намерения.

\pagebreakafive

\begin{clojure}
(deftest test-some-api
  (testing "API call" ...
    (testing "HTTP response is OK" ...))
  (testing "DB checks:" ...
    (testing "common user fields" ...)
    (testing "password is hashed" ...)))
\end{clojure}

\subsection{Исключения}

\index{исключения!в тестах}

Мы всё ещё не выясняли, как тестировать код с исключениями. Хотелось бы
убедиться, что вызов \code{(->fahr nil)} бросит ошибку, а не вернёт
\code{nil}. Если проверки нет, код не защищён от подобных изменений:

\ifnarrow

\begin{clojure}
;; before
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
\end{clojure}

\splitter

\begin{clojure}
;; after
(defn ->fahr [cel]
  (when cel
    (+ (* cel 1.8) 32)))
\end{clojure}

\else

\noindent
\iflarge
\begin{tabular}{ @{}p{5.5cm} @{}p{5cm} }
\else
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }
\fi

\begin{clojure}
;; before
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
\end{clojure}

&

\begin{clojure}
;; after
(defn ->fahr [cel]
  (when cel
    (+ (* cel 1.8) 32)))
\end{clojure}

\end{tabular}

\fi

\index{nil}

\noindent
В этом случае \code{nil} провалится ниже по стеку вызовов, что усложнит поиск
причины.

Наивный способ~--- обернуть вызов в \code{try} и добавить утверждение в~ветку
\code{catch}:

\begin{clojure}
(deftest test-fahr-nil
  (try
    (->fahr nil)
    (catch Throwable e
      (is true))))
\end{clojure}

Отчасти это решит проблему: в случае ошибки действительно сработает
\code{(is true)}. Однако \code{try} не имеет обратной проверки. Если исправить
\code{(->fahr nil)} на \code{(->fahr 1)}, исключения не будет и тело
\code{(catch...)} не получит управление. Когда исключение ожидают, но его нет,
это тоже ошибка.

\pagebreakafive

\iflarge\vspace{15mm}\pagebreak[4]\fi

\index{классы!NullPointerException}

\begin{clojure}
(deftest test-fahr-nil
  (try
    (->fahr nil)
    (catch NullPointerException e
      (is true))))
\end{clojure}

Макрос \code{(is (thrown?...))} лишён этих недостатков. Внутренняя форма
\code{thrown?} принимает класс исключения и произвольное тело. Если брошено
исключение этого класса (с учётом наследования), внешний \code{is} сработает
положительно:

\begin{clojure}
(deftest test-fahr-nil
  (is (thrown? NullPointerException
               (->fahr nil))))
\end{clojure}

Когда исключения не было, получим ошибку в утверждении. Исправьте \code{nil}
на число и убедитесь, что тест не проходит.

\index{NPE}

Иногда проверки на класс не хватает. В больших участках кода \code{NPE}
возникает на разных уровнях. Предположим, кто-то изменил \code{->fahr} так, что
для \code{nil} получим \code{nil} (колонка справа в таблице выше). Представим
теперь, что результат \code{->fahr} участвует в сложении. Пример ниже бросит
\code{NPE}, хотя на самом деле он исходит не из \code{->fahr}, а функции
сложения. Этим мы расширили область ошибки, хотя должны были сузить её. Если
обернуть пример в тест, получится ложное тестирование: происходит не то, что мы
ожидаем.

\begin{clojure}
(+ 1 (->fahr nil))
\end{clojure}

\label{illegal-arg}

Проблему решают двумя шагами. Первый~--- исправить функцию так, чтобы она
бросила что-то более осмысленное, чем \code{NPE}. Подойдёт специальное
исключение \code{IllegalArgumentException}. Его дополняют сообщением о том,
что именно не так:

\ifnarrow

\begin{clojure}
(defn ->fahr [cel]
  (if (number? cel)
    (+ (* cel 1.8) 32)
    (throw (new IllegalArgumentException
             "Fahrenheit temperature
              must be a real number"))))
\end{clojure}

\else

\begin{clojure}
(defn ->fahr [cel]
  (if (number? cel)
    (+ (* cel 1.8) 32)
    (throw (new IllegalArgumentException
            "Fahrenheit temperature must be
                                  a real number"))))
\end{clojure}

\fi

Второй шаг~--- убедиться, что исключение пришло именно из \code{->fahr}. Форма
\code{(is (thrown\-/with-msg?...))} проверяет, что текст исключения совпадает
с регулярным выражением. Тест ниже покрывает эти требования:
\code{IllegalArgumentException} из другой функции не пройдёт проверку.

\begin{clojure}
(deftest test-fahr-nil
  (is (thrown-with-msg?
       IllegalArgumentException
       #"Fahrenheit temperature"
       (->fahr nil))))
\end{clojure}

\subsection{Пакетная проверка}

Вспомним, как выглядит \code{test-fahr}:

\begin{clojure}
(deftest test-fahr
  (is (= 68 (int (->fahr 20))))
  (is (= 212 (int (->fahr 100)))))
\end{clojure}

Оба \code{is} отличаются только числами. Чтобы добавить ещё одну проверку,
придётся копировать одну из форм. Копирование раздувает код и в~целом выходит
боком. Очевидно, из похожих \code{(is...)} можно выделить постоянную часть и
переписать тест.

\index{clojure.test!are}

Макрос \code{are} (англ.~множественная форма is) выполняет несколько
\code{is} по шаблону. Он принимает форму связывания, шаблон и аргументы. Число
аргументов должно быть кратно переменным из формы связывания. На каждом шаге
макрос связывает часть аргументов с~переменными и выполняет шаблон:

\begin{clojure}
(deftest test-fahr
  (are [c f] (= c (int (->fahr f)))
    68 20
    212 100))
\end{clojure}

Аргументы записывают столбиком по принципу одна строка~--- один
\code{is}. Переменные \code{f} и \code{c} в векторе означают температуру по
Фаренгейту и Цельсию, то есть исходное и ожидаемое значения. Выражение
\code{(int (->fahr f))} переехало в шаблон, поэтому нет смысла копировать его
для каждого случая.

Макрос \code{are} удобен для небольших выражений. Со временем он становится
трудным в поддержке. В этом случае тест переписывают на \code{doseq}, с которым
легче совладать.

Предположим, мы тестируем API для создания пользователя. Функция принимает
словарь из десяти полей. Хотелось бы убедиться, что для каждого поля, в случае
его отсутствия или неверного формата, мы получим ошибку. Можно линейно вызвать
функцию десять раз с небольшими правками в параметрах, но скопированный код
займёт много места. Поэтому пойдём на хитрость.

В переменную \code{params-ok} запишем правильные параметры API:

\ifafive

\begin{clojure}
(def params-ok
  {:name "John Smith"
   :email "john@test.com"
   :age 40
   ...})
\end{clojure}

\else

\begin{clojure}
(def params-ok {:name "John Smith"
                :email "john@test.com"
                ...})
\end{clojure}

\fi

Объявим вектор негативных случаев \code{params-variations}. Он состоит из пар
\tuple{словарь, текст}. Словарь~--- это изменения, которые добавим к
\code{params-ok} функцией \code{merge}. Текст описывает проблему: неверная
почта, слишком длинное имя и так далее.

\begin{clojure}
(def params-variations
  [[{:name nil}      "Empty name"]
   [{:email "dunno"} "Wrong email"]
   [{:email nil}     "No email"]
   [{:something 42}  "Extra field"]])
\end{clojure}

Тест пробегает по \code{params-variations}. На каждом шаге он вызывает
\code{api-create-user} с испорченными параметрами. Обратите внимание, что вызов
обёрнут в \code{testing} с сообщением. Если на одном из шагов не сработает
\code{is}, мы узнаем причину из отчёта.

\pagebreakafive

\ifnarrow

\begin{clojure}
(deftest test-api-create-user-bad-params
  (testing "Sending bad parameters"
    (doseq [[params* description]
            params-variations]
      (testing description
        (let [params
              (merge params-ok params*)

              response
              (api-create-user params)

              {:keys [status]} response]
          (is (= 400 status)))))))
\end{clojure}

\else

\begin{clojure}
(deftest test-api-create-user-bad-params
  (testing "Sending bad parameters"
    (doseq [[params* description] params-variations]
      (testing description
        (let [params (merge params-ok params*)
              response (api-create-user params)
              {:keys [status]} response]
          (is (= 400 status)))))))
\end{clojure}

\fi

Новый тест разделяет данные и проверку, поэтому его легко поддерживать. Если в
API появятся новые поля, расширим \code{params-variations}, не меняя тест.

\subsection{Именование}

Начинайте имя теста с префикса \code{test-}. С точки зрения Clojure это
необязательно: фреймворк ищет тесты по метаданным, а не по имени. Выражения ниже
останутся функцией и тестом, даже если их назвали наоборот.

\ifnarrow

\begin{clojure}
;; function
(defn test-if-suspended [user])

;; test
(deftest is-suspended)
\end{clojure}

\else

\begin{clojure}
(defn test-if-suspended [user]) ;; function
(deftest is-suspended)          ;; test
\end{clojure}

\fi

Префикс необходим для навигации по коду. В модуле бывает больше тестов, чем
умещается на экран. Вперемешку с тестами идут переменные и служебные функции. С
ростом модуля станет трудно понять, где функция, а где тест. С префиксом ошибки
быть не может.

\index{Emacs!навигация}
\index{навигация}

Emacs предлагает навигацию по коду командой \code{imenu} и её улучшенной
версией \code{helm-imenu}. При их вызове открывается буфер со списком
определений. С вводом текста останутся только те элементы, которые его
содержат. Называйте определения так, чтобы по команде \code{M-x helm-imenu <RET> test}
в списке остались только тесты.

В общем случае тест именуют по правилу \code{test\-/<what>\-/<case>}, где
\code{<what>} означает то, что мы тестируем, а \code{<case>}~---
сценарий. Например, \code{test-create-user-ok} означает, что создают
пользователя и~ожидают успех. Имя \code{test-create-user-bad-params} говорит о
попытке создать пользователя с неверными параметрами. Если пользователь не смог
войти в систему, потому что подпись устарела, тест называют
\code{test-user-login-signature-expired}.

\subsection{Порядок аргументов}

\index{тесты!ожидаемое}

Необычный вопрос: как писать правильно, \code{(is (= 200 status))} или
\code{(is (= status 200))}? На первый взгляд это абсурд: неужели равенство
зависит от порядка? Значения либо равны, либо нет. Но макрос \code{is}
сложнее, чем мы думаем: он разбивает форму \code{(= 200 status)} на ожидаемую
и фактическую части. По-английски они называются expected и actual.

Ожидаемое значение~--- то, которое посчитали заранее. Фактическое~--- то, на
которое тест вышел самостоятельно, вызвав наш код. Число 68~--- это ожидаемое, а
форма \code{(int (->fahr 20))}~--- действительное. Статус 200~--- это ожидаемое,
а выражение \code{(:sta\-tus res\-pon\-se)}~--- действительное.

Подобное разделение нужно для отчётов. Когда значения не равны, хотелось бы
видеть, где мы ошиблись. Предположим, в отчёте написано
\code{failed (= 200 403)}. Как это понимать? Ожидали успешный ответ, но не
хватило прав? Или это брешь в безопасности~--- доступа к странице нет, но
пользователь смог её увидеть? Если же написано <<expected 200, got 403>>, то
ясно: это первый случай, когда не хватило прав.

Правило: ожидаемое стоит на первом месте, а действительное~--- на~втором. Пишите
\code{(is (= 200 status))} вместо \code{(is (= status 200))}. Это непривычно
и противоречит здравому смыслу. Как правило, фактическое~--- это скаляр, а
действительное~--- выражение, поэтому хочется записать их как в таблице слева.
Увы, придётся побороть себя и писать по образцу справа:

\ifnarrow

\begin{clojure}
;; wrong
(= (int (->fahr 20)) 68)
\end{clojure}

\splitter

\begin{clojure}
;; correct
(= 68 (int (->fahr 20)))
\end{clojure}

\else

\noindent
\iflarge
\begin{tabular}{ @{}p{5.7cm} @{}p{5cm} }
\else
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }
\fi

\begin{clojure}
;; wrong
(= (int (->fahr 20)) 68)
\end{clojure}

&

\begin{clojure}
;; correct
(= 68 (int (->fahr 20)))
\end{clojure}

\end{tabular}

\fi

\index{библиотеки!JUnit}

Правило уходит корнями в прошлое. Фреймворк JUnit утвердил именно такой порядок в
\footurl{методах сравнения}{https://junit.org/junit5/docs/current/user-guide/}[JUnit].
Хорошо это или плохо, судить уже поздно~--- принцип <<expected слева>> стал
стандартом. Аналогично работают тесты в Python, Ruby и других языках. Отдельные
фреймворки предлагают модули, чтобы <<перестать говорить как Йода>>, то~есть
поменять семантику аргументов. Это возможно и в Clojure, но сейчас мы не будем
отклоняться от темы.

\index{CIDER}

Особенность expected и actual видна при запуске тестов в CIDER. Один и тот же
тест проверяет статус ответа на 200. Пока всё хорошо, нет разницы, в каком
порядке следуют аргументы \code{is}. В случае ошибки вариант слева вносит
путаницу. Согласно ему, нормальным считается статус 404 (expected), а не 200
(actual). Вариант справа выводит статусы правильно.

\ifnarrow

\begin{clojure}
;; wrong
(is (= (:status response)
       200))

Fail in test-...
expected: 404
  actual: 200
    diff: - 404
          + 200
\end{clojure}

\splitter

\begin{clojure}
;; correct
(is (= 200
       (:status response)))

Fail in test-...
expected: 200
  actual: 404
    diff: - 200
          + 404
\end{clojure}

\else

\noindent
\iflarge
\begin{tabular}{ @{}p{5.8cm} @{}p{4.5cm} }
\else
\begin{tabular}{ @{}p{5.5cm} @{}p{4.5cm} }
\fi

\begin{clojure}
;; wrong
(is (= (:status response)
       200))

Fail in test-...
expected: 404
  actual: 200
    diff: - 404
          + 200
\end{clojure}

&

\begin{clojure}
;; correct
(is (= 200
       (:status response)))

Fail in test-...
expected: 200
  actual: 404
    diff: - 200
          + 404
\end{clojure}

\end{tabular}

\fi

\section{Фикстуры}

\index{фикстуры}

До сих пор мы работали с простыми тестами. Они запускаются в любой момент,
потому что не зависят от ресурсов. Так бывает не всегда: чем сложнее код, тем
больше требований к базе данных, файлам и сети. Всё вместе это называется
окружением теста.

Рассмотрим, как сообщить тесту его окружение. Для этого служат фикстуры. В
широком смысле термин означает стенд, на котором испытывают изделие. В
программировании фикстуру описывают функцией, которая запускается до или после
теста. Фикстура готовит окружение и очищает его. Перечислим случаи, когда
полезны фикстуры.

\index{файлы!в фикстурах}

\textbf{Файлы на диске.} Код, который мы тестируем, ищет в заданной папке файл с
данными. Фикстура создаёт файл и удаляет его после теста. Подход гарантирует,
что на диске не останется следов после работы.

\textbf{Данные в базе.} Чтобы проверить авторизацию, в базу вносят пользователя
с известным паролем. Пригодятся и другие данные: профиль, друзья, история
заказов. Фикстура пишет данные в базу и в~конце очищает её, чтобы не повлиять на
следующий тест.

\textbf{Запуск и остановка системы.} Иногда фикстура управляет глобальным
состоянием программы. Например, для интеграционного теста нужно включить систему
целиком. Запуск и остановку системы логично поместить в фикстуру.

По ходу главы мы рассмотрим и другие сценарии для фикстур. Пока что разберёмся,
как они устроены технически. Фикстура~--- это функция, которая принимает
тест. Функция выполняет любые действия, в~том числе вызывает тест. Вопрос, в
какой момент это делать, остаётся на ваше усмотрение.

В примере ниже мы сначала готовим окружение: чистим таблицы, вносим данные,
затем вызываем тест.

\index{фикстуры!база данных}

\label{fix-db-data}

\ifnarrow

\begin{clojure}
(def db {...}) ;; JDBC spec

(defn fix-db-data [t]
  ;; purge tables
  (jdbc/execute! db
    "truncate users cascade;")
  (jdbc/execute! db
    "truncate orders cascade;")
  ;; add data
  (jdbc/insert! db :users user-data)
  (jdbc/insert! db
    :profile profile-data)
  ;; execute the test
  (t))
\end{clojure}

\else

\ifafive

\begin{clojure}
(def db {...}) ;; JDBC spec

(defn fix-db-data [t]

  ;; purge tables
  (jdbc/execute! db "truncate users cascade;")
  (jdbc/execute! db "truncate orders cascade;")

  ;; add data
  (jdbc/insert! db :users user-data)
  (jdbc/insert! db :profile profile-data)

  ;; execute the test
  (t))
\end{clojure}

\else

\begin{clojure}
(def db {...}) ;; JDBC spec

(defn fix-db-data [t]
  ;; purge tables
  (jdbc/execute! db "truncate users cascade;")
  (jdbc/execute! db "truncate orders cascade;")
  ;; add data
  (jdbc/insert! db :users user-data)
  (jdbc/insert! db :profile profile-data)
  ;; execute the test
  (t))
\end{clojure}

\fi

\fi

Бывает и наоборот: тест нуждается в финальных действиях. Предположим, мы пишем
промежуточные файлы на диск. Чтобы очистить папку при выходе из теста, напишем
фикстуру:

\pagebreakafive

\ifnarrow

\begin{clojure}
(import 'java.io.File
        'org.apache.commons.io.FileUtils)

(defn clean-dir [path]
  (FileUtils/cleanDirectory
    (new File path)))

(defn fix-clean-files [t]
  (t)
  (clean-dir "/tmp/tests/data"))
\end{clojure}

\else

\begin{clojure}
(import 'java.io.File
        'org.apache.commons.io.FileUtils)

(defn clean-dir [path]
  (FileUtils/cleanDirectory (new File path)))

(defn fix-clean-files [t]
  (t)
  (clean-dir "/tmp/tests/data"))
\end{clojure}

\fi

Иногда фикстура выполняет и предварительные, и финальные шаги. В этом случае
\code{(t)} находится где-то посередине.

Надеемся, читатель заметил, что имена фикстур начинаются с~префикса
\code{fix-}. Для фикстур действует то же правило именования, что и для
тестов. Это особые сущности, поэтому их выделяют префиксом на общем фоне.

\subsection{Регистрация}

\index{фикстуры!регистрация}

Если запустить тест сейчас, фикстура не сработает. Мы только объявили фикстуру,
но не сказали фреймворку взять её в работу. Это делают регистрацией фикстуры.
Резонный вопрос: если фреймворк сам находит тесты, почему бы ему не искать и
фикстуры?

Причина в том, что фикстуры работают на разных этапах теста. Clojure выделяет
стадии \code{:each} и \code{:once}. Зарегистрировать фикстуру значит связать
её с одним из этих ключей. Значение \code{:each} означает, что фикстура
работает для каждого теста из модуля. С ключом \code{:once} фикстура
выполняется однажды в рамках пространства.

\index{фикстуры!:once}
\index{фикстуры!:each}

Одна и та же фикстура может быть как \code{:each}, так и или
\code{:once}. Вспомним фикстуру \code{fix-clean-files}, которая очищает
папку. Если у файлов случайные имена, логично удалить их один раз в конце, и
фикстуре указывают \code{:once}. Если имена одинаковы, возрастает риск коллизии
(чтение и запись из другого теста). Тогда фикстуру связывают с~ключом
\code{:each}.

Другой пример~--- фикстура базы данных. На время теста она пишет данные в
таблицы и очищает их. Если тесты только читают данные, укажем
\code{:once}. Получим выигрыш в скорости: для десяти тестов фикстура сработает
один раз. Для тестов на запись важно, чтобы ни один из них не влиял на другой,
поэтому фикстуру добавляют с \code{:each}.

Функция \code{use-fixtures} из \code{clojure.test} принимает ключ и любое
число фикстур:

\index{clojure.test!use-fixtures}

\begin{clojure}
(use-fixtures :once
  fix-db-server fix-clean-files)

(use-fixtures :each fix-db-data)
\end{clojure}

Выражения ставят в верхней части файла до тестов. Они могут быть и в конце, но
чем раньше мы увидим фикстуры, тем лучше.

\subsection{Очерёдность}

Чтобы исследовать порядок фикстур, добавим в них побочный эффект. Функция
\code{fix-factory} принимает тип фикстуры, её номер и возвращает
фикстуру. Логика фикстуры в том, чтобы напечатать свой номер и тип до и после
теста.

\index{фикстуры!порядок}

\ifnarrow

\begin{clojure}
(defn fix-factory [type number]
  (fn [t]
    (println (format "%s %s starts"
               type number))
    (t)
    (println (format "%s %s ends"
               type number))))
\end{clojure}

\else

\begin{clojure}
(defn fix-factory [type number]
  (fn [t]
    (println (format "%s %s starts" type number))
    (t)
    (println (format "%s %s ends" type number))))
\end{clojure}

\fi

\noindent
Добавим по две фикстуры каждого типа:

\begin{clojure}
(use-fixtures :once
  (fix-factory :once 1)
  (fix-factory :once 2))

(use-fixtures :each
  (fix-factory :each 3)
  (fix-factory :each 4))
\end{clojure}

Если запустить тесты, увидим следующее. Фикстуры 1 и 2 с типом \code{:once}
сработали однажды на границах всего прогона. Обратите внимание на их обратный
порядок в конце: сначала завершается фикстура 2, и~только потом~--- 1. Фикстуры
3 и 4 оборачивают каждый тест. Чтобы выразить процесс нагляднее, добавим
отступы. С ними видна иерархия фикстур.

\index{отступы}

\begin{clojure}
:once 1 starts
  :once 2 starts
    :each 3 starts
      :each 4 starts
        test 1
      :each 4 ends
    :each 3 ends
    :each 3 starts
      :each 4 starts
        test 2
      :each 4 ends
    :each 3 ends
  :once 2 ends
:once 1 ends
\end{clojure}

\subsection{Хранение фикстур}

Пытливому читателю будет полезно знать, где лежит информация о~фикстурах. Очевидно,
вызов \code{use-fixtures} меняет глобальное состояние. Это не атом и не
переменная, а нечто другое, с чем мы ещё не работали,~--- метаданные
пространства. После регистрации фикстур проверьте его ключи:

\index{метаданные!в фикстурах}
\index{метаданные!в тестах}
\index{метаданные!в пространствах}

\begin{clojure}
(keys (meta *ns*))

(:clojure.test/each-fixtures
 :clojure.test/once-fixtures)
\end{clojure}

В каждом ключе список функций, которые передали в \code{use\-/fixtures} с
\code{:each} или \code{:once}. Вызов \code{use-fixtures} заменяет в метаданных
все фикстуры этого типа. Важно, что это полная замена, а не запись
в~конец. Чтобы отказаться от всех фикстур, выполните:

\begin{clojure}
(use-fixtures :once)
(use-fixtures :each)
\end{clojure}

Другой способ очистить фикстуры~--- удалить форму \code{use\-/fixtures} в коде и
выполнить буфер в REPL. Тогда объявление \code{(ns...)}
сработает ещё раз с новыми метаданными.

\label{fix-session}

В других языках и фреймворках выделяют ещё одну стадию фикстур~---
\code{:session}. Такая фикстура запускается в разрезе всего прогона
тестов. Можно сказать, это фикстура-синглтон: даже для нескольких модулей она
сработает один раз. В \code{clojure.test} нет такой стадии. С ней пространства
были бы связаны друг с другом, что нарушает идею фреймворка. Начинающим часто не
хватает \code{session}-фикстур, но мы научимся обходиться без них.

\subsection{Связанные переменные}

\index{clojure.core!binding}
\index{фикстуры!с binding}

Фикстуры особенно удобны в паре с динамическими переменными. Напомним:
динамические переменные~--- это формы \code{def} с тегом \code{\circum{}:dynamic} и
<<ушками>>. Макрос \code{binding} выполняет код с новым значением переменных. Мы
подробно рассмотрели их в главе про изменяемость \page{dynamic-vars}.

Форма \code{deftest} порождает функцию без аргументов. Нельзя сообщить тесту его
параметры, как обычной функции. А ведь тесту нужны файлы, база данных и многое
другое. Поэтому окружение передают в два шага. Первый~--- тест ссылается на
глобальную переменную. Второй~--- пишут фикстуру, которая оборачивает тест в
\code{binding} с этой переменной и~нужным значением.

Предположим, мы тестируем функцию, которая принимает путь к файлу и пишет в него
картинку. Объявим фикстуру, которая на время теста свяжет переменную
\code{*tmp-file*} со временным файлом, экземпляром \code{java.util.File}. При
выходе из теста удалим файл, а~переменная вернётся в \code{nil}.

\pagebreakafive

\index{классы!File}
\index{файлы!временные}

\ifnarrow

\begin{clojure}
(import 'java.io.File)

(defonce ^:dynamic *tmp-file* nil)

(defn fix-with-tmp-file [t]
  (let [tmp-file
        (File/createTempFile
          "test" "image.png")]
    (binding [*tmp-file* tmp-file]
      (t))
    (.delete tmp-file)))

(use-fixture :each fix-with-tmp-file)
\end{clojure}

\else

\begin{clojure}
(import 'java.io.File)

(defonce ^:dynamic *tmp-file* nil)

(defn fix-with-tmp-file [t]
  (let [tmp-file (File/createTempFile "test" "image.png")]
    (binding [*tmp-file* tmp-file]
      (t))
    (.delete tmp-file)))

(use-fixture :each fix-with-tmp-file)
\end{clojure}

\fi

Частичка \code{with} в имени фикстуры намекает на контекст. Добавляйте её, когда
фикстура обращается к переопределениям вроде \code{binding}, \code{with-redefs}
или аналогам.

\index{форматы!PNG}
\index{изображения}
\index{классы!PngImage}

Внутри теста мы вызываем \code{plot-chart}~--- функцию, которая принимает массив
точек, файл и записывает в него график.

\ifnarrow

\begin{clojure/lines*}{firstnumber=1}
(import 'javax.imageio.ImageIO)

(deftest test-plot-chart-png
 (let [dataset [[...] [...] [...]]
       filepath (.getAbsolutePath
                          *tmp-file*)]
   (plot-chart dataset filepath)))
\end{clojure/lines*}

\else

\begin{clojure/lines*}{firstnumber=1}
(import 'javax.imageio.ImageIO)

(deftest test-plot-chart-png
  (let [dataset [[...] [...] [...]]
        filepath (.getAbsolutePath *tmp-file*)]
    (plot-chart dataset filepath)))
\end{clojure/lines*}

\fi

\noindent
Убедимся, что функция действительно записала в файл картинку. Класс
\code{PngImage} предлагает простейший парсер одноимённого формата. Прочитаем
разрешение файла и сверим с образцом.

\ifnarrow

\begin{clojure/lines*}{firstnumber=8}
(let [png (ImageIO/read *tmp-file*)
      width (.getWidth png)
      height (.getHeight png)])
(is (= [640 480] [width height]))))
\end{clojure/lines*}

\else

\begin{clojure/lines*}{firstnumber=7}
    (let [png (ImageIO/read *tmp-file*)
          width (.getWidth png)
          height (.getHeight png)])
    (is (= [640 480] [width height]))))
\end{clojure/lines*}

\fi

\index{базы данных!Cassandra}
\index{фикстуры!база данных}

Рассмотрим более сложную фикстуру для базы данных. Пусть это будет Cassandra, а
не JDBC-драйвер. Работа с базой состоит из двух частей: подключение и подготовка
данных. Поместим первую часть в фикстуру \code{fix-with-db}, которая связывает
\code{*db*} с текущей сессией. Установка сессии~--- дорогая операция, поэтому
фикстура будет разовой (once).

\ifnarrow

\begin{clojure}
(require '[qbits.alia :as alia])

(defonce ^:dynamic *db* nil)

(defn fix-with-db [t]
  (let [opt {:contact-points
               ["localhost"]}
        cluster (alia/cluster opt)
        session (alia/connect cluster)]
    (binding [*db* session]
      (t))
    (.close session)
    (.close cluster)))

(use-fixture :once fix-with-db)
\end{clojure}

\else

\begin{clojure}
(require '[qbits.alia :as alia])

(defonce ^:dynamic *db* nil)

(defn fix-with-db [t]
  (let [opt {:contact-points ["localhost"]}
        cluster (alia/cluster opt)
        session (alia/connect cluster)]
    (binding [*db* session]
      (t))
    (.close session)
    (.close cluster)))

(use-fixture :once fix-with-db)
\end{clojure}

\fi

Вторая фикстура готовит данные для каждого теста. Поскольку фикстуры
\code{:once} запускаются раньше, чем \code{:each}, подготовка данных сработает
внутри \code{(binding [*db* ...])} из первой фикстуры. Это значит, внутри второй
мы свободно обращаемся к \code{*db*} как к сессии:

\index{SQL!TRUNCATE}

\ifnarrow

\begin{clojure}
(defn fix-db-prepare-data [t]
  (alia/execute! *db*
    "truncate project.users;")
  (alia/execute! *db*
    "truncate project.orders;")
  (alia/execute! *db*
    "insert into project.users...")
  (t))

(use-fixture :each fix-db-prepare-data)
\end{clojure}

\else

\begin{clojure}
(defn fix-db-prepare-data [t]
  (alia/execute! *db* "truncate project.users;")
  (alia/execute! *db* "truncate project.orders;")
  (alia/execute! *db* "insert into project.users...")
  (t))

(use-fixture :each fix-db-prepare-data)
\end{clojure}

\fi

С этими фикстурами каждый тест найдёт в базе нужные данные, при этом подключение
будет открыто в течение всего сеанса.

\subsection{Мультификстуры}

\label{multi-fixture}

\index{фикстуры!множественные}

Любопытный вопрос: что произойдёт, если фикстура вызовет тест несколько раз?
Напишем такую фикстуру:

\begin{clojure}
(defn fix-multi [t]
  (t) (t) (t))

(use-fixtures :each fix-multi)
\end{clojure}

\noindent
и запустим один тест. С точки зрения фреймворка прошло три теста, о чём скажет
отчёт:

\ifnarrow

\begin{text}
Ran 6 assertions, in 3 test functions.
0 failures, 0 errors.
\end{text}

\else

\begin{text}
book.util-test: Ran 6 assertions, in 3 test functions.
0 failures, 0 errors.
\end{text}

\fi

На первый взгляд, в этом нет смысла. Множественный прогон не несёт пользы, а
только потребляет ресурсы и время. Но с динамическими переменными такая фикстура
находит новое применение. Один и тот же тест можно выполнить в разных
окружениях.

Предположим, программа работает с базой данных. В требованиях сказано, что это
может быть PostgreSQL или MySQL. Убедимся, что программа поддерживает обе
СУБД. Чтобы не дублировать тесты под каждый тип базы, логику повтора выносят в
фикстуру. Объявим подключения к разным базам данных:

\ifnarrow

\begin{clojure}
(def db-pg
  {:dbtype "postgresql" :host "..."})

(def db-mysql
  {:dbtype "mysql" :host "..."})
\end{clojure}

\else

\begin{clojure}
(def db-pg    {:dbtype "postgresql" :host "..."})
(def db-mysql {:dbtype "mysql"      :host "..."})
\end{clojure}

\fi

Добавим динамическую переменную \code{*db*}. Новая фикстура перебирает
подключения и связывает их с \code{*db*} на каждом шаге. Когда переменная
связана, запускается тест. Он зависит от текущего подключения и поэтому
обращается либо в PostgreSQL, либо в MySQL.

\ifnarrow

\begin{clojure}
(defonce ^:dynamic *db* nil)

(defn fix-with-multi-db-backend [t]
  (doseq [db [db-pg db-mysql]]
    (binding [*db* db]
      (testing
        (format "Test DB: %s"
          (:dbtype *db*))
        (t)))))
\end{clojure}

\else

\begin{clojure}
(defonce ^:dynamic *db* nil)

(defn fix-with-multi-db-backend [t]
  (doseq [db [db-pg db-mysql]]
    (binding [*db* db]
      (testing (format "Test DB: %s" (:dbtype *db*))
        (t)))))
\end{clojure}

\fi

Вызов \code{(t)} обёрнут в форму \code{testing}, которая сообщает тип базы. Если
произошла ошибка, мы узнаем, с какой базой работали в тот момент. Тест на чтение
пользователя, который выполнится дважды:

\ifnarrow

\begin{clojure}
(defn test-get-user-by-id
  (let [user
        (project.orm/get-user *db* 1)]
    (is (= {:name "Ivan"} user))))
\end{clojure}

\else

\begin{clojure}
(defn test-get-user-by-id
  (let [user (project.orm/get-user *db* 1)]
    (is (= {:name "Ivan"} user))))
\end{clojure}

\fi

Перечислим другие сценарии для мультификстур. Это могут быть интеграционные
тесты в нескольких браузерах (Chrome, Firefox). Иногда нужно проверить, что
логика не зависит от формата передачи данных (JSON, Msgpack). Если программа
работает с изображениями, тесты прогоняют на разных типах файлов (PNG, JPEG) и
разрешениях.

\section[This is fine]{This is fine\footnote{%
    Этот раздел носит скорее шуточный характер,
    но всё же раскрывает некоторые особенности фикстур.}}

Для полноты картины учтём и обратный случай: что случится, если фикстура не
вызывает тест?

\index{фикстуры!с подавлением}

\begin{clojure}
(defn fix-mute [t])

(use-fixtures :each fix-mute)
\end{clojure}

Это приведёт к тому, что ни один тест не сработает. Сама по себе фикстура не
отменяет тесты: фреймворк по-прежнему находит и выполняет их. В отчёте увидим
список тестов, но для каждого будет указано <<0~assertions>>. Если запустить
тест из Emacs, получим предупреждение:

\begin{clojure}
No assertions (or no tests) were run.
Did you forget to use ‘is’ in your tests?
\end{clojure}

\index{CIDER}

CIDER считает подозрительным, что не было ни одного \code{is}. Чтобы обмануть
CIDER, улучшим фикстуру. Добавим в неё \code{is}, который всегда истинен. Даже
если в тесте ошибки, его тело не выполнится, а в отчёте будет один
assertion. Назовём фикстуру
\footurl{\code{fix-this-is-fine}}{https://knowyourmeme.com/memes/this-is-fine}[This\\*is fine]:

\begin{clojure}
(defn fix-this-is-fine [t]
  (is true))

(use-fixtures :each fix-this-is-fine)
\end{clojure}

\index{люди!Джордж Оруэлл}

С её помощью мы пройдём тест Оруэлла:

\begin{clojure}
(deftest test-1984
  (testing "Sometimes they are five."
    (is (= 5 (* 2 2)) )))
;; OK, ran 1 assertions
\end{clojure}

По аналогии напишите фикстуру, которая портит любой тест. Добейтесь, чтобы все
тесты завершились с ошибкой.

\subsection{Фикстуры с условиями}

\index{фикстуры!с условием}

Как мы выяснили, фикстура не только вызывает тест, но и несёт дополнительную
логику. Тест может быть обёрнут в цикл, условие или другую форму. Разберёмся с
условием. В каких случаях тест ставят под \code{if} и есть ли в этом смысл?

К условной фикстуре прибегают, когда мы не знаем заранее, сможем ли выполнить
тест. Например, часть программы работает только с~базой данных
PostgreSQL. Фикстура проверяет тип подключения и~не вызывает тест, если он
заведомо не работает.

\begin{clojure}
(defn fix-pg-only [t]
  (when (= (:dbtype *db*) "postgresql")
    (t)))
\end{clojure}

Фикстура молча пропускает тесты, которые не поддерживает текущая база
данных. Если нужен сигнал об ошибке, добавьте ложное утверждение. Обратите
внимание на второй параметр \code{is}. Это сообщение, которое появится в отчёте
для утверждения.

\ifnarrow

\begin{clojure}
(defn fix-pg-only [t]
  (let [{:keys [dbtype]} *db*]
    (if (= dbtype "postgresql")
      (t)
      (is false
        (str "Unsupported DB "
          dbtype)))))
\end{clojure}

\else

\begin{clojure}
(defn fix-pg-only [t]
  (let [{:keys [dbtype]} *db*]
    (if (= dbtype "postgresql")
      (t)
      (is false (str "Unsupported DB " dbtype)))))
\end{clojure}

\fi

Каким способом зарегистрировать фикстуру~--- \code{:once} или \code{:each}?
Зависит от семантики условия. В нашем примере база не меняется от теста к тесту,
поэтому условие может быть выполнено однажды. Если фикстура проверяет файл на
диске, проверку делают для каждого теста.

Рассмотрим другие сценарии, когда фикстурам нужны условия. Это версия
операционной системы: если она ниже порога, мы не можем выполнить тест. Иногда
приложение зависит от системной утилиты, которую вызывает в отдельном
процессе. Это может быть \code{ffmpeg} для конвертации видео. Фикстура
проверяет, что утилита установлена при помощи вызова \code{ffmpeg -version}.
Когда тест работает с большими файлами, может не хватить места на сервере
CI. Перед запуском фикстура убеждается, что места хватит.

\section{Метки и селекторы}

\index{селекторы!в тестах}

Фикстуры с условиями похожи на фильтры. С их помощью запускают не все тесты, а
только часть, которая подходит окружению. Избегайте ситуаций, когда в фикстурах
слишком много условий. Clojure предлагает более удобный способ выборочного
прогона. Это метки и селекторы тестов.

Метки устроены проще, чем фикстуры с условием. Это метаданные, которые сообщают
тесту при его создании. Тест ниже получил флаг \code{:special} со значением
\code{true}.

\begin{clojure}
(deftest ^:special test-special-case
  (let [...]
    (is ...)))
\end{clojure}

\index{синтаксис!\code{\^} (метаданные)}
\index{метаданные}

Напомним, что выражение \code{\circum{}:flag}~--- это сокращение полной версии
\code{\circum{}\{:flag true\}}. <<Крышка>> полезна, чтобы задать несколько флагов за один
раз:

\begin{clojure}
(deftest ^:special ^:backend ^:db
  test-special-case
  ...)
\end{clojure}

\noindent
Когда тегов два и больше, имя теста переносят на следующую строку, чтобы
визуально отделить от тегов.

По тегам легко догадаться, что это тест на серверную логику (\code{backend});
ему нужна база данных (\code{db}); это особый тест (\code{special}). Смысл
тегов зависит от соглашений в команде. Чтобы проверить флаги, прочитаем
метаданные переменной \code{test-special-case}. Среди прочих полей вы найдёте
\code{:special} и остальные:

\ifnarrow

\begin{clojure}
(meta #'test-special-case)
{:special true
 :backend true
 :no-db true ...}
\end{clojure}

\else

\begin{clojure}
(meta #'test-special-case)
{:special true :backend true :no-db true ...}
\end{clojure}

\fi

По тегам можно выбрать часть тестов: только особые (\code{special}) или на
серверную логику (\code{backend}). Выборка называется селектором
тестов. Селекторы полезны по нескольким причинам.

Часть тестов отработает быстрее, чем полный набор. Если мы работаем над участком
кода и точно знаем, какие тесты он задевает, нет смысла запускать всё
подряд. Назначим тестам тег и будем работать с подмножеством.

Иногда окружение не настроено должным образом, и выполнить все тесты
невозможно. Например, интеграционный тест требует браузер и~драйвер к нему,
очередь задач и почтовый сервер. Столь сложные тесты выносят в отдельный шаг
сборочной линии. В общих чертах сборка выглядит так:

\begin{itemize}

\item
  запустить минимальное окружение (база данных);

\item
  выполнить модульные тесты;

\item
  если не было ошибок, включить дополнительное окружение (очередь задач,
  заглушки);

\item
  выполнить интеграционные тесты.

\end{itemize}

\noindent
Чем сложнее проект, тем больше в нём тестов и шагов по их запуску.

В тестовом фреймворке Clojure нет селекторов. Он запускает один тест,
пространство или всё целиком. Селекторы предлагают сторонние библиотеки и
утилиты. Рассмотрим, как задать их в Leiningen.

Откройте файл \code{project.clj}. Внутри \code{def\-pro\-ject} добавьте ключ
\code{:test-selectors}. Это словарь, где ключ~--- метка селектора, а
значение~--- функция одного аргумента. Функция принимает метаданные теста. Если
она вернула ложь или \code{nil}, тест пропускают.

Поскольку кейворд в Clojure работает как функция, селектором может быть сам
тег. Пример ниже читается как <<набор тестов \code{:special}, у которых тег
\code{:special}>>:

\begin{clojure}
:test-selectors {:special :special
                 :backend :backend}
\end{clojure}

\noindent
Чтобы запустить тесты с селектором, передайте метку в команду \code{test}:

\begin{bash}
$ lein test :special
\end{bash}

\index{селекторы!:default}

Если метка не задана, фреймворк назначит ей \code{:default}. Под этот селектор
подходит любой тест. Хитрость в том, что поведение \code{:default} можно
изменить. Ниже ему задали селектор, который вернёт все
\textbf{не}~интеграционные тесты. В результате \code{lein test} запустит только
модульные тесты. Чтобы прогнать весь проект, мы завели метку \code{:all},
которая вернёт истину для любого теста.

\ifnarrow

\begin{clojure}
:test-selectors
  {:default (complement :integration)
   :integration :integration
   :all (constantly true)}
\end{clojure}

\else

\begin{clojure}
:test-selectors {:default (complement :integration)
                 :integration :integration
                 :all (constantly true)}
\end{clojure}

\fi

Селектор может быть полноценной функцией. Предположим, часть программы
полагается на новые функции базы данных. Для каждого теста укажем минимальную
версию базы, поле \code{:db/version} с числом:

\begin{clojure}
(deftest ^{:db/version 11}
  test-some-feature
  ...)
\end{clojure}

Отнесём функциональность, которая требует версию базы выше 11, к
экспериментальному классу. Для этого напишем отдельный селектор. Запустите его
командой \code{lein test :db-experi\-men\-tal}:

\ifnarrow

\begin{clojure}
:test-selectors
  {:db-experimental
   (fn [test-meta]
     (some-> test-meta
             :db/version
             (>= 11)))}
\end{clojure}

\else

\begin{clojure}
:test-selectors
  {:db-experimental
    (fn [test-meta]
      (some-> test-meta :db/version (>= 11)))}
\end{clojure}

\fi

По умолчанию \code{lein} не предлагает \code{regex}-селекторов. Нельзя выбрать
тесты по частичному совпадению пространства или имени. Это легко исправить
селектором, который передаёт имя теста в \code{re-find}.

\ifnarrow

\begin{clojure}
:test-selectors
  {:test-api
   (fn [m]
     (->> m :name str
          (re-find #"^test-api")))}
\end{clojure}

\else

\begin{clojure}
:test-selectors
  {:test-api
    (fn [m] (->> m :name str
                 (re-find #"^test-api")))}
\end{clojure}

\fi

Он вернёт все тесты, чьи имена начинаются с \code{test-api}. Имя переменной~---
это символ, поэтому приводим его к строке. Обратите внимание: в ключе
\code{:name} метаданных содержится символ, а не строка. Следующая за ним
\code{str} приводит имя к строке. Кроме того, имя не содержит пространство;
последнее находится в поле \code{:ns} и~представляет собой не символ, а объект
\code{Namespace}. Добраться до имени пространства поможет функция
\code{ns-name}. Поиск по нему выглядит так:

\index{clojure.core!ns-name}
\index{классы!Namespace}

\ifnarrow

\begin{clojure}
:test-selectors
  {:test-ns-api
   (fn [m]
     (->> m :ns ns-name name
          (re-find #"^project.api")))}
\end{clojure}

\else

\begin{clojure}
:test-selectors
  {:test-ns-api
    (fn [m] (->> m :ns ns-name str
                 (re-find #"^project.api")))}
\end{clojure}

\fi

Новый селектор ищет только те тесты, чьи пространства начинаются
с~\code{project.api}. В него попадут условные модули \code{project.api.user},
\code{project.api.oreders} и другие.

Когда тестов много, расставлять теги утомительно. Повышается риск забыть тег, и
тест выпадет из набора. Если все тесты модуля связаны по смыслу, тег назначают
не тесту, а пространству. С точки зрения \code{lein} тест наследует теги
пространства, в котором объявлен:

\begin{clojure}
(ns ^:integration
  book.integration-test
  (:require [clojure.test :refer :all]))

(deftest test-user-login-ok
  ...)
\end{clojure}

Теперь не нужно указывать \code{\circum{}:integration} каждому тесту, поскольку мы
сделали это на уровне модуля. Селектор интеграционных тестов не изменится: его
метка и функция по-прежнему равны \code{:integration}. Тесты запускаются как
обычно:

\begin{bash}
$ lein test :integration
\end{bash}

\subsection{Тесты в Deps}

\index{тесты!deps.edn}
\index{утилиты!Deps}

Не все проекты на Clojure используют Lein; некоторые перешли
на~\footurl{Deps}{https://clojure.org/guides/deps\_and\_cli}[Deps],
утилиту для управления зависимостями от Cognitect. С версии 1.9 Deps идёт в
поставке Clojure.

\index{библиотеки!Test-runner}

Если проект работает на Deps, мы теряем возможности Lein, в том числе прогон
тестов. Чтобы компенсировать потери, в Deps подключают сторонние
библиотеки. Проект \footurl{Test-runner}{https://github.com/cognitect-labs/test-runner}[Test runner]
делает то же, что и~\code{lein test}: находит тесты, запускает их и выводит
отчёт.

Добавьте в файл \code{deps.edn} запись:

\ifnarrow

\begin{clojure}
:aliases
{:test
 {:extra-paths ["test"]
  :extra-deps
  {com.cognitect/test-runner
   {:git/url
    "https://github.com/
         cognitect-labs/test-runner.git"
    :sha "209b64...."}}
  :main-opts
  ["-m" "cognitect.test-runner"]}}
\end{clojure}

\else

\begin{clojure}
:aliases
{:test
 {:extra-paths ["test"]
  :extra-deps
  {com.cognitect/test-runner
   {:git/url "https://github.com/
              cognitect-labs/test-runner.git"
    :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
  :main-opts ["-m" "cognitect.test-runner"]}}
\end{clojure}

\fi

\index{алиас}
\index{прoфили!deps}

Ключ \code{:aliases} играет ту же роль, что и профили в \code{lein}~--- это
опции, которые включаются, если указан профиль. В ключе \code{:extra-paths}
список путей для поиска файлов с кодом. Поле \code{:extra-deps} указывает
зависимости в~дополнение к основным. Test-runner нужен только для тестов,
поэтому он не должен быть в глобальных зависимостях.

Коренное отличие Deps от Lein в том, что репозиторием может быть GitHub. Поле
\code{:sha} означает хэш коммита, что даёт более тонкий контроль над
версиями. Ключ \code{:main-opts} задаёт входную точку программы. Это функция
\code{-main} из модуля \code{cognitect.test-runner}.

Библиотека предлагает ключи для выборки тестов с логикой <<только с этим тегом>>
(\code{-i},~англ.~include~--- <<включить>>) или <<без этого тега>>
(\code{-e},~англ.~exclude~--- <<исключить>>). Команда ниже выполнит все тесты кроме
интеграционных:

\begin{bash}
clj -Atest -e :integration
\end{bash}

Селекторы в \code{test-runner} могут быть только ключами. Произвольные функции
вроде нашего \code{:db-experimental} не поддерживаются. Test-runner ищет
пространства по регулярному выражению (ключ \code{-r}, namespace-regex). С~ним
можно выбрать тесты по доменной структуре, например все дочерние модули
\code{project.api}.

\section{Проблема окружения}

\index{окружение}

До сих пор мы писали примитивные тесты, которые проверяют числа. На практике вы
столкнетесь с проблемой: в коде преобладают не вычисления, а ввод-вывод
данных. Это обращение к сторонним ресурсам: базе данных, очереди задач, HTTP
API. Такой код трудно тестировать по двум причинам.

\index{организации!Amazon}
\index{S3}

Во-первых, настроить локальное окружение стоит усилий, а иногда это
невозможно. Представим, что приложение загружает файлы в Amazon S3. Только
недавно появились проекты, которые имитируют S3 на локальной машине. Но ни одна
заглушка не гарантирует точного совпадения заголовков, сообщений об ошибке и так
далее. У вас может не быть ключей и сертификатов доступа. Если открыть их всем
разработчикам, инфраструктура фирмы окажется под угрозой.

Во-вторых, тесты плохо работают с данными, которые не контролируют. Если ответ
сервиса изменится, получим сломанный билд. Чтобы тест не зависел от окружения,
применяют моки и стабы. Разберёмся, что это такое и в чём плюсы и минусы
каждого.

\subsection{Моки}

\label{test-isolation}

\index{моки}

Мок (англ.~mock~--- <<ложный, фиктивный>>)~--- это объект, который временно
заменяет другой объект. При обращении к нему сработает не исходный код, а тот,
что мы указали. Часто моки накладывают на функции с выходом в сеть. С их помощью
проверяют, как поведёт себя код в разных ситуациях: данные получены, статус 403,
соединение не удалось.

\label{mobile-app-intro}

\index{веб-разработка}

Представим мобильное приложение для городского отдыха. На главном экране карта,
на которую нанесены кафе, рестораны и ближайшие события: фильмы, выставки,
фестивали. Данные приходят с сервера по протоколу HTTP в JSON. Функция
\code{view-main-page} принимает запрос с~координатами устройства, собирает
сведения о местах и событиях и~отсылает результат:

\ifnarrow

\begin{clojure}
(defn view-main-page [request]
  (let [location
        (-> request
            :params
            (select-keys [:lat :lon]))
        sites
        (get-sites-by-location location)
        events
        (get-events-by-location
          location)]
    {:status 200
     :body {:sites sites
            :events events}}))
\end{clojure}

\else

\begin{clojure}
(defn view-main-page [request]
  (let [location (-> request
                     :params
                     (select-keys [:lat :lon]))
        sites (get-sites-by-location location)
        events (get-events-by-location location)]
    {:status 200
     :body {:sites sites :events events}}))
\end{clojure}

\fi

Данные о местах и событиях приходят из условных сервисов Яндекс.Карт
и~Афиши. Функции \code{get-sites}\textbf{...} и \code{get-events}\textbf{...}
обращаются к ним по HTTP. Так выглядит функция
\code{get\-/sites\-/by\-/location} для поиска кафе и ресторанов в радиусе 300
метров:

\pagebreakafive

\index{HTTP!API}

\ifnarrow

\begin{clojure}
(ns book.views
  (:require
   [clj-http.client :as client]))

(defn get-sites-by-location
  [{:keys [lat lon]}]
  (-> {:method :get
       :url
       "https://maps.yandex.ru/search/v1"
       :as :json
       :query-params
       {:apikey "****"
        :lat lat :lon lon :distance 300
        :type "cafe,restaurant"}}
      client/request
      :body))
\end{clojure}

\else

\iflarge

\begin{clojure}
(ns book.views
  (:require [clj-http.client :as client]))
\end{clojure}

\pagebreaklarge

\begin{clojure}
(defn get-sites-by-location
  [{:keys [lat lon]}]
  (-> {:method :get
       :url "https://maps.yandex.ru/search/v1"
       :as :json
       :query-params {:apikey "****"
                      :lat lat
                      :lon lon
                      :distance 300
                      :type "cafe,restaurant"}}
      client/request
      :body))
\end{clojure}

\else

\begin{clojure}
(ns book.views
  (:require [clj-http.client :as client]))

(defn get-sites-by-location
  [{:keys [lat lon]}]
  (-> {:method :get
       :url "https://maps.yandex.ru/search/v1"
       :as :json
       :query-params {:apikey "****"
                      :lat lat
                      :lon lon
                      :distance 300
                      :type "cafe,restaurant"}}
      client/request
      :body))
\end{clojure}

\fi

\fi

Функция \code{get-events-by-location} для событий аналогична поиску
ресторанов. Разница в домене (не \code{maps.yandex.ru}, a
\code{events.afisha.ru}) и параметрах запроса.

Очевидно, \code{view-main-page} обращается в сеть дважды, что затрудняет
тестирование. Понадобится два API-ключа; если запускать тесты часто, мы
исчерпаем квоты на число запросов. Настоящие данные меняются и поэтому не
подходят для тестов: завтра откроется новое кафе или закроется старое. Решим
проблему моками.

\index{clojure.core!with-redefs}

В главе про изменяемость мы работали с \code{with-redefs} \page{with-redefs}.
Макрос заменяет переменную по её пути на что-то другое. Простейший мок подменяет
функцию с обращением в сеть на функцию с известным результатом.

Напишем тест главного экрана с двумя моками. Поместим ответы сервисов в
переменные \code{let}. Функцию \code{view-main-page} вызываем внутри
\code{with-redefs}, иначе эффект моков теряется.

\ifnarrow

\begin{clojure}
(deftest test-main-page
  (let [sites [{:name "Cafe1"}
               {:name "Cafe2"}]
        events [{:name "Event1"}
                {:name "Event2"}]]
    (with-redefs
      [book.views/get-sites-by-location
       (constantly sites)
       book.views/get-events-by-location
       (constantly events)]
      (let [request
            {:params {:lat 55.751244
                      :lon 37.618423}}
            result
            (view-main-page request)]
        (is (= {:sites sites
               :events events}
               (:body result)))))))
\end{clojure}

\else

\ifafive

\begin{clojure}
(deftest test-main-page
  (let [sites [{:name "Cafe1"} {:name "Cafe2"}]
        events [{:name "Event1"} {:name "Event2"}]]
\end{clojure}

\pagebreakafive

\begin{clojure}
    (with-redefs
      [book.views/get-sites-by-location
         (constantly sites)
       book.views/get-events-by-location
         (constantly events)]
      (let [request {:params {:lat 55.751244
                              :lon 37.618423}}
            result (view-main-page request)]
        (is (= {:sites sites :events events}
               (:body result)))))))
\end{clojure}

\else

\begin{clojure}
(deftest test-main-page
  (let [sites [{:name "Cafe1"} {:name "Cafe2"}]
        events [{:name "Event1"} {:name "Event2"}]]
    (with-redefs
      [book.views/get-sites-by-location
         (constantly sites)
       book.views/get-events-by-location
         (constantly events)]
      (let [request {:params {:lat 55.751244
                              :lon 37.618423}}
            result (view-main-page request)]
        (is (= {:sites sites :events events}
               (:body result)))))))
\end{clojure}

\fi

\fi

Мы избежали похода в сеть: тест не зависит от ключей, прав доступа и новых
заведений. Говорят, что он изолирован от окружения: запустите тест в любое
время, и результат не изменится. Далее мы рассмотрим, как улучшить тест.

\subsection{Вынести данные в файл}

Переменные \code{sites} и \code{events}, которые якобы пришли из сторонних
сервисов, крайне скудны. Сообщите им ответы реального источника~--- скажем,
десять ресторанов и семь мероприятий. Чтобы не засорять код огромными словарями,
поместите их в \code{.json}-файлы в папку ресурсов. Считайте файлы в переменную
модуля:

\index{файлы!для моков}

\begin{clojure}
(def data-events
  (-> "data/events.json"
      clojure.java.io/resource
      slurp
      (json/parse-string true)))
\end{clojure}

На практике функция \code{get-sites-by-loca\-ti\-on} сложнее, чем в
примере. Заведения фильтруют согласно внутренней логике. Например, исключают
кафе с низкой оценкой и те, что сейчас закрыты. Это порождает отдельный тест:
добавьте в файл кафе с низкой оценкой и~убедитесь, что его нет в ответе.

\subsection{Мок в фикстуре}

\index{фикстуры!для моков}

Если тестов несколько, оборачивать каждый в \code{with-redefs}
утомительно. Поместим мок в фикстуру. Так мы снизим повторы в коде, и~ей~смогут
пользоваться другие тесты.

\ifnarrow

\begin{clojure}
(defn fix-mock-sites-events [t]
  (with-redefs [...]
    (t)))

(use-fixtures :each
  fix-mock-sites-events)
\end{clojure}

\else

\begin{clojure}
(defn fix-mock-sites-events [t]
  (with-redefs [...]
    (t)))

(use-fixtures :each fix-mock-sites-events)
\end{clojure}

\fi

Недостаток фикстуры в том, для всех тестов она задаёт позитивный сценарий (оба
вызова прошли без ошибок). Для полноты картины нужно проверить ошибки.

\subsection{Негативные сценарии}

\index{ошибки!недоступность}

Недоступность сервиса не должна влиять на приложение в целом. Если возникли
проблемы с кафе, пользователь увидит мероприятия, и~наоборот. Возможно, он даже
не заметит проблемы: если локации не пришли, приложение покажет старые данные.

Чтобы проверить главный экран на устойчивость, нужны сценарии:

\begin{itemize}

\item
  получили кафе, но не события;

\item
  наоборот: кафе в порядке, ошибка с событиями;

\item
  не работают оба сервиса.

\end{itemize}

Под общими словами <<не работают>> имеют в виду:

\index{HTTP!403}
\index{HTTP!429}

\begin{itemize}

\item
  проблемы доступа или квот: статусы 403 и 429;

\item
  недоступность сервиса: статусы 500 и 503;

\item
  проблемы связи: таймаут соединения или поиск хоста.

\end{itemize}

Напишем макрос \code{with-mock}, который принимает путь к функции, результат
мока и тело, которое он оборачивает.

\index{макросы!with-mock}

\begin{clojure}
(defmacro with-mock
  [path result & body]
  `(with-redefs
     [~path (fn [& ~'_] ~result)]
     ~@body))
\end{clojure}

Важно: для замены \code{path} мы создаём функцию с помощью \code{fn}, а не
\code{constantly}. Дело в том, что \code{result} может быть не только
выражением, но и произвольным кодом. \code{Constantly}~--- это функция, поэтому её
аргументы вычисляются до того, как она сработает. Нельзя передать в неё код
c~исключением. Следующий код:

\ifnarrow

\begin{clojure}
(constantly
  (throw (new Exception "error")))
;; Execution error at...
\end{clojure}

\else

\begin{clojure}
(constantly (throw (new Exception "error")))
;; Execution error at...
;; error
\end{clojure}

\fi

\index{порядок вычислений}

\noindent
бросит исключение до входа в \code{with-redefs}. Наоборот, обёртка в
функцию откладывает исполнение кода до вызова:

\begin{clojure}
(fn [& _] (throw (new Exception "error")))
;; #function[eval53371/fn--53372]
\end{clojure}

С помощью \code{with-mock} описывают комбинации успехов и неудач. Тест ниже
проверяет сценарий, когда сервис кафе сработал без ошибок, а~с~событиями что-то
не так. Если запустить тест, окажется, что главный экран не ловит исключения, и
пользователь не получит ничего.

\ifnarrow

\begin{clojure/lines}
(deftest test-sites-ok-events-err
  (with-mock
    book.views/get-sites-by-location
    [...]
    (with-mock
     book.views/get-events-by-location
     (throw
      (new UnknownHostException
        "DNS error"))
     (let [req {...}
           res (view-main-page req)
           {:keys [status body]} res]
       (is (= 200 status))
       (is (= {...} body))))))
\end{clojure/lines}

\else

\begin{clojure/lines}
(deftest test-sites-ok-events-err
  (with-mock book.views/get-sites-by-location [...]
    (with-mock book.views/get-events-by-location
      (throw (new UnknownHostException "DNS error"))
      (let [request {...}
            response (view-main-page request)
            {:keys [status body]} response]
        (is (= 200 status))
        (is (= {...} body))))))
\end{clojure/lines}

\fi

Доработайте \code{view-main-page} так, чтобы тест получил ответ со статусом
200 и полем \code{:sites}. Добавьте тесты с другими комбинациями: ошибка
соединения в \code{get-sites}, статусы 403 и 500, недоступность сразу двух
сервисов.

Подумайте, как улучшить \code{with-mock}. Сейчас макросы вложены друг в друга,
что даёт отступы и лишний код \ifnarrow(строки 2 и 5)\else(строки 2 и 3)\fi. Сделайте так, чтобы
\code{with-mock} был похож на \code{let}~--- принимал форму связывания, где
нечётный элемент~--- путь к функции, а чётный~--- результат. Тогда каскад моков
можно будет заменить на один.

\subsection{Сбор данных}

\index{моки!сбор данных}

Не заглядывая в конец главы, подумайте, как сделать мок промышленного уровня. Он
не только возвращает результат, но и:

\begin{itemize}

\item
  считает, сколько раз его вызвали;

\item
  на каждый вызов запоминает аргументы;

\item
  принимает список результатов и возвращает их поочёредно, например первый и
  второй раз словари, а на третий~--- исключение;

\item
  предлагает удобный доступ к собранным данным.

\end{itemize}

Продвинутый мок следит за особой логикой. Например, поиск ресторанов вернёт
только базовые сведения о них. Чтобы получить подробные сведения о месте, нужно
слать отдельный запрос. Чтобы трафик не рос линейно, данные извлекают только для
трёх лучших ресторанов. Мок проверяет, что функцию \code{get-site-details}
вызвали не больше трёх раз. В конце главы мы рассмотрим библиотеки с такими
возможностями.

\subsection{Недостатки}

Кажется, что проблема ушла: тесты автономны и не зависят от сторонних
сервисов. Однако у моков свои недостатки, которые нужно иметь в~виду.

Мок нарушает принцип закрытости, или чёрного ящика. При написании теста мы
подглядываем в код, чтобы узнать, какие функции заменить. Это нечестно: чем
меньше тест знает о коде, который тестирует, тем он надёжней.

Мок исключает сетевое взаимодействие, что иногда выходит боком. Передача данных
по HTTP~--- сложный процесс, а подмена запроса на функцию~--- его грубое
приближение. С помощью подмены нельзя предугадать возможные ошибки.

Наконец, мок повышает связанность тестов с логикой. Если переименовать функцию,
которую мокают, форма \code{(with-redefs...)} перестанет работать. Мелкие правки
в коде повлияют на тесты, что неудобно и~неверно идеологически.

Эти проблемы решают стабы, о которых речь в следующем разделе.

\iflarge\vspace{15mm}\pagebreak[4]\fi

\subsection{Стабы}

\index{стабы}

Стаб (англ.~stub~--- <<заглушка>>)~--- это сущность, которая заменяет часть
системы на время тестов. От моков она отличается тем, что тест не может ей
управлять. Если моку указывают, что и чем заменить, то стаб~--- чёрный ящик с
точки зрения теста.

Удачный пример стаба~--- локальный сервер для поиска ресторанов. По адресу
\code{/search/v1} он вернёт данные, которые предварительно скопировали из
настоящего источника. Больше мы не будем мокать функцию
\code{get-sites-by-location}. Изменим её так, чтобы поле запроса \code{:url}
указывало на локальный адрес, а не условный Яндекс.

У подхода со стабом преимущество: он снимает зависимость теста от логики. Тест
не знает устройство кода, нужно только перенацелить запросы на другой адрес. Это
вопрос конфигурации, а логика программы не меняется.

Другое достоинство в том, что во время теста происходит настоящий обмен данными
по сети. Да, это локальный сервер без шифрования и проверки сертификатов. Но
основная часть HTTP протекает как в~боевом запуске. Приложение читает заголовки,
тело, парсит JSON, проверяет статус ответа. С моком мы пропускаем эти шаги.

\index{fake}

Сервера-заглушки ещё называют фейками (англ.~fake~--- <<подделка>>). С~помощью
фейка моделируют нештатное поведение сервера. Например, долгое ожидание,
медленную передачу данных или недоступность. Достичь таких эффектов моком
трудно. С его помощью можно только бросить исключение, которое ожидают от
HTTP-клиента. Однако тесты на исключениях далеки от реального положения дел.

Стаб легко ложится на концепцию фикстуры. До запуска теста она включает сервер,
а после выключает его. На роль сервера подходит Jetty или другой адаптер для
Ring. Мы подробно рассмотрели их в главе про веб-разработку \page{ring-jetty}.

Напишем фикстуру для сервера карт. Начнём с обработчика HTTP-запроса. Для пути
\code{/search/v1} сервер вернёт данные в JSON, а для остальных запросов~--- 404:

\label{sites-handler}

\iflarge\vspace{15mm}\pagebreak[4]\fi

\ifnarrow

\begin{clojure}
(defn sites-handler* [{:keys [uri]}]
  (case uri
    "/search/v1"
    {:status 200
     :body [{:name "Cafe1"
             :address "..."}
            {:name "Cafe2"
             :address "..."}]}
    {:status 404
     :body "page not found"}))
\end{clojure}

\else

\begin{clojure}
(defn sites-handler* [{:keys [uri]}]
  (case uri
    "/search/v1"
    {:status 200
     :body [{:name "Cafe1" :address "..."}
            {:name "Cafe2" :address "..."}]}
    {:status 404
     :body "page not found"}))
\end{clojure}

\fi

\index{middleware!стабы}

Обернём функцию в middleware. Мы хотим, чтобы коллекция из \code{:body}
приводилась в JSON автоматически. Кроме того, пригодятся параметры запроса:

\begin{clojure}
(def sites-handler
  (-> sites-handler*
      wrap-keyword-params
      wrap-params
      wrap-json-response))
\end{clojure}

Теперь упакуем приложение в фикстуру. Сервер не меняет состояние от теста к
тесту, потому что мы только читаем данные. Подключим фикстуру с ключом
\code{:once}, чтобы она сработала один раз:

\ifnarrow

\begin{clojure}
(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}
        server (run-jetty
                 sites-handler opt)]
    (t)
    (.stop server)))

(use-fixtures :once
  fix-fake-sites-server)
\end{clojure}

\else

\begin{clojure}
(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}
        server (run-jetty sites-handler opt)]
    (t)
    (.stop server)))

(use-fixtures :once fix-fake-sites-server)
\end{clojure}

\fi

\index{конфигурация}

Исправим функцию \code{get-sites-by-location} так, чтобы бекэнд обращался к
локальному хосту. Очевидно, базовый URL должен быть в~конфигурации. Вы уже
знаете, как устроена конфигурация, поэтому не будем приводить весь код. Для
краткости представим, что переменная \code{config}~--- словарь
параметров. Полный URL для карт построим так:

\pagebreaklarge

\ifnarrow

\begin{clojure}
(def config
  {:maps-base-url
     "http://127.0.0.1:8088"})

(let [{:keys [maps-base-url]} config
      url (str maps-base-url
               "/search/v1")]
  (client/get url {...}))
\end{clojure}

\else

\begin{clojure}
(def config
  {:maps-base-url "http://127.0.0.1:8088"})

(let [{:keys [maps-base-url]} config
      url (str maps-base-url "/search/v1")]
  (client/get url {...}))
\end{clojure}

\fi

Вернёмся к тесту главного экрана. Нам не нужны моки, поэтому уберём макросы
\code{with-mock}. Однако сейчас тест не пройдёт, потому что мы решили проблему
только с поиском заведений. Для событий код по-прежнему обращается к чужому
серверу. Временно закомментируем события, а поле \code{:events} сделаем
\code{nil}.

\begin{clojure}
(defn view-main-page [request]
  (let [...
        sites
        (get-sites-by-location location)

        ;; events
        ;; (get-events-by-location location)
       ]
    {:status 200
     :body {:sites sites :events nil}}))
\end{clojure}

Тест пройдёт без ошибок: в поле \code{:sites} окажутся данные, что вернул стаб.

\ifnarrow

\begin{clojure}
(deftest test-main-page
  (let [request
        {:params {:lat 55.751244
                  :lon 37.618423}}
        result (view-main-page request)]
    (is (= (:body result)
           {:sites [...] :events nil}))))
\end{clojure}

\else

\begin{clojure}
(deftest test-main-page
  (let [request {:params {:lat 55.751244
                          :lon 37.618423}}
        result (view-main-page request)]
    (is (= (:body result) {:sites [...] :events nil}))))
\end{clojure}

\fi

Раскомментируйте поиск событий и напишите для него похожую заглушку на другом
порту. Оформите её в фикстуру и убедитесь, что тест проходит.

\subsubsection*{Другие возможности}

Рассмотрим, что ещё интересного предлагают стабы. Как и в случае с моками,
удобно, когда ответы лежат в файлах. Чтобы фейковый сервер читал файл, передайте
его экземпляр в \code{:body} \page{http-files}:

\index{файлы!в стабах}

\begin{clojure}
{:status 200
 :body (-> "data/events.json"
           clojure.java.io/resource
           clojure.java.io/file)}
\end{clojure}

\noindent
В файл \code{resources/data/events.json} запишите данные, полученные
от~реального сервера.

\index{координаты}
\index{геолокация}

Стаб всегда возвращает успешный ответ, что неудобно. Научим его негативным
сценариям. Проще всего это сделать с помощью параметров. Договоримся, что
некоторые координаты, которые посылает пользователь, особые. Например, для пары
\tuple{0, 0} сервер вернёт пустой результат:

\begin{clojure/lines*}{firstnumber=1}
(defn sites-handler* [request]
  (let [{:keys [uri params]} request
        {:keys [lat lon]} params]
    (case uri
      "/search/v1"
      (case [lat lon]
        [ "0"  "0"]
        {:status 200 :body []}
\end{clojure/lines*}

\noindentnarrow
Комбинация \tuple{66, 66} означает ошибку доступа:

\begin{clojure/lines*}{firstnumber=9}
        ["66" "66"]
        {:status 403
         :body {:error "ACCESS_ERROR"}}
\end{clojure/lines*}

Для координат \tuple{42, 42} сервер отвечает с задержкой в 35 секунд:

\begin{clojure/lines*}{firstnumber=12}
        ["42" "42"]
        (do (Thread/sleep (* 1000 35))
            {:status 200 :body []})
\end{clojure/lines*}

В остальных случаях получим обычный ответ: 200 или 404.

\begin{clojure/lines*}{firstnumber=15}
        ;; else lat/lon
        {:status 200
         :body [{...} {...}]})
      ;; else path
      {:status 404
       :body "page not found"})))
\end{clojure/lines*}

\index{HTTP!ожидание}

Напишите тесты для этих координат. Особенно интересен случай с~долгим ответом
для пары \tuple{42, 42}. Убедимся, что если сервис карт не отвечает, мы ждём
разумное время, а не стандартные 30 секунд. Передайте в параметры
\code{(client/get)} поля \code{:socket-timeout} и \code{:connection-timeout} со
значением 5000, пять секунд. Этого хватит для боевого запуска. Замерьте
выполнение \code{view-main-page}. Добавьте проверку, что ожидание не превышает
пять секунд с небольшой погрешностью.

Тест на экстремальный случай: что произойдёт, если сервер недоступен? Чтобы
смоделировать ситуацию, у теста должен быть доступ к серверу. Поместим его в
динамическую переменную:

\index{недоступность}

\ifnarrow

\begin{clojure}
(defonce ^:dynamic *server* nil)

(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}]
    (binding [*server*
              (run-jetty
                sites-handler opt)]
      (t)
      (.stop *server*))))
\end{clojure}

\else

\begin{clojure}
(defonce ^:dynamic *server* nil)

(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}]
    (binding [*server*
              (run-jetty sites-handler opt)]
      (t)
      (.stop *server*))))
\end{clojure}

\fi

Напишем тест, в котором временно отключим сервер. В конце его нужно включить,
чтобы не задеть остальные тесты.

\begin{clojure}
(deftest test-the-website-is-down
  (.stop *server*)
  (let [request {:params {:lat 1 :lon 2}}
        result (view-main-page request)]
    (is (= (:body result) {...})))
  (.start *server*))
\end{clojure}

В результате поиск локаций бросит исключение Connection refused. Доработайте
код, чтобы клиент увидел пустой результат, а исключение осталось в логах и
Sentry.

\subsection{Ресурсы и пути}

\label{resources}

\index{JVM!ресурсы}
\index{файлы!ресурсы}

Мы упомянули, что данные для моков и стабов хранят в файлах. Так мы не засоряем
код объёмными словарями. Файлы в папке \code{resources} называются ресурсами
приложения. У них особая роль: при сборке jar-файла ресурсы становятся его
частью. Код из jar читает ресурсы сам из себя, словно это файлы рядом на диске.

Мы поместили файл \code{events.json} в папку \code{resources/data} и читали как
ресурс. Проблема в том, что этот файл нужен только для тестов. Если собрать
проект, \code{events.json} попадёт в jar, что напрасно увеличит его объём.

Чтобы отбросить лишние ресурсы при сборке, в проекте указывают
\code{:resource-paths}. Это вектор, в котором перечислены пути для поиска
ресурсов. По умолчанию он равен \code{["resources"]}. При слиянии профилей
векторы соединяются в один. Если другой профиль задал свои ресурсы:

\begin{clojure}
:resource-paths ["resources_test"]
\end{clojure}

\noindent
, то в итоге программа ищет их в обеих папках. Для боевой сборки оставим только
\code{resources}, чтобы не вбирать в jar ресурсы для тестов.

\index{env-директория}

Путь \code{resources\_test} выше выбран неудачно. Более удобный способ связать
файлы и окружение~--- это env-директория. На её первом уровне находятся папки с
именами профилей, а в них~--- \code{src} и \code{resources} с~кодом и ресурсами,
которые относятся к этому профилю.

Создайте папки и переместите ресурсы для теста:

\ifnarrow

\begin{bash}
$ mkdir -p env/test/resources/data
$ mv resources/data/events.json \
     env/test/resources/data/
\end{bash}

\else

\begin{bash}
$ mkdir -p env/test/resources/data
$ mv resources/data/events.json \
     env/test/resources/data/
\end{bash}

\fi

\noindent
Получилась структура:

\iflarge\vspace{15mm}\pagebreak[4]\fi

\begin{bash}
$ tree env
\end{bash}

\dirtree{%
 .1 env.
 .2 dev.
 .3 resources.
 .2 test.
 .3 resources.
 .4 data.
 .5 events.json.
}

\linegap

\noindent
Задайте профили в проекте:

\ifnarrow

\begin{clojure}
:profiles
  {:test {:resource-paths
          ["env/test/resources"]}
   :dev {:resource-paths
         ["env/test/resources"]}}
\end{clojure}

\else

\begin{clojure}
:profiles
{:test {:resource-paths ["env/test/resources"]}
        :dev {:resource-paths ["env/test/resources"]}}
\end{clojure}

\fi

На первый взгляд, странно, что для \code{:dev} и \code{:test} мы указали один и
тот же путь. Дело в том, что по умолчанию REPL запускается с профилем
\code{dev}, но не \code{test}. В разработке у нас не будет доступа к ресурсам из
\code{env/test}. Это влечёт неудобства: мы исправили код и вызвали тест из REPL,
но он не проходит из-за путей. Когда \code{:dev} учитывает ресурсы тестов,
проблемы не возникает.

\index{REPL}

Если вам не нравятся повторы в конфигурации, запустите REPL с~ключом
\code{with-profile +test}. Плюс перед профилем означает добавить его к
стандартному. Без плюса профиль заменит его.

\index{профили!lein}

Обратите внимание: вы переместили файл между папками, но для JVM это один и тот
же ресурс по пути \code{data/events.json}. Код его загрузки не изменился:

\begin{clojure}
(def data-events
  (-> "data/events.json"
      clojure.java.io/resource
      slurp
      (json/parse-string true)))
\end{clojure}

Любознательным читателям предлагаем эксперимент. Скомпилируйте \code{uberjar}
с разными ресурсами: в первый раз как обычно, а во второй~--- с опцией
\code{:resource-paths}:

\ifnarrow

\begin{clojure}
:profiles
  {:uberjar {:resource-paths
             ["env/test/resources"]}
\end{clojure}

\else

\begin{clojure}
:profiles {:uberjar {:resource-paths
                     ["env/test/resources"]}
\end{clojure}

\fi

После каждой сборки перенесите jar-файл из \code{target/uberjar} в~другую
папку. Распакуйте оба архива командой \code{jar}:

\begin{bash}
$ jar xf <project>.jar
\end{bash}

Во втором архиве вы обнаружите файл \code{data/\-events.json}. Убедитесь, что его
нет в первом архиве. Вашу программу распакует любой желающий, поэтому в ресурсах
не должно быть приватных данных вроде паролей и ключей. Это касается и данных
для тестирования~--- включить их в jar будет ошибкой.

Пользуясь случаем, изучите другие файлы из jar, их структуру и~содержимое.

\subsection{База данных}

\index{тесты!база данных}

При написании тестов вы столкнётесь с проблемой: почти каждое действие требует,
чтобы в базе лежали особые данные. Для создания пользователя нужен
администратор. Чтобы добавить участника в~группу, нужна эта группа. Чтобы
оформить заказ, нужны товары, история покупок для расчёта скидки и многое
другое. Чем шире логика приложения, тем больше нужно данных для теста.

Если каждый каждый раз готовить данные вручную, с тестами начнутся
проблемы. Нужна единая точка входа, чтобы каждый тест имел доступ к одинаковым
данным. В идеале данные декларативны и~находятся в файле. Чтобы добавить запись,
мы исправляем файл, а не код. Когда тесты закончились, содержимое базы
исчезает. Недопустимо, чтобы тест зависел от изменений, выполненных в другом
тесте.

В этом разделе мы рассмотрим, как работать с базой на время тестов. Начнём с
первого шага~--- подготовки базы. Под этим понимают создание таблиц, индексов и
других сущностей без вставки данных.

\index{утилиты!createuser}
\index{утилиты!createdb}

Базу создают до запуска тестов. Способ зависит от того, как она работает:
локально или в Docker. Если локально, вызовем несколько утилит. Ниже мы
обращаемся к \code{createuser} и \code{createdb} из поставки PostgreSQL:

\begin{bash}
$ createuser book_test -S -W
$ createdb -O book_test book_test
\end{bash}

Первая команда готовит пользователя с именем \code{book\_test}. Ключ~\code{-S}
означает, что это суперпользователь, обладатель высших привилегий. Супердоступ
нужен, чтобы включать расширения базы: триграммный поиск, прогрев индексов и
другие.

Вторая команда создаёт одноимённую пустую базу. Ключ \code{-O} (owner) задаёт
владельца базы. Владелец имеет полный доступ ко всем её сущностям. В боевом
запуске приложению выделяют минимальные права вплоть до отдельных таблиц, но для
тестов это неважно.

\index{Docker}

Если база работает в Docker, обратитесь к главе про системы. Там мы узнали, как
задать параметры базы в .yaml-файле и переменными среды \page{docker-db}.

\index{SQL!миграции}
\index{библиотеки!Migratus}

Пустую базу наполняют таблицами. Если приложение ведёт миграции, их запускают до
тестов из командной строки. Команда \code{migratus} доступна из одноимённой
библиотеки и \footurl{плагина к~Lein}{https://github.com/yogthos/migratus-lein}[Migratus]
для управления миграциями.

\begin{clojure}
$ lein migratus migrate
$ lein test
\end{clojure}

Прогона миграций можно избежать, если скопировать их в папку образа
\code{/docker-entry\-point-initdb.d}. Образ устроен так, что при запуске
выполнит все sql-файлы из этой папки. Убедитесь, что скопировали только
\code{up}-миграции, иначе их \code{down}-версии сведут пользу на нет.

Таблицы и индексы готовы, остались данные. Перечислим способы их вставки и
очистки во время тестов.

\subsubsection*{Ручная вставка}

В простом случае данные для тестов хранят в виде коллекции. Обычно это вектор с
именем таблицы и словарём полей:

\pagebreaklarge

\ifnarrow

\begin{clojure}
(def db-data
 [[:users {:name "Ivan"
           :email "ivan@test.com"}]
  [:users {:name "Juan"
           :email "Juan@test.com"}]
  [:groups {:name "Python fans"
            :topics 6}]
  [:groups {:name "Clojure fans"
            :topics 7}]])
\end{clojure}

\else

\begin{clojure}
(def db-data
  [[:users {:name "Ivan" :email "ivan@test.com"}]
   [:users {:name "Juan" :email "Juan@test.com"}]
   [:groups {:name "Python fans" :topics 6}]
   [:groups {:name "Clojure fans" :topics 7}]])
\end{clojure}

\fi

\index{JDBC!insert"!}

Специальная функция пробегает по списку словарей; каждый словарь~--- это запись
в базе. Функцию оборачивают в фикстуру, которая запускает тест после вставки
записей. Здесь и ниже мы полагаем, что переменная \code{*db*} означает
подключение к базе. Не важно, откуда пришла эта переменная: читатель знаком с
системами и конфигурацией и вправе задать \code{*db*} на своё усмотрение.

\begin{clojure}
;; loader
(defn load-data []
  (doseq [[table row] db-data]
    (jdbc/insert! *db* table row)))

;; fixture
(defn fix-db-data [t]
  (load-data)
  (t))
\end{clojure}

Для каждой записи нужно знать её таблицу. Это может быть первый элемент пары
\tuple{таблица, запись} как в примере выше или поле метаданных. Когда записей
одного типа много, добавлять таблицу в каждую из них избыточно. Сгруппируем
записи по таблицам и вставим не по одной, а разом, что быстрее.

\index{JDBC!insert-multi"!}

\ifnarrow

\begin{clojure}
(def db-data
  [[:users [{:name "Ivan"
             :email "ivan@test.com"}
            {:name "Juan"
             :email "Juan@test.com"}]]
  [:groups [{:name "Dog fans"
             :topics 6}
            {:name "Cat fans"
             :topics 7}]]])

(defn load-data []
 (doseq [[table rows] db-data]
  (jdbc/insert-multi! *db* table rows)))
\end{clojure}

\else

\begin{clojure}
(def db-data
  [[:users [{:name "Ivan" :email "ivan@test.com"}
            {:name "Juan" :email "Juan@test.com"}]]
   [:groups [{:name "Dog fans" :topics 6}
             {:name "Cat fans" :topics 7}]]])

(defn load-data []
  (doseq [[table rows] db-data]
    (jdbc/insert-multi! *db* table rows)))
\end{clojure}

\fi

Структура \code{db-data} напоминает словарь, но всё же им не является. Мы
намеренно используем вектор, чтобы гарантировать порядок обхода. Как мы увидим
далее, очерёдность загрузки важна.

\subsubsection*{Вставка из CSV}

\index{форматы!CSV}

Когда записей ещё больше, словари становятся неудобны. Ключи словаря занимают
половину его описания. Для тысячи записей мы столько же раз укажем ключи. Если
структура данных одинакова, их хранят в виде массива, а ключи указывают один
раз.

Именно так устроен формат \footurl{CSV}{https://en.wikipedia.org/wiki/Comma-separated\_values}[CSV].
Это текст, где каждая строка означает запись, а поля разделены запятой.
В первой строке обычно идёт заголовок~--- имена полей с тем же разделителем.

У CSV несколько преимуществ. Записи~--- это массивы, а не словари, поэтому имена
полей не повторяются. CSV компактней JSON и аналогов. С ним работают табличные
редакторы Excel и OpenOffice. Можно открыть CSV как электронную таблицу,
добавить или удалить столбец, пересчитать ячейки формулой и сохранить результат.

\index{SQL!INSERT}

Отдельные базы читают и пишут CSV напрямую. На больших объёмах вставка из CSV
работает быстрее, чем обычный \code{INSERT}.

Предположим, нам скинули данные о пользователях в CSV. Поместим их в ресурс по
пути \code{data/users.csv}. Несколько первых строк:

\begin{text}
name,age,email
Ivan,34,ivan@test.me
Juan,39,juan@example.com
Ioan,19,ioan@dunno.org
\end{text}

\index{SQL!COPY}

Составим запрос с командой \code{COPY}. Это особый оператор, который работает в
PostgreSQL. Укажем таблицу, путь к CSV-файлу и его свойства. Под свойствами
понимают разделитель, формат файла и~признак заголовка. Разделителем могут быть
не только запятая, но и точка с~запятой или табуляция. Если заголовка нет,
считается, что поля идут в том же порядке, что и в таблице.

\pagebreaklarge

\begin{clojure}
(jdbc/execute! *db*
 "COPY users(name, age, email)
  FROM '/Users/ivan/work/book/
        env/test/resources/data/users.csv'
  DELIMITER ',' CSV HEADER")
\end{clojure}

Заметим, что запрос ожидает полный путь к файлу, что мешает командной
работе. Вряд ли ваши коллеги держат проект в папке
\code{/Users/\-ivan/\-work/\-book}. На практике полный путь к файлу вычисляют из
относительного.

Если в запросе нет ошибок, и файл на месте, и пользователю хватает прав, то в
таблице \code{users} окажутся данные из файла. Аналогично работает сброс таблицы
в файл: оператор \code{FROM} заменяют на \code{TO}.

\index{Gzip}
\index{классы!GZIPInputStream}
\index{классы!CopyManager}

Выполним загрузку из CSV силами Clojure. Усложним задачу тем, что в файле очень
много записей и потому он сжат алгоритмом GZip. Это полезная практика: все
большие файлы в репозитории должны быть сжаты. Чтобы читать такой файл на лету
(не выгружая во временную папку), понадобятся классы:

\begin{clojure}
(:import java.io.FileInputStream
         java.util.zip.GZIPInputStream
         org.postgresql.copy.CopyManager)
\end{clojure}

Класс \code{CopyManager}~--- это обёртка над командой \code{COPY}. Его
конструктор принимает соединение с базой. Уточним: именно открытое
TCP-соединение, а не словарь. Получим его функцией \code{jdbc/get-connection} из
спеки подключения \ifnarrow(строки 2--3)\else(строка~2)\fi.

Метод \code{copyIn} ожидает SQL-запрос с оператором \code{COPY} и поток данных
CSV. Поток получим из ресурса \code{data/users.csv.gz}, пропустив его через
серию функций и классов \ifnarrow(строки 5--10)\else(строки
4--8)\fi. Класс \code{GZIPInputStream} оборачивает поток и~при чтении декодирует
данные в полёте.  В конце работы закрываем соединение с базой.

\index{JDBC!get-connection}

\ifnarrow

\begin{clojure/lines}
(defn load-data-gz []
  (let [conn
        (jdbc/get-connection *db*)
        copy (CopyManager. conn)
        stream
        (-> "data/users.csv.gz"
            clojure.java.io/resource
            clojure.java.io/file
            FileInputStream.
            GZIPInputStream.)]
   (.copyIn copy
     "COPY users(name, age, email)
      FROM STDIN
      (FORMAT CSV, HEADER true)"
     stream)
   (.close conn)))
\end{clojure/lines}

\else

\begin{clojure/lines}
(defn load-data-gz []
  (let [conn (jdbc/get-connection *db*)
        copy (CopyManager. conn)
        stream (-> "data/users.csv.gz"
                   clojure.java.io/resource
                   clojure.java.io/file
                   FileInputStream.
                   GZIPInputStream.)]
    (.copyIn copy "COPY users(name, age, email)
             FROM STDIN (FORMAT CSV, HEADER true)"
             stream)
    (.close conn)))
\end{clojure/lines}

\fi

Нельзя загрузить один файл сразу в несколько таблиц. Соблюдайте правило: один
файл~--- одна таблица. Если файлов несколько, перепишите функцию так, чтобы она
принимала путь к файлу и имя таблицы. Импорт очень больших данных (миллион и
больше) можно вести параллельно. Для этого CSV разбивают на несколько потоков,
каждый из которых читает свою часть файла. Их загружают одновременно с~помощью
\code{pmap}.

\subsubsection*{Проблема ключей}

\index{ключи!первичный}
\index{ключи!внешний}

\index{Primary Key}
\index{Foreign Key}

Таблицы редко существуют сами по себе. Чаще всего они связаны: пользователь
ссылается на профиль, заказ на пользователя и так далее. Для этого служат
первичный и внешний ключи. Первичный ключ (PK, Primary Key)~--- поле, которое
однозначно определяет запись в~таблице. Внешний ключ (FK, Foreign Key)~--- поле,
которое ссылается на первичный ключ другой таблицы. Вместе они называются
отношением таблиц.

\index{счётчики!в базе данных}

Как правило, первичные ключи~--- это целые числа с автоматической
нумерацией. Чтобы добавить запись в таблицу, не нужно подбирать новый ключ: база
ведёт для него уникальный счётчик. Для очередной записи он вырастет на
единицу. Имя счётчика в PostgreSQL строится по шаблону \code{<table>\_<pk>\_seq},
например \code{users\_id\_seq}.

Чтобы связать записи, задайте их первичному и внешнему ключам (PK и FK)
одинаковые значения. Ниже пользователь ссылается на группу; ключ этой группы
взяли случайно.

\ifnarrow

\begin{clojure}
(def group-id 3)
(jdbc/insert! *db* :groups
  {:id group-id :name "Clojure users"})
(jdbc/insert! *db* :users
  {:group_id group-id :name "Ivan"})
\end{clojure}

\else

\begin{clojure}
(def group-id 3)
(jdbc/insert! *db* :groups
   {:id group-id :name "Clojure users"})
(jdbc/insert! *db* :users
   {:group_id group-id :name "Ivan"})
\end{clojure}

\fi

Проблема в том, что заданный вручную PK может вступить в~конфликт со
счётчиком. Предположим, при вставке в \code{groups} счётчик был равен
нулю. Поскольку мы задали \code{id} явно, обращения к счётчику не было, и он не
увеличился.

Теперь нужны ещё три группы. Нам не важен их \code{id}, поэтому не будем
указывать его при вставке. В этот раз ключ приходит из счётчика. Две первые
группы получат значения 1 и 2. Для третьей возникнет ошибка:

\index{конфликты ключей}

\begin{text}
ERROR: duplicate key violates
       unique constraint 'groups_pkey'
DETAIL: Key (id)=(3) already exists
\end{text}

Ключ 3 в конфликте с записью, которую мы добавили раньше. Если выполнить запрос
ещё раз, ошибка уйдёт, потому что счётчик перескочил проблемное место и стал
равен 4. Однако хотелось бы понять, как не допустить конфликта ключей в будущем.
Избежать этого можно двумя способами: коррекцией счётчиков и~особой загрузкой
данных. Разница в том, кто контролирует счётчики: вы или база данных.

Под ручной коррекцией имеют в виду следующее. В тестовых данных явно указывают
первичные ключи. Для удобства некоторые из них выносят в переменную. Например,
если на администратора ссылаются несколько сущностей, вынесем его ключ в
переменную:

\ifnarrow

\begin{clojure}
(def id-admin 1)

(def db-data
  [[:users [{:id id-admin
             :name "Ivan"}]]
   [:profiles [{:id 1
                :user_id id-admin
                :avatar "..."}]
    :posts [{:id 1
             :user_id id-admin
             :title "New book"}
            {:id 2
             :user_id id-admin
             :title "Some post"}]]])
\end{clojure}

\else

\begin{clojure}
(def id-admin 1)

(def db-data
  [[:users [{:id id-admin :name "Ivan"}]]
   [:profiles [{:id 1 :user_id id-admin :avatar "..."}]
    :posts [{:id 1 :user_id id-admin
             :title "New book"}
            {:id 2 :user_id id-admin
             :title "Some post"}]]])
\end{clojure}

\fi

\index{счётчики!сброс}

После вставки исправим счётчики так, чтобы они перескочили значения, которые мы
использовали. Предположим, в тестовый набор входит семь пользователей, и мы
назначили им ключи от 1 до 7. Если установить счётчик в 100, он уже не вернётся
к числам от 1 до 7. Новые записи в \code{users} получат ключи 101, 102 и так
далее. Чтобы передвинуть счётчик, выполните запрос:

\ifnarrow

\begin{clojure}
(jdbc/execute! *db*
  "ALTER SEQUENCE users_id_seq
   RESTART WITH 100")
\end{clojure}

\else

\begin{clojure}
(jdbc/execute! *db*
  "ALTER SEQUENCE users_id_seq RESTART WITH 100")
\end{clojure}

\fi

Если первичный ключ называется \code{id} (что рекомендуется), то потребуется
только имя таблицы. Чтобы не перечислять таблицы вручную, получим их из массива
\code{db-data}. Добавьте в конец \code{load-data} вызов функции:

\index{SQL!ALTER SEQUENCE}

\ifnarrow

\begin{clojure}
(defn restart-db-ids []
  (let [value 100
        tables (set (map first db-data))
        query "ALTER SEQUENCE %s_id_seq
               RESTART WITH %s"]
    (doseq [table tables]
      (jdbc/execute! *db*
        (format query
          (name table) value)))))
\end{clojure}

\else

\begin{clojure}
(defn restart-db-ids []
  (let [value 100
        tables (set (map first db-data))
        query "ALTER SEQUENCE %s_id_seq RESTART WITH %s"]
    (doseq [table tables]
      (jdbc/execute! *db*
         (format query (name table) value)))))
\end{clojure}

\fi

Он подхватит все таблицы из \code{db-data} и выставит счётчики их ключей в
100. На больших данных из CSV эту цифру придётся увеличить на порядок или
два. Если потребуется, по \code{id} вы отличите исходную запись от добавленной в
процессе. Запрос \code{DELETE ... WHERE id > 100} удалит записи, которые попали
в базу уже после <<накрутки>> счётчиков.

Теперь рассмотрим загрузчик. В этом случае полагаются на ключи, которые вернула
база данных. Конкретные их значения не важны. Главное, чтобы у связанных записей
первичный и внешний ключи совпадали. Для этого пойдём на хитрость.

Для начала удалим первичные ключи из тестовых данных. Ни в~одном словаре нет
поля \code{:id} с конкретным значением. Сущностям, на которые нужно ссылаться,
присвоим псевдонимы. Проще всего это сделать через метаданные. В полях, которые
ссылаются на другие записи, вместо чисел укажем псевдоним.

\index{метаданные}

\ifnarrow

\begin{clojure}
;; users
^{:db/alias :users/admin}
 {:name "Ivan" :email "ivan@test.com"}

;; posts
{:user_id :users/admin
 :title "New book"}
{:user_id :users/admin
 :title "Some post"}
\end{clojure}

\else

\iflarge

\begin{clojure}
;; users
^{:db/alias :users/admin}
 {:name "Ivan" :email "ivan@test.com"}
\end{clojure}

\pagebreaklarge

\begin{clojure}
;; posts
{:user_id :users/admin :title "New book"}
{:user_id :users/admin :title "Some post"}
\end{clojure}

\else

\begin{clojure}
;; users
^{:db/alias :users/admin}
 {:name "Ivan" :email "ivan@test.com"}

;; posts
{:user_id :users/admin :title "New book"}
{:user_id :users/admin :title "Some post"}
\end{clojure}

\fi

\fi

Загрузчик объявляет атом с пустым словарём и наполняет его в~процессе. Если в
метаданных записи псевдоним, мы связываем его с ключом, который вернула
база. Например, при вставке первого словаря получили \code{id}, равный 5. Атом
станет \code{{:users/admin 5}}.

Перед вставкой загрузчик просматривает тот же атом на предмет ссылок. Если
значение поля~--- кейворд, считаем, что это внешний ключ. В профиле встречается
поле \code{:user\_id} со значением \code{:users/admin}. Очевидно, нужно заменить
его на то, что лежит в атоме по этому ключу, в нашем случае~--- число 5. Если в
атоме нет ключа, бросить исключение.

\index{базы данных!MariaDB}

Зная алгоритм, напишите загрузчик самостоятельно. Имейте в виду, что ответ
\code{jdbc/insert!} зависит от типа базы данных. Привёдем примеры для популярных
баз PostgreSQL и MariaDB (форк MySQL):

\ifnarrow

\begin{clojure}
(jdbc/insert! *db*
  :users {:name "Ivan"})
({:id 5 :name "Ivan"}) ;; for PostgreSQL
({:generated_key 5})   ;; for MariaDB
\end{clojure}

\else

\begin{clojure}
(jdbc/insert! *db* :users {:name "Ivan"})
({:id 5 :name "Ivan"}) ;; for PostgreSQL
({:generated_key 5})   ;; for MariaDB
\end{clojure}

\fi

Результат вставки~--- это список с одним элементом. В случае с MariaDB ключ
называется \code{:generated\_key} независимо от того, как он задан в
таблице. Наоборот, в ответе PostgreSQL ключ совпадает с определением в базе.
Если вы поддерживаете обе системы, пригодится универсальный поиск ключа:

\begin{clojure}
(defn insert->pk [result]
  (let [[row] result
        {:keys [id generated_key]} row]
    (or id generated_key)))
\end{clojure}

\subsubsection*{Удаление данных}

\index{фикстуры!очистка данных}
\index{SQL!DELETE FROM}

Очистка базы столь же важна, как и наполнение. Она должна занимать минимум
усилий и не оставлять артефактов.

Наивный способ очистить базу~--- выполнить \code{DELETE FROM} для всех
таблиц, с которыми работают тесты. Проблема \code{DELETE} в том, что он
учитывает зависимость ключей. Нельзя удалить пользователя, если на него
ссылается профиль. Придётся вызвать \code{DELETE} в правильном порядке:
сначала для \code{profiles}, затем для \code{users}. Чем больше таблиц, тем
сложнее запомнить порядок.

\index{SQL!ON DELETE}

Читатель, знакомый с PostgreSQL, возразит: каскадное удаление возможно при
помощи \code{ON DELETE} в описании ключа. Это продвинутая техника, и сейчас
мы не будем о ней говорить. Нас интересует, как очистить данные независимо от
того, как заданы ключи и ссылки.

\index{SQL!TRUNCATE}

Команда \code{TRUNCATE} \eng{подрезать} нужна для быстрой очистки таблицы. В
отличие от \code{DELETE}, она не вызывает триггеры и не сканирует всю
таблицу. \code{TRUNCATE} принимает несколько таблиц за раз. Её~преимущество в
каскадном режиме. Если передан флаг \code{CASCADE}, все таблицы из графа связей
тоже очищаются. Каскадная очистка пары таблиц вызывает цепную реакцию по всей
базе.

\index{функции!fix-db-data}

Напишем функцию очистки. Она посылает запрос, в котором через запятую указаны
таблицы из данных для тестов. Добавьте её в~фикстуру
\code{fix-db-data} \page{fix-db-data} после вызова \code{(t)}.

\ifnarrow

\begin{clojure}
(defn delete-data []
  (let [tables (set (map first db-data))
        tables-comma
        (str/join "," (map name tables))
        query
        (format "TRUNCATE %s CASCADE"
          tables-comma)]
    (jdbc/execute! *db* query)))
\end{clojure}

\else

\begin{clojure}
(defn delete-data []
  (let [tables (set (map first db-data))
        tables-comma (str/join "," (map name tables))
        query (format "TRUNCATE %s CASCADE" tables-comma)]
    (jdbc/execute! *db* query)))
\end{clojure}

\fi

\subsubsection*{Транзакция с откатом}

\index{транзакции!в тестах}

\index{SQL!BEGIN}
\index{SQL!COMMIT}

Другой способ избавиться от изменений в базе~--- обернуть действия с ней в
особую транзакцию. Она завершается оператором не \code{COMMIT}, а
\code{ROLLBACK}, что значит <<откатить команды>>. С точки зрения базы наши
действия выглядят так:

\begin{sql}
BEGIN;
INSERT INTO users ...
INSERT INTO profiles ...
UPDATE users SET name=...
ROLLBACK;
\end{sql}

При выходе из транзакции мы не увидим эффекта \code{INSERT}, \code{UPDATE} и
других изменений.

В пакет JDBC входит функция \code{db-set-roll\-back-only!}. Она принимает
транзакционное соединение и выставляет ему флаг \code{rollback}. Если флаг
установлен, JDBC завершает блок откатом.

\index{макросы!with-db-transaction}

Вы уже знакомы с макросом \code{with-db-tran\-saction}: внутри него действует
транзакционное соединение, которое получают из JDBC-спеки. Наш макрос
\code{with-db-rollback} делает то же самое, но устанавливает откат:

\ifnarrow

\begin{clojure}
(defmacro with-db-rollback
  [[t-conn & bindings] & body]
  `(jdbc/with-db-transaction
     [~t-conn ~@bindings]
     (jdbc/db-set-rollback-only!
       ~t-conn)
     ~@body))
\end{clojure}

\else

\begin{clojure}
(defmacro with-db-rollback
  [[t-conn & bindings] & body]
  `(jdbc/with-db-transaction [~t-conn ~@bindings]
     (jdbc/db-set-rollback-only! ~t-conn)
     ~@body))
\end{clojure}

\fi

Вне макроса вы не найдёте в базе тех изменений, что наблюдали внутри него. В
действии:

\ifnarrow

\begin{clojure}
(with-db-rollback [tx *db*]
  (println "Inserting the data...")
  (jdbc/insert! tx
    :users {:name "Ivan"})
  (let [...]
    (do-something-with-db tx)))
\end{clojure}

\else

\begin{clojure}
(with-db-rollback [tx *db*]
  (println "Inserting the data...")
  (jdbc/insert! tx :users {:name "Ivan"})
  (let [...]
    (do-something-with-db tx)))
\end{clojure}

\fi

Следите за тем, чтобы все действия с базой протекали через \code{tx}, а~не
\code{*db*}. Изменения в рамках обычного соединения останутся в базе. Этим
страдает загрузчик \code{load-data}, который ссылается на глобальную переменную
\code{*db*}. Если загрузчик <<упал>> на середине, половина данных останется в
базе. Чтобы загрузка была в транзакции, передайте транзакционное соединение в
параметрах или свяжите его с \code{*db*} формой \code{binding}.

Случай с параметром: \code{load-data} принимает \code{tx}, который мы
установили на вершине теста.

\ifnarrow

\begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (load-data tx) ;; takes a parameter
    (let [user
          (get-user-by-name tx "Ivan")]
      (is (= "Ivan" (:name user))))))
\end{clojure}

\else

\begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (load-data tx) ;; takes a parameter
    (let [user (get-user-by-name tx "Ivan")]
      (is (= "Ivan" (:name user))))))
\end{clojure}

\fi

\index{clojure.core!binding}

Вариант с динамической переменной. В этом случае мы считаем, что все функции
ссылаются на \code{*db*}. Внутри макроса она станет транзакционным соединением
с откатом.

\ifnarrow

\begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (binding [*db* tx]
      (load-data) ;; no parameters
      (let [user
            (get-user-by-name "Ivan")]
        (is (= "Ivan" (:name user)))))))
\end{clojure}

\else

\begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (binding [*db* tx]
      (load-data) ;; no parameters
      (let [user (get-user-by-name "Ivan")]
        (is (= "Ivan" (:name user)))))))
\end{clojure}

\fi

Выбор зависит от того, как в проекте работают с базой. Решение с откатом
подходит для Mount и похожей архитектуры, где база~--- это глобальная
переменная. Подумайте, как написать фикстуру с макросом
\code{with-db-rollback}. Будет ли она работать с системой компонентов? Что
необходимо в этом случае?

\section{Тестирование веб-приложе\-ний}

\index{тесты!для веб-приложений}

Тесты на отдельные функции необходимы, но не недостаточны. Они защищают
отдельные части проекта от изменений, но не обещают, что система
устойчива. Поднимемся выше и рассмотрим, как тестировать приложение целиком.

В главе про веб-разработку мы пришли к важному выводу. На~каждом уровне
приложение ведёт себя как функция одного аргумента. Обработчик запроса, маршруты
и стек middleware~--- это функции, которые принимают запрос и возвращают
ответ \page{http-all-function}.

Чтобы написать тест, составим запрос и вызовем приложение как функцию. Проверим
статус ответа на успех (200, 201) или неудачу (404, 403). Если это ответ с JSON,
прочитаем данные из тела и сравним с~образцом.

Вспомним веб-приложение из первой главы \page{compojure}. Отдельные страницы мы
соединили в маршруты с помощью Compojure. Получилось <<голое>> приложение. Оно
многого не умеет, в том числе читать параметры, работать с JSON, сессиями и так
далее.

\pagebreaklarge

\index{middleware}

\ifnarrow

\begin{clojure}
(defroutes app-naked
  (GET "/"
    request (page-index request))
  (GET "/hello"
    request (page-hello request))
  page-404)
\end{clojure}

Чтобы научить всему этому приложение, его оборачивают в middleware.

\begin{clojure}
(def app
  (-> app-naked
      wrap-session
      wrap-keyword-params
      wrap-params
      wrap-json-body
      wrap-json-response))
\end{clojure}

\else

\begin{clojure}
(defroutes app-naked
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)

(def app
  (-> app-naked
      wrap-session
      wrap-keyword-params
      wrap-params
      wrap-json-body
      wrap-json-response))
\end{clojure}

\fi

Напишем несколько тестов для приложения. Для экономии места сверим только статус
ответа, не заглядывая в \code{body}. Проверим главную страницу:

\ifnarrow

\begin{clojure}
(deftest test-app-index
  (let [request {:request-method :get
                 :uri "/"}
        response (app request)
        {:keys [status body]} response]
    (is (= 200 status))))
\end{clojure}

\else

\begin{clojure}
(deftest test-app-index
  (let [request {:request-method :get :uri "/"}
        response (app request)
        {:keys [status body]} response]
    (is (= 200 status))))
\end{clojure}

\fi

Для пути, которого нет в маршрутах, ожидаем статус 404:

\ifnarrow

\begin{clojure}
(deftest test-app-page-not-found
  (let [request {:request-method :get
                 :uri "/missing"}
        response (app request)
        {:keys [status body]} response]
    (is (= 404 status))))
\end{clojure}

\else

\begin{clojure}
(deftest test-app-page-not-found
  (let [request {:request-method :get :uri "/missing"}
        response (app request)
        {:keys [status body]} response]
    (is (= 404 status))))
\end{clojure}

\fi

\index{моки}

Как видно из примеров, писать тесты для веб-приложения нетрудно. Если страница
обращается в сеть, вызов <<мокают>> или запускают стаб, как мы делали это с
поиском кафе и событий для мобильного приложения \page{mobile-app-intro}.
Перечислим несколько новых приёмов, которые облегчат вашу работу.

\subsubsection*{Приложение целиком}

Избегайте ситуации, когда тест вызывает не приложение, а один из~обработчиков
\coderef{3}:

\begin{clojure/lines}
(deftest test-page-handler
  (let [req {:request-method :get}
        res (some-page-handler req)
        {:keys [status]} res]
    (is (= 200 status))))
\end{clojure/lines}

Даже если страница работает, нет гарантии, что запрос пройдёт сквозь стек
middleware. В боевых проектах он несёт важную логику, в~том числе проверку
доступа. Убрав middleware из теста, вы обманываете себя. Обработчик, который вы
тестируете, должен быть максимально <<заряжен>>, то есть близок к настоящему
приложению.

\subsubsection*{Библиотека запросов}

Выше мы объявили запрос в виде словаря. Это удобно, когда нет параметров или
тела. Если странице нужны параметры, придётся писать их в виде длинной строки,
что нечитаемо и тяжело в поддержке.

\ifnarrow

\begin{clojure}
{:request-method :get
 :uri
 "/users/?page=2&order=
                 date_added&name=ivan"}
\end{clojure}

\else

\begin{clojure}
{:request-method :get
 :uri "/users/?page=2&order=date_added&name=ivan"}
\end{clojure}

\fi

\index{библиотеки!Ring-mock}

Чтобы избежать ошибок, подключите
\footurl{Ring\-/mock}{https://github.com/ring-clojure/ring-mock}[Ring\\*mock]~---
библиотеку запросов к Ring-при\-ло\-же\-нию. Её функция \code{request} принимает
метод и путь. Если добавить словарь параметров, то для \code{GET} они станут
частью адреса, а для \code{POST}~--- его телом. Библиотека берёт на себя
URL-кодирование. Функция \code{json-body} подготовит тело с потоком, в который
записана коллекция.

Рассмотрим несколько примеров. \code{GET}-запрос по адресу \code{/help} :

\begin{clojure}
(mock/request :get "/help")
\end{clojure}

\noindent
Поиск фильмов с параметрами:

\ifnarrow

\begin{clojure}
(mock/request :get "/movies"
  {:search "batman" :page 1})
\end{clojure}

\else

\ifafive

\begin{clojure}
(mock/request :get "/movies"
              {:search "batman" :page 1})
\end{clojure}

\else

\begin{clojure}
(mock/request :get "/movies" {:search "batman" :page 1})
\end{clojure}

\fi

\fi

\index{HTTP!POST}
\index{классы!ByteArrayInputStream}
\index{заголовки!Content-Type}

\noindent
Отправка формы методом POST. Тело запроса станет потоком байтов, классом
\code{ByteArrayInputStream}. Внутри него~--- закодированные поля
формы. Заголовок \code{Content-Type} примет значение
\code{application/x-www-form-urlencoded}:

\ifnarrow

\begin{clojure}
(mock/request :post "/users"
  {:name "Ivan" :email "test@test.com"})
\end{clojure}

\else

\begin{clojure}
(mock/request :post "/users"
              {:name "Ivan" :email "test@test.com"})
\end{clojure}

\fi

\index{HTTP!API}

\noindent
Случай для REST API. Ресурс \code{/users} ожидает не поля формы, а~JSON.
Функция \code{json-body} дополняет запрос телом и заголовками:

\ifnarrow

\begin{clojure}
(-> (mock/request :post "/users")
    (mock/json-body
      {:name "Ivan"
       :email "test@test.com"}))
\end{clojure}

\else

\begin{clojure}
(-> (mock/request :post "/users")
    (mock/json-body
      {:name "Ivan" :email "test@test.com"}))
\end{clojure}

\fi

\noindent
Эти и другие функции смотрите в документации проекта.

\subsubsection*{Проверка тела}

Выше мы проверяли только статус ответа. На практике статуса недостаточно: число
200 ещё не говорит, что пришло именно то, что нужно. Проверка тела зависит от
его типа. Если это текст или HTML, пользуются регулярным выражением. Например,
по фразе Login мы определим, что на этой странице пользователь не авторизован.

\index{форматы!JSON}

Интереснее вариант с JSON, когда мы тестируем API. Нужно восстановить из тела
коллекцию и сравнить с образцом. Обратимся к~приложению \code{sites-handler},
которое мы написали в качестве заглушки для поиска кафе \page{sites-handler}.
Выполним к нему запрос:

\pagebreakafive

\ifnarrow

\begin{clojure}
(let [request (mock/request
                :get "/search/v1"
                {:lat 11 :lon 22})
      response (sites-handler request)
      body (-> response
               :body
               (json/parse-string
                 true))]
  (is (= {...} body)))
\end{clojure}

\else

\ifafive

\begin{clojure}
(let [request (mock/request
                :get "/search/v1"
                {:lat 11 :lon 22})
      response (sites-handler request)
      body (-> response
               :body
               (json/parse-string true))]
  (is (= {...} body)))
\end{clojure}

\else

\begin{clojure}
(let [request (mock/request :get "/search/v1"
                            {:lat 11 :lon 22})
      response (sites-handler request)
      body (-> response
               :body
               (json/parse-string true))]
  (is (= {...} body)))
\end{clojure}

\fi

\fi

Недостаток в том, что мы сравниваем данные как есть. Некоторые поля ответа,
например даты или ключи сущностей, меняются со временем. Мы уже выяснили, что
\code{id}~--- это ключ с автонумерацией. Если удалить данные и загрузить
повторно, их первичные ключи изменятся.

Перед сравнением лишние поля исключают с помощью \code{dissoc}
и~\code{map}. Представим, что поиск кафе вернул результат:

\begin{clojure}
{:sites [{:name "Site1"
          :date-updated "2019-11-12"
          :id 42}
         {:name "Site2"
          :date-updated "2019-11-10"
          :id 99}]}
\end{clojure}

\index{итерация!for}

\noindent
Напишем функцию, которая очистит тело от лишних полей.

\ifnarrow

\begin{clojure}
(defn clean-sites [body]
 (update body :sites
  (fn [sites]
   (for [site sites]
    (dissoc site :id :date-updated)))))
\end{clojure}

\else

\begin{clojure}
(defn clean-sites [body]
  (update body :sites
          (fn [sites]
            (for [site sites]
              (dissoc site :id :date-updated)))))
\end{clojure}

\fi

\noindent
Теперь данные сравнивают не в лоб, а с помощью функции:

\begin{clojure}
(is (= {:sites [{:name "Site1"}
                {:name "Site2"}]}
       (clean-sites body)))
\end{clojure}

Иногда проверяют не конкретные значения, а структуру ответа. Это удобно, когда в
ответе объёмные списки и словари. В таком случае пользуются спекой или
JSON-схемой. Преимущества спеки в том, что она лояльна к новым полям. Если в
ответ добавили поле, спека не выдаст ошибку.

\index{spec!в тестах}
\index{spec!valid?}
\index{spec!assert}

\ifnarrow

\begin{clojure}
(let [response (...) ;; get the response
      body (-> response
               :body
               (json/parse-string
                 true))]
  (is (s/valid? :api.search/result
                body)))
\end{clojure}

\else

\begin{clojure}
(let [response (...) ;; get the response
      body (-> response
               :body
               (json/parse-string true))]
  (is (s/valid? :api.search/result body)))
\end{clojure}

\fi

Функция \code{s/valid?} вернёт истину или ложь, что неудобно для тестов. Если
данные неверны, придётся вывести их на экран для расследования. Замените
\code{s/valid?} на макрос \code{s/assert}, который бросит исключение. Так
вы сразу увидите данные \code{explain} в отчёте.

\index{веб-разработка}

Кроме валидации, спека полезна для генерации тестовых данных. Эту возможность мы
рассмотрим ближе к концу главы.

\section{Тестирование систем}

\index{системы!тестирование}

Коротко о том, как пишут тесты в проектах с системами, о которых мы говорили в
прошлой главе \page{chapter-systems}. Напомним, система~--- это набор компонентов со
связями между ними. Покрыть тестами каждый компонент нетрудно; проблемы
возникают при их взаимодействии. В проекте обязательно должен быть тест, где
система работает как единое целое.

\subsection{Фикстура}

\index{фикстуры!с системой}

Во время тестов кто-то должен запустить систему и остановить её. На эту роль
подходит фикстура. Предположим, система и функции \code{start!} и \code{stop!}
находятся в модуле \code{system.clj}. Напишем фикстуру \code{fix-system}:

\pagebreakafive

\begin{clojure}
(defn fix-system
  [t]
  (system/start!)
  (t)
  (system/stop!))
\end{clojure}

Внутри теста в переменной \code{system/system} будет рабочая система. Другие
фикстуры, например для работы с базой, могут обратиться к компонентам
напрямую. Важно, чтобы в \code{use-fixtures} они шли в~правильном порядке
(левее~--- раньше), иначе получим \code{NPE} и другие странности. Фикстура ниже
готовит данные в базе для каждого теста:

\pagebreaklarge

\index{NPE}

\ifnarrow

\begin{clojure}
(defn fix-db-data
  [t]
  (let [{:keys [db]} system/system]
    (prepare-test-data db)
    (t)
    (clear-test-data db)))

(use-fixtures :once
  fix-system fix-db-data)
\end{clojure}

\else

\begin{clojure}
(defn fix-db-data
  [t]
  (let [{:keys [db]} system/system]
    (prepare-test-data db)
    (t)
    (clear-test-data db)))

(use-fixtures :once fix-system fix-db-data)
\end{clojure}

\fi

Фикстура \code{fix-db-data} нарушает правило, согласно которому к~системе нельзя
обращаться напрямую и вынимать из неё компоненты. В этом плане для тестов
действуют послабления. Тесты~--- не боевой код, поэтому на небольшие нарушения
закрывают глаза.

\subsection{Обращение к системе}

Когда система работает, к ней обращаются как к полноценному серверу, а не к~функции.
Чтобы проверить API, мы посылаем настоящий HTTP-запрос и читаем
ответ. Для этого нужна клиентская библиотека. Если сервер проверяет права
доступа, мы должны построить заголовок авторизации и добавить в запрос.

Напишем тест для условного API, которое вернёт заказы пользователя. Чтобы не
обрушить на вас лавину кода, разделим тест на~логические блоки. Сначала добавим
в базу пользователя с открытым и закрытым ключами. Результат записи в~базу
неважен, поэтому затеним его подчёркиванием. Для краткости опустим вставку
других данных: профиля, заказов и так далее.

\begin{clojure/lines*}{firstnumber=1}
(deftest test-api-orders-ok
  (let [public-key "my_public_key"
        secret-key "slk6Da7sD2G4g"
        {:keys [db]} system/system
        _ (jdbc/insert! db :users
              {:public_key public-key
               :secret_key secret-key})
\end{clojure/lines*}

Предполагается, что внутри теста система уже работает за счёт фикстуры
\code{fix-system}. Ключ системы \code{db} ссылается на открытое подключение к
базе. Далее составим параметры запроса HTTP. Закрытый ключ не участвует в
параметрах, но с его помощью получим их отпечаток (хэш) по алгоритму
HMAC~SHA256. Если вы забыли, как работает подпись ключом, вернитесь в начало
главы к похожему примеру \page{hmac-sha256}. Из отпечатка строим заголовок
авторизации:

\ifnarrow

\begin{clojure/lines*}{firstnumber=8}
    params {:command :listOrders
            :public_key public-key
            :ordering "date_created"
            :sort "desc"
            :page 2}
    signature (params->sha256hmac
                params secret-key)
    auth-header (str "HMAC_SHA256="
                  signature)
\end{clojure/lines*}

\else

\begin{clojure/lines*}{firstnumber=7}
        params {:command :listOrders
                :public_key public-key
                :ordering "date_created"
                :sort "desc"
                :page 2}
        signature (params->sha256hmac params secret-key)
        auth-header (str "HMAC_SHA256=" signature)
\end{clojure/lines*}

\fi

В третьем блоке мы передаём адрес, параметры и~заголовки в~HTTP-клиент. В~этот
момент происходит настоящий сетевой запрос. Сервер вычисляет сигнатуру и
сравнивает с той, что прислал клиент. Если они равны, получим статус 200 и JSON
с заказами в~теле ответа.

\ifafive\vspace{15mm}\pagebreak[4]\fi

\ifnarrow

\begin{clojure/lines*}{firstnumber=17}
    response
    (client/get
      "http://127.0.0.1:8080/api"
      {:query-params params
       :headers {:authentication
                 auth-header}})
    {:keys [status body]} response]
(is (= 200 status))
(is (= {:orders [...]} body))))
\end{clojure/lines*}

\else

\begin{clojure/lines*}{firstnumber=14}
        response
        (client/get "http://127.0.0.1:8080/api"
            {:query-params params
             :headers {:authentication auth-header}})
        {:keys [status body]} response]
    (is (= 200 status))
    (is (= {:orders [...]} body))))
\end{clojure/lines*}

\fi

Даже в сокращении тест занимает много места. Чтобы его улучшить, выносите как
можно большей действий в фикстуры и~вспомогательные функции. Например, создание
пользователя и~заказов совершенно точно должно быть в фикстуре, иначе этот код
разбредётся по всем тестам. Подготовку запроса (подпись, заголовок) поместите
в~функцию, которая выполнит эти шаги самостоятельно.

\subsection{Состояние}

Фикстура \code{fix-system} неслучайно стоит под ключом \code{:once}. Запуск и
остановка системы занимают много времени. В наших интересах прогнать как можно
больше тестов, пока система работает. Если делать это поштучно, процесс
затянется надолго.

Кажется, что две-три секунды это немного. Но представьте, что работаете над
задачей и запускаете тест раз за разом,~--- подобные паузы
раздражают. Рассмотрим, как избавиться от ожидания.

\index{системы!состояние}
\index{метаданные}

Потребуется два шага. Первый~--- улучшить систему, чтобы она знала о своём
состоянии: включена она сейчас или выключена. Проще всего это сделать полем в
метаданных. Вынесем имя поля в отдельную переменную. Перепишем \code{start!},
чтобы в метаданных системы появился флаг со значением \code{true}.

\ifnarrow

\begin{clojure}
(def state-field ::started?)

(defn start! []
  (let [sys
        (-> system
            component/start-system
            (with-meta
              {state-field true}))]
    (alter-var-root
      #'system (constantly sys))))

(defn started? []
  (some-> system meta (get state-field)))
\end{clojure}

\else

\begin{clojure}
(def state-field ::started?)

(defn start! []
  (let [sys (-> system
                component/start-system
                (with-meta {state-field true}))]
    (alter-var-root #'system (constantly sys))))

(defn started? []
  (some-> system meta (get state-field)))
\end{clojure}

\fi

Функция \code{started?} вернёт флаг из метаданных текущей системы. Аналогично
изменим \code{stop!}, чтобы флаг становился ложью.

Второй шаг~--- перед тем, как включить систему в фикстуре, проверим, была ли она
уже запущена. Если нет, фикстура работает как обычно: запуск, тест,
остановка. Если система уже работает, значит, кто-то сделал это вручную. В этом
случае фикстура только выполнит тест, что гораздо быстрее.

\ifnarrow

\begin{clojure}
(defn fixture-system [t]
  (let [started-manually?
        (system/started?)]
    (when-not started-manually?
      (start!))
    (t)
    (when-not started-manually?
      (stop!))))
\end{clojure}

\else

\begin{clojure}
(defn fixture-system [t]
  (let [started-manually? (system/started?)]
    (when-not started-manually?
      (start!))
    (t)
    (when-not started-manually?
      (stop!))))
\end{clojure}

\fi

Выполните в REPL \code{(system/start!)}. Теперь вызывайте тест сколько угодно
раз~--- система включена постоянно, и не придётся ждать её запуска. Если
использовать эту фикстуру в другом модуле, она поведёт себя так же, потому что
состояние системы глобально.

Получилась session-фикстура, о которой мы упоминали в начале
главы \page{fix-session}. Такие фикстуры активны в течение всего прогона тестов,
из чего порой можно извлечь пользу. Однако официально они не поддерживаются
фреймворком Clojure, поэтому контроль за ними ложится на вас.

\section{Интеграционные тесты}

\index{тесты!интеграционные}
\index{пирамида тестов}

На протяжении главы мы постепенно усложняли тесты. С каждым шагом они всё меньше
зависят от технических деталей и делают упор на бизнес-логику. Принцип называют
\footurl{пирамидой тестов}{https://martinfowler.com/bliki/TestPyramid.html}[Test Pyramid].
В её основании юнит-тесты~--- множество отдельных проверок. Поднимаясь к
вершине, мы абстрагируемся от технических деталей. В какой-то момент тестируют
уже не функции, а всё приложение.

\index{библиотеки!Selenium}
\index{интерфейс}

Каждый уровень требует специальных знаний. Читатель готов к~тому, чтобы
подняться на последний этаж~--- освоить интеграционное тестирование. По-другому
его называют UI- или Selenium-тестами в честь одноимённого фреймворка. В этих
тестах запросы шлют не программно, а имитируют действия человека. Для этого
управляют браузером или телефоном: вводят данные в форму, нажимают кнопку и
проверяют, что появились нужные элементы.

Интеграционные тесты работают медленно, потому что включают полный цикл
приложения. Это загрузка страницы, выполнение скриптов, реакция браузера. Если
возникнет ошибка, её трудно расследовать из-за длины цепи. Представьте, что вы
нажали на кнопку, но ничего не произошло. Возможны десятки причин, почему кнопка
не работает, причём как на сервере, так и на клиенте.

Рассмотрим, как писать UI-тесты на Clojure. На этапе подготовки запускают
систему и наполняют базу тестовыми данными. Далее тест берёт контроль над
браузером и командует им. Например, открывает страницу \code{http://127.0.0.1:8080}
и щёлкает по ссылкам. В любой момент мы получим адрес страницы, её заголовок
и HTML-код. В тест добавляют формы \code{(is (= ...))}, чтобы проверить,
на какой странице мы оказались или что видит пользователь.

UI-тест не всегда обращается именно к локальному серверу. Некоторые тесты пишут
для сервисов, которые развёрнуты в инфраструктуре фирмы. Это так называемые
стейджинги \eng{staging}~--- сервера, которые работают как в промышленном
запуске, но доступны только разработчикам. При их развёртывании в базу добавляют
специальную учётную запись, от имени которой действует тест.

Чтобы управлять браузером, нужны драйвер и библиотека к нему. Под драйвером
понимают утилиту командной строки. Когда драйвер запущен, он принимает запросы
по протоколу HTTP. Одновременно драйвер запускает браузер в режиме марионетки, и
между ними образуется связь. Таким образом, драйвер~--- это посредник между
тестом и браузером. Он переводит HTTP-запросы в бинарный протокол браузера и
наоборот.

\index{утилиты!chromedriver}
\index{утилиты!geckodriver}
\index{утилиты!safaridriver}

Каждый браузер работает со своим драйвером. Для Chrome он называется
\code{chromedriver}, для Firefox~--- \code{geckodriver}. Одноимённые утилиты
ставятся из пакетных менеджеров \code{apt}, \code{yum} или
\code{brew}. Пользователи Windows скачают бинарные файлы с сайта
проектов. Драйвер к Safari называется \code{safaridriver}. С версии 13 он
идёт в комплекте с~Mac~OS.

\index{библиотеки!Etaoin}

Для работы с драйвером подойдёт библиотека
\footurl{Etaoin}{https://github.com/igrishaev/etaoin}[Etaoin].
Добавьте её в зависимости профиля \code{:dev} (только для разработки и тестов):

\begin{clojure}
:dev {:dependencies [[etaoin "0.3.6"]]}
\end{clojure}

Убедитесь, что драйвер находится по одному из путей, указанных в~\code{PATH},
например \code{/usr/\-local/\-bin}. Для этого выполните \code{chromedriver} или
\code{geckodriver} с ключом \code{--version} в терминале. Другой способ
проверить утилиту~--- вызвать \code{where} с её именем. Путь до драйвера можно
задать в опциях библиотеки, но проще положить его в \code{PATH}.

\index{переменные!PATH}

Напишем первый тест. Представим, что локальный сервер работает на порту
8080. Тест открывает форму входа, заполняет поля и~нажимает кнопку
Login. Браузер обновляет страницу, появляется приветствие. Становятся видны
элементы интерфейса, которые прежде были скрыты (ссылки My profile, Logout и
другие).

\ifnarrow

\begin{clojure}
(ns project.integration-tests
  (:require [etaoin.api :as e]))

(deftest test-ui-login-ok
  (e/with-chrome {} driver
    (e/go driver
      "http://127.0.0.1:8080/login")
    (e/wait-visible driver
      {:fn/has-text "Login"})
    (e/fill driver
      {:tag :input :name :email}
      "test@test.com")
    (e/fill driver
      {:tag :input :name :password}
      "password")
    (e/click driver
      {:tag :button :fn/text "Login"})
    (e/wait-visible driver
      {:fn/has-text "Welcome"})
    (is (e/visible? driver
          {:tag :a
           :fn/text "My profile"}))
    (is (e/visible? driver
          {:tag :button
           :fn/text "Logout"}))))
\end{clojure}

\else

\ifafive

\begin{clojure}
(ns project.integration-tests
  (:require [etaoin.api :as e]))

(deftest test-ui-login-ok
  (e/with-chrome {} driver
    (e/go driver "http://127.0.0.1:8080/login")
    (e/wait-visible driver {:fn/has-text "Login"})
\end{clojure}

\pagebreakafive

\begin{clojure}
    (e/fill driver
       {:tag :input :name :email} "test@test.com")
    (e/fill driver
       {:tag :input :name :password} "password")
    (e/click driver {:tag :button :fn/text "Login"})
    (e/wait-visible driver {:fn/has-text "Welcome"})
    (is (e/visible? driver
           {:tag :a :fn/text "My profile"}))
    (is (e/visible? driver
           {:tag :button :fn/text "Logout"}))))
\end{clojure}

\else

\begin{clojure}
(ns project.integration-tests
  (:require [etaoin.api :as e]))

(deftest test-ui-login-ok
  (e/with-chrome {} driver
    (e/go driver "http://127.0.0.1:8080/login")
    (e/wait-visible driver {:fn/has-text "Login"})
    (e/fill driver
       {:tag :input :name :email} "test@test.com")
    (e/fill driver
       {:tag :input :name :password} "password")
    (e/click driver {:tag :button :fn/text "Login"})
    (e/wait-visible driver {:fn/has-text "Welcome"})
    (is (e/visible? driver
           {:tag :a :fn/text "My profile"}))
    (is (e/visible? driver
           {:tag :button :fn/text "Logout"}))))
\end{clojure}

\fi

\fi

Разберём отдельные выражения. Форма \code{with-chrome}~--- это макрос, который
запускает Chrome на время исполнения кода. Макрос нужен, чтобы выключить драйвер
при выходе или в случае ошибки. Без него пришлось бы добавить
\code{try/finally}, что порождает вложенность и~в~целом неудобно:

\index{вложенность}
\index{браузеры}

\begin{clojure}
(let [driver (e/chrome)]
  (try
    (e/go driver "http://...")
    (e/click driver {:tag :button})
    (finally
      (e/quit driver))))
\end{clojure}

Выражение \code{(e/quit driver)} освобождает занятые ресурсы: закрывает окно
браузера и завершает процесс драйвера.

Функция \code{wait-visible} ждёт до тех пор, пока элемент не появится на
экране. Отрисовка страницы~--- это долгая операция. Из-за особенностей
веб-технологий она может быть медленной даже на мощном оборудовании. Если не
отделить команды ожиданием, между ними будет разница в несколько
миллисекунд. Браузер либо не успеет выполнить первое действие, либо отбросит
второе.

Ожидание в UI-тестах встречается часто. Основное время уходит на то, чтобы
получить отклик от системы. \code{Wait-visible}~--- это лишь одна из семейства
\code{wait}-функций. В них входят \code{wait\-/has\-/text} (дождаться текст на
экране), \code{wait-has-class} (ждать, пока у элемента не появится класс) и
другие.

\index{селекторы!CSS}
\index{селекторы!XPath}

Драйвер ищет элементы на странице с помощью селекторов. Это выражения на языках
\footurl{CSS}{https://www.w3schools.com/cssref/css\_selectors.asp}[CSS] и
\footurl{XPath}{https://www.w3schools.com/xml/xpath\_syntax.asp}[XPath]. Мы
не будем разбирать их синтаксис: это долго и заслуживает отдельной главы.

Для краткости рассмотрим альтернативу: на элемент можно сослаться по
словарю. Ключи \code{tag} и \code{id} означают имя тега и идентификатор. Другие
ключи означают атрибуты тега. В примере выше селектор
\code{{:tag :input :name :email}} станет строкой
\code{.//input[@name="email"]} на языке XPath.

\index{языки!XPath}

Ключ \code{index} ссылается на $i$-й элемент в случаях, когда селектор нашёл их
несколько. Например, \code{{:tag :button :index 1}} вырождается
в~\code{.//button[1]}. Индекс считают от нуля. Ключи с пространством \code{fn}
особые: они означают вызов функции XPath. Ниже ключ \code{:fn/has-class}
вызывает \code{contains} на имени класса. Получим все ссылки, у которых есть
класс active.

\begin{clojure}
{:tag :a :fn/has-class "active"}
;; .//a[contains(@class, "active")]
\end{clojure}

При помощи словаря можно сослаться на любой элемент страницы. Если путь к
элементу слишком сложен, добавьте ему класс или идентификатор. В особых случаях
элемент ищут в рамках другого элемента, чтобы сузить выборку. Эти и другие
случаи описаны в документации к библиотеке.

Наконец, если вы не доверяете браузеру, можно получить текущий HTML функцией
\code{e/get-source}. Это важное отличие от пункта меню <<показать код
страницы>>, где видно исходный HTML до начала работы скриптов. Далее вы парсите
разметку средствами Clojure или Java и выполняете свои проверки. Для парсинга
подойдут библиотеки
\footurl{Hickory}{https://github.com/davidsantiago/hickory}[Hickory] и
\footurl{JSoup}{https://jsoup.org}[JSoup].

\index{HTML}

Наш интеграционный тест можно улучшить по следующим пунктам.

\textbf{Конфигурация.} Порт 8080 <<захардкожен>> в теле теста. Мы уже знаем, что
подобные значения приходят из конфигурации. Исправьте тест так, чтобы и сервер,
и драйвер работали с одинаковым источником порта.

\index{фикстуры!with-chrome}

\textbf{Фикстура.} Вспомним, как работает \code{with\-/chrome}: он создаёт новый
драйвер, выполняет тело и выключает его. Это напоминает систему: если каждый
тест обёрнут в \code{with\-/chrome}, мы теряем время на включение и запуск
драйвера.

Сделаем так, чтобы драйвер работал на протяжении всего прогона. Объявим
динамическую переменную и~фикстуру, которая связывает драйвер на время
тестов. Подключим её с ключом \code{:once}:

\begin{clojure}
(defonce ^:dynamic *driver* nil)

(defn fix-chrome [t]
  (e/with-chrome {...} driver
    (binding [*driver* driver]
      (t))))

(use-fixtures :once fix-chrome)
\end{clojure}

\textbf{Второй браузер.} Тесты работают в Chro\-me, но руководство ставит
задачу~--- убедиться, что мы поддерживаем Firefox. Всё, что мы написали для
Chrome, нужно выполнить в другом браузере, при этом код нельзя копировать.

Поможет мультификстура, с которой мы знакомились на середине
главы \page{multi-fixture}. Она пробегает по списку типов браузеров, ключам
\code{:chrome} и~\code{:firefox}. Макрос \code{with-driver}~--- это общий случай
\code{with-chrome}. Отличие в том, что \code{with-driver} ожидает первым
аргументом тип браузера. На каждом шаге фикстура связывает драйвер
с~динамической переменной и выполняет тест.

\ifnarrow

\begin{clojure}
(defn fix-multi-driver [t]
  (doseq [driver-type [:chrome :firefox]]
    (e/with-driver driver-type {} driver
      (binding [*driver* driver]
        (testing (format "Browser %s"
                   (name driver-type))
          (t))))))
\end{clojure}

\else

\begin{clojure}
(defn fix-multi-driver [t]
  (doseq [driver-type [:chrome :firefox]]
    (e/with-driver driver-type {} driver
      (binding [*driver* driver]
        (testing (format "Browser: %s" driver-type)
          (t))))))
\end{clojure}

\fi

Тесты сработают в обоих браузерах. Для ясности мы обернули тест сообщением о
том, в каком браузере его вызывают. Чтобы добавить новый браузер, например
Safari, добавьте его ключ в вектор \code{driver-type}.

\index{фикстуры!обход}

Заметим, что обход тестов и браузеров отличается от типа фикстуры. Если это
\code{:once}, все тесты сработают сначала в Chrome, а потом в~Firefox (прогон в
разрезе браузера). Если \code{:each}, каждый тест сначала сработает в Chrome, а
затем в Firefox (в разрезе теста).

На первый взгляд это ничего не меняет, но со временем видна польза каждого
подхода. Если наша цель~--- убедиться, что тесты проходят в~принципе, выполним
набор сначала в одном браузере, затем в другом. Если работаем над
совместимостью, нужна другая стратегия: брать тесты под одному и проверять во
всех браузерах. Задайте фикстуре нужный тип в зависимости от цели.

\textbf{Пакетные действия.} Ещё один способ улучшить тесты~--- вынести
одинаковые задачи в фикстуру или функцию. Предположим, каждый тест начинается с
авторизации и заканчивается выходом из системы. Чтобы не копировать код этих
действий, напишем фикстуру \code{fix-login-logout} и зарегистрируем с ключом
\code{:each}.

\begin{clojure}
(defn fix-login-logout [t]
  (doto *driver*
    (e/go "http://127.0.0.1:8080/login")
    (e/fill {:tag :input :name :email}
            "test@test.com")
    (e/fill {:tag :input :name :password}
            "********")
    (e/click {:tag :button
              :fn/text "Login"}))

  (t)

  (doto *driver*
    (e/click {:tag :button
              :fn/text "Logout"})
    (e/wait-has-text "Login")))
\end{clojure}

Выносите сложные действия в функции. Например, выбор даты в~виджете календаря
может занять до десяти команд. Напишите условную функцию \code{set-widget-date},
которая принимает драйвер, селектор поля и дату, которую нужно ввести.

\index{макросы!doto}

\textbf{Используйте doto.} Когда несколько форм принимают одинаковый первый
аргумент, их объединяют в макрос \code{doto}. Он подставит \code{*driver*} на
второе место в каждый список тела. С \code{doto} код становится короче и
чище. Каждая функция Etaoin принимает драйвер, поэтому их легко группировать в
\code{doto}.

\section{Другие решения}

Перечислим сторонние библиотеки для тестов. Мы не будем изучать их подробно:
ограничимся кратким описанием и примером. Подробности ищите в документации к
проектам.

\subsection{Продвинутые моки}

\index{библиотеки!Mockery}
\index{моки}

На минуту вернёмся к мокам~--- временной подмене функций через
\code{with-redefs}. Макрос слишком многословен, чтобы работать с ним
напрямую. Появились библиотеки, которые описывают мокинг короче и
выразительнее. Одна из них называется
\footurl{Mockery}{https://github.com/igrishaev/mockery}[Mockery].
Библиотека предлагает макрос \code{with-mock}:

\begin{clojure}
(with-mock mock
  {:target :project.path/get-geo-point
   :return {:lat 14.23 :lng 52.52}}
  (get-geo-point "cafe" "200m"))
\end{clojure}

Его первый аргумент~--- символ, с которым связано хранилище мока. Ключ
\code{:target} задаёт путь к объекту, который нужно заменить,
а~\code{:return}~--- результат. Выше мы <<замокали>> функцию
\code{get-geo-point}, которая, судя по названию, обращается к сервису карт.

Внутри макроса символ \code{mock} указывает на атом со словарём. Он наполняется
данными по~мере того, как вызывают цель: сколько раз к ней обратились и с какими
аргументами. Ниже мы добавили проверки, что функцию вызвали один раз с
параметрами cafe и 200m.

\ifnarrow

\begin{clojure}
(let [{:keys [called?
              call-count
              call-args]} @mock]
  (is called?)
  (is (= 1 call-count))
  (is (= '("cafe" "200m") call-args)))
\end{clojure}

\else

\begin{clojure}
(let [{:keys [called? call-count call-args]} @mock]
  (is called?)
  (is (= 1 call-count))
  (is (= '("cafe" "200m") call-args)))
\end{clojure}

\fi

\index{библиотеки!Spy}

Библиотека \footurl{Spy}{https://github.com/alexanderjamesking/spy}[Spy]
работает по-другому. Одноимённая функция порождает <<шпионскую>> версию
исходной. Шпион ведёт себя как оригинал, но накапливает аргументы и
результаты. Позже шпиона <<допрашивают>> на предмет того, какие данные он
собрал.

Небольшой пример с прослушкой функции суммирования:

\begin{clojure}
(require '[spy.core :as spy])

(def spy+ (spy/spy +))
(mapv spy+ [1 2 3] [4 5 6])

(spy/calls spy+)
;; [(1 4) (2 5) (3 6)]
(spy/responses spy+)
;; [5 7 9]
\end{clojure}

\index{обратные зависимости}
\index{dependency indirection}

\index{die-fn}
\index{функция смерти}

Spy полезен, когда функцию передают в параметрах. В широком смысле техника
называется dependency indirection, обратная зависимость. Не старший объект
решает, что вызывать, а наоборот~--- ему говорят, с чем работать.

Предположим, мы пишем тесты на чтение конфигурации с параметром
\code{:die-fn}. Если ошибок нет, функция смерти не вызывается. Когда
в~конфигурации ошибка, должен быть вызов с~исключением и~меткой. Чтобы написать
тест, в~\code{load-config} передают шпиона. Он не вызывает исключение, но
фиксирует факт вызова, что позже проверяют в~утверждении.

\pagebreakafive

\begin{clojure}
(require '[spy.assert :as assert])

(deftest test-config-error-die-fn-called
  (let [spy-die-fn (spy/spy)]
    (load-config {:file "/wrong/file.json"
                  :spec ::config
                  :die-fn spy-die-fn})
    (assert/called? spy-die-fn)))
\end{clojure}

Функция \code{spy} может и не принимать аргументов. В этом случае она вернёт
функцию произвольной арности. Модуль \code{assert} предлагает макросы для
проверок в тестах: вызвано хотя бы раз, точное число раз, именно с этими
аргументами и так далее. На нижнем уровне они сводятся к~\code{is} с~понятным
сообщением.

\subsection{Альтернативный синтаксис}

\index{библиотеки!Midje}

Проект \footurl{Midje}{https://github.com/marick/Midje}[Midje] предлагает другой
синтаксис для тестов. В этой библиотеке работают с фактами. Факт означает набор
проверок, сгруппированных по смыслу. Запишем факты о функции \code{split}:

\ifnarrow

\begin{clojure}
(facts "about split"
 (str/split "a/b" #"/") => ["a" "b"]
 (str/split "" #"irrelvant") => [""])
\end{clojure}

\else

\begin{clojure}
(facts "about split"
 (str/split "a/b/c" #"/") => ["a" "b" "c"]
 (str/split "" #"irrelvant") => [""])
\end{clojure}

\fi

\index{продвинутое равенство}
\index{extended equality}

Стрелка между выражениями~--- это оператор, который называется extended
equality, продвинутое равенство. От обычного \code{=} он отличается тем, что
работает с разными типами. С его помощью величины сравнивают короче. Например,
форма \code{1 => even?} сводится к \code{(even? 1)}. \code{Midje} предлагает и
другие, более сложные стрелки для коллекций и~макросов.

\subsection{Вывод XUnit}

\index{библиотеки!Test2junit}

Плагин \footurl{Test2junit}{https://github.com/ruedigergad/test2junit}[Test to~JUnit]
пишет отчёт в файл формата XUnit. Системы интеграции вроде CircleCI или Jenkins
отображают его в понятном виде. Графический отчёт легче читать, чем вывод
консоли: ошибки выделены красным, стектрейсы спрятаны под выпадающие
элементы. Добавьте плагин в Lein и задайте путь, куда писать файлы.

\ifnarrow

\begin{clojure}
:plugins [[test2junit "1.1.2"]]
:test2junit-output-dir
  "target/test2junit"
\end{clojure}

\else

\begin{clojure}
:plugins [[test2junit "1.1.2"]]
:test2junit-output-dir "target/test2junit"
\end{clojure}

\fi

Чтобы использовать плагин, выполните \code{lein test2junit}. Вы не увидите
обычных сообщений в консоли, потому что теперь они направлены в файл. После
прогона тестов проверьте, что появился XML-отчёт.

Системы интеграции выделяют особую папку, в которой оседают логи и прочие
файлы~--- артефакты. С их помощью расследуют неудачные сборки. Сервер хранит
папку некоторое время, чтобы можно было исследовать её позже.

Как правило, путь к~артефактам указывает переменная среды \code{CI\_ARTE\-FACTS}
или с похожим именем. Чтобы сохранить отчёт о тестах, скопируйте его вручную
после прогона. Более удобный способ~--- сразу нацелить плагин на нужный путь в
настройках.

\begin{clojure}
:test2junit-output-dir
  (or (System/getenv "CI_ARTEFACTS")
      "target/test2junit")
\end{clojure}

\noindent
Убедитесь, что плагин подхватывает переменную:

\ifnarrow

\begin{bash}
$ CI_ARTEFACTS=/some/custom/path \
    lein test2junit
\end{bash}

\else

\begin{bash}
$ CI_ARTEFACTS=/some/custom/path lein test2junit
\end{bash}

\fi

\subsection{Генерация данных}

\index{библиотеки!Test.check}
\index{генерация данных}
\index{spec!gen}

Иногда тестам нужен большой объём данных: сто, двести тысяч записей или
миллион. При этом данные должны быть разнообразны~--- не подойдёт один и тот же
набор, загруженный тысячу раз. Поможет библиотека
\footurl{Test.check}{https://github.com/clojure/test.check}[Test check].
Её модуль \code{gen} производит случайные данные по заданным правилам. Особенно
полезна генерация записей. Объявим пользователя с тремя полями:

\ifnarrow

\begin{clojure}
(defrecord User
  [user-name user-id active?])
\end{clojure}

\else

\begin{clojure}
(defrecord User [user-name user-id active?])
\end{clojure}

\fi

Чтобы получить случайную запись, нужно произвести три случайных величины и
передать в конструктор \code{->User}. Модуль предлагает всевозможные генераторы
и их комбинации. Нас устроит кортеж из непустой строки, натурального числа и
булева:

\pagebreaklarge

\ifnarrow

\begin{clojure}
(require
 '[clojure.test.check.generators
   :as gen])

(def gen-fields
  (gen/tuple
    (gen/not-empty
      gen/string-alphanumeric)
    gen/nat
    gen/boolean))
\end{clojure}

\else

\begin{clojure}
(require '[clojure.test.check.generators :as gen])

(def gen-fields
  (gen/tuple (gen/not-empty gen/string-alphanumeric)
             gen/nat
             gen/boolean))
\end{clojure}

\fi

Когда генератор готов, из него получают данные:

\begin{clojure}
(gen/generate gen-fields)
["rw2AJ124fm9w91La3M58Bqt5" 14 true]
\end{clojure}

\noindent
Каждый вызов порождает новый вектор. Чтобы получить запись, применим вектор к её
конструктору:

\begin{clojure}
(apply ->User (gen/generate gen-fields))
#user.User{:user-name "dfgJKSHF3"
           :user-id 7
           :active? true}
\end{clojure}

Spec, которой мы посвятили главу \page{chapter-spec}, идёт ещё дальше. Она
предлагает генераторы на базе Test.check, где шаблоны задают
спекой. Раскрывается ещё одно свойство спек: кроме проверки, они подходят для
тестовых данных. Предположим, мы задали пользователя с~тремя полями:

\ifnarrow

\begin{clojure}
(s/def :user/id int?)
(s/def :user/name string?)
(s/def :user/active? boolean?)

(s/def ::user
  (s/keys :req-un [:user/id
                   :user/name
                   :user/active?]))
\end{clojure}

\else

\begin{clojure}
(s/def :user/id int?)
(s/def :user/name string?)
(s/def :user/active? boolean?)

(s/def ::user (s/keys :req-un [:user/id
                               :user/name
                               :user/active?]))
\end{clojure}

\fi

\noindent
Функция \code{s/gen} строит по спеке генератор. Последний передают в функцию
\code{generate}. Вот как получить случайного пользователя по спеке:

\iflarge

\begin{clojure}
(gen/generate (s/gen ::user))
\end{clojure}

\pagebreak

\begin{clojure}
{:id 88546920
 :name "Z4MO7GH80k3mRD"
 :active? true}
\end{clojure}

\else

\begin{clojure}
(gen/generate (s/gen ::user))

{:id 88546920
 :name "Z4MO7GH80k3mRD"
 :active? true}
\end{clojure}

\fi

Если нужно получить много записей, сохраните генератор в переменную, потому что
его подготовка (вызов \code{s/gen}) занимает время.

Вместо случайных величин можно задать варианты, например список имён, фамилий, и
городов. Сейчас имя пользователя~--- машинная строка, что некрасиво. Поменяем
спеку \code{:user\-/name} на множество имён.  В новой генерации будут только
те имена, что мы указали. Выбор имени из множества происходит случайно.

\begin{clojure}
(s/def :user/name
  #{"Ivan" "Juan" "Huan" "Ioann"})

{:id 274 :name "Juan" :active? true}
{:id 557 :name "Huan" :active? false}
{:id 557 :name "Ivan" :active? true}
\end{clojure}

Когда множество большое, его выносят в ресурс EDN и читают при загрузке модуля.

Возможности Spec обширны. С её помощью порождают связанные данные, например
пользователей, которые ссылаются на профили, и~наоборот. Спеки могут быть любой
вложенности, что открывает поле для экспериментов. В особых случаях спеке
сообщают свой алгоритм генерации. К нему прибегают, если спека очень сложна и
стандартный алгоритм не может подобрать данные, которые ей подходят.

\section{Заключение}

Тест~--- это код, который проверяет другой код. Тест защищает проект от
случайных изменений. Без тестов появляется эффект бабочки: правка в одном месте
ломает другое.

\index{покрытие}

Различают несколько видов тестов. В основном работают с юнит-тестами, которые
ещё называют модульными. Они проверяют функции из одноимённого пространства. С
юнит-тестами связан термин <<покрытие>>. Это доля кода, который сработал во
время тестов. При анализе покрытия смотрят не только величину в
процентах. Важно, чтобы все ветки алгоритма приняли участие.

Чтобы подготовить тест к запуску, применяют фикстуры. Это функции, которые
вызывают тест до или после каких-то действий. Различают одно- и многоразовые
фикстуры, \code{:once} и \code{:each}. Фикстуры разнообразны: это может быть
запись в базу, локальный сервер, система компонентов. Иногда фикстура вызывает
тест несколько раз в цикле.

Чтобы выполнить часть тестов, нужны теги и селекторы. Тег~--- это поле
метаданных теста. Селектор~--- функция, которая принимает метаданные и
возвращает истину или ложь. Тесты группируют в~наборы, потому что не всегда
можно выполнить их целиком в текущем окружении. Поскольку кейворд ведёт себя как
функция, селектор и тег чаще всего совпадают.

Если код обращается в сеть, помогут моки и стабы. Мок~--- это подмена кода в
момент исполнения. Например, функцию \code{get-events} заменяют на
\code{(constantly {...})} с известными данными. Стаб~--- это полноценный сервер
на локальном порту. В этом случае функцию \code{get-events} нацеливают на
локальный хост с помощью конфигурации. Сервер отдаёт данные, которые скопировали
из настоящего источника. Чтобы не засорять код большими словарями, их выносят в
ресурсы.

Ресурсы~--- это файлы в одноимённой папке проекта. У них особая роль: при сборке
ресурсы попадают в архив jar. Проект настраивают так, что в режиме тестов видны
дополнительные пути для их поиска. Убедитесь, что при сборке \code{uberjar} в
него не попали посторонние данные.

Негативные сценарии важны в той же степени, что и позитивные. Проверяйте
неверные параметры и права доступа. Чтобы не повторяться, выносите повторы в
списки и пробегайте по ним в \code{doseq}. Если вы ожидали ошибку, но её не
было, это тоже ошибка. Для таких ситуаций служит макрос
\code{(is (thrown?...))}.

Интеграционные тесты проверяют программу целиком. Они имитируют действия
человека, поэтому занимают больше времени. Тест управляет браузером или
телефоном. Типичный сценарий теста~--- нажать на элемент и проверить, что
появился или исчез другой элемент. Интеграционные тесты д\'{о}роги в поддержке,
поэтому их пишут в~последнюю очередь.

Если логика опирается на базу данных, в неё загружают необходимые записи. Обычно
записи хранят в виде коллекций или в файле CSV. Понадобится загрузчик, который
вносит данные в базу и позже очищает их. Если требуется большой объём данных, их
генерируют спекой.

Clojure предлагает различные библиотеки и утилиты для тестов. Из коробки
доступен Clojure.test, базовый фреймворк. Утилита Lein содержит команду для
прогона тестов. Сторонники Deps.edn пользуются Test-runner. Другие решения
меняют отчётность, синтаксис тестов, упрощают подмену функций.

Не злоупотребляйте библиотеками. Перед тем как браться за них, убедитесь, что
выжали всё из стандартного фреймворка.
