
\chapter{Изменяемость}

\index{изменяемость}

\begin{teaser}

В этой главе речь пойдёт об изменяемых типах. В этом плане Clojure занимает
особую позицию. В классических языках данные меняются, а стандартная библиотека
предлагает ограничения: локи, атомарные действия, постоянные коллекции. В
Clojure, наоборот, данные не меняются, а мутабельные типы задвинуты на второй
план. Это сделано специально, потому что неизменяемость~--- центральная идея
языка.
\end{teaser}

Руководства по Clojure учат нас постоянным коллекциям. Это правильный подход:
чем труднее изменить данные, тем меньше шансов сделать это по ошибке. Но
полностью избежать изменений невозможно, и вы должны знать, как управлять ими.
Поэтому займём другую сторону: рассмотрим, как управлять состоянием в программах
на Clojure.

\section{Общие проблемы}

Код на Clojure с трудом ложится на императивный стиль, который делает акцент на
изменение данных. Скажем, чтобы получить список удвоенных чисел в классическом
языке, мы должны:

\index{итерация}

\begin{itemize}

\item
  создать пустой список~--- будущий результат;

\item
  пройти по элементам исходного списка;

\item
  на каждом шаге вычислить новый элемент;

\item
  добавить его к результату.

\end{itemize}

\pagebreaklarge

Выразим алгоритм в коде на Python:

\begin{english}
  \begin{python}
numbers = [1, 2, 3]
doubles = []

for x in numbers:
    y = x * x
    doubles.append(y)

doubles # [1, 4, 9]
  \end{python}
\end{english}

Базовые типы Clojure не меняются, и к ним нельзя применить тот же подход. Те,
кто пришёл из императивных языков, поначалу не могут писать код с постоянными
коллекциями. Привычка менять данные настолько укрепилась в них, что
иммутабельность кажется физическим ограничением.

Автор Clojure полагает, что изменяемость~--- основная проблема в разработке
ПО. Когда мы пишем код, то видим его начальное состояние, в котором он будет
первый такт машинного времени. Затем программа инициирует классы, заполнит поля,
и объекты изменятся.

Многие ошибки трудно расследовать, потому что код и состояние расходятся. Чтобы
исправить ошибку, её повторяют в локальном окружении. Однако привести код в
конкретное состояние не так просто. Неизменяемые данные отсекают целый пласт
ошибок, от которых страдают императивные языки.

\index{языки!Python}

Рассмотрим примеры на Python. В модуле заданы параметры запроса по
умолчанию. Функция \verb|api_call| принимает дополнительные параметры,
объединяет со стандартными и передаёт в HTTP-клиент:

\ifnarrow

\begin{english}
  \begin{python/lines}
DEFAULT_PARAMS = {
    "allow_redirects": True,
    "timeout": 5,
    "headers": {"Content-Type":
                "application/json"},
    "auth": ("username", "password"),
}

def api_call(**params):
    api_params = DEFAULT_PARAMS
    api_params.update(params)
    url = "https://api.host.com"
    response = \
      requests.post(url, **api_params)
    return response.json()
  \end{python/lines}
\end{english}

\else

\begin{english}
  \begin{python/lines}
DEFAULT_PARAMS = {
    "allow_redirects": True,
    "timeout": 5,
    "headers": {"Content-Type": "application/json"},
    "auth": ("username", "password"),
}
  \end{python/lines}
\end{english}

\iflarge\pagebreak[4]\fi
\ifafive\pagebreak[4]\fi

\begin{english}
  \begin{python/lines*}{firstnumber=7}
def api_call(**params):
    api_params = DEFAULT_PARAMS
    api_params.update(params)
    resp = requests.post(
        "https://api.host.com", **api_params
    )
    return resp.json()
  \end{python/lines*}
\end{english}

\fi

\index{передача по ссылке}

В теле \verb|api_call| грубая ошибка: переменная \verb|api_params| получает
не копию глобальных параметров, а ссылку на них \ifnarrow\coderef{10}\else\coderef{9}\fi.
Изменяя \verb|api_params|, мы на самом деле меняем \verb|DEFAULT_PARAMS|
\ifnarrow\coderef{11}\else\coderef{10}\fi. На каждый вызов
глобальные параметры меняются, что ведёт к странному поведению программы.
Наше представление о коде не совпадает с тем, как он работает.

Другой пример: на собеседованиях часто показывают функцию с сигнатурой
ниже. Объясните, что в ней не так, и приведите пример ошибки.

\begin{english}
  \begin{python}
def foo(bar=[]):
  \end{python}
\end{english}

Ответ: параметры функции по умолчанию создаются однажды. В~данном случае
\verb|bar| равен пустому списку. В Python список изменяется. Если в
\verb|bar| ничего не передали, получим исходный список. Добавим в~него
элемент, и в следующий раз \verb|bar| будет уже не пустой:

\begin{english}
  \begin{python}
def foo(bar=[]):
    bar.append(1)
    return bar
  \end{python}
\end{english}

Вызов \verb|foo| вернёт списки \verb|[1]|, \verb|[1, 1]| и так
далее. Ещё хуже: если результат \verb|foo| сохранить в переменную и позже
добавить к нему элемент, на самом деле изменится злосчастный \verb|bar|.

Современные IDE проверяют код на неявные ошибки. Про список в~сигнатуре знают
все анализаторы и линтеры. Но мы не можем целиком положиться на утилиты: если
данные меняются постоянно, трудно понять, где ошибка, а где умысел.

Начинающих кложуристов выдаёт состояние там, где оно не требуется:

\begin{english}
  \begin{clojure}
(let [result (atom [])
      data [1 2 3 4 5]]
  (doseq [item data]
    (let [new-item (* 2 item)]
      (swap! result conj new-item)))
  @result)
  \end{clojure}
\end{english}

\index{императивный стиль}

Это привычка из императивного прошлого. Атом-аккумулятор лишний, достаточно
\verb|map| или \verb|for|:

\ifnarrow

\begin{english}
  \begin{clojure}
(map (partial * 2)
     [1 2 3 4 5])
  \end{clojure}

\splitter

  \begin{clojure}
(for [n [1 2 3 4 5]]
  (* n 2))
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
(map (partial * 2)
     [1 2 3 4 5])
  \end{clojure}

&

  \begin{clojure}
(for [n [1 2 3 4 5]]
  (* n 2))
  \end{clojure}

\end{tabular}

\end{english}

\fi

Оба выражения короче и понятней. Не нужно создавать вектор и добавлять в него
элементы~--- это делают функции. Если обход коллекции завязан на
атоме, скорее всего это слабое решение.

Авторы Clojure сделали всё, чтобы выделить состояние на общем фоне. Прибегайте к
нему только в крайних случаях. Если вы написали код с состоянием без
уважительной причины, вам сделают замечание или не примут работу.

\index{состояние}

\subsection{В защиту состояния}

Мы говорили, что состояние несёт потенциальные ошибки. Это слишком линейное
заявление: без состояния работают только небольшие программы. Например, скрипты,
которые запускают раз в день. Писать промышленный код без состояния невозможно.

\index{ресурсы}

Постоянные данные избавляют нас от ошибок с перезаписью полей. Это весомый
выигрыш, но кроме данных приложение полагается на ресурсы. Для них действует
правило: дешевле работать с открытым ресурсом, чем постоянно открывать и
закрывать его. Состояние повышает скорость программы.

\index{веб-разработка}
\index{протоколы!CGI}

Много лет назад веб-серверы работали по протоколу CGI,
\footurl{Common Gateway Interface}{https://en.wikipedia.org/wiki/Common\_Gateway\_Interface}[CGI].
На каждый запрос сервер запускал скрипт или бинарный файл. Скрипт получал данные
запроса из переменных среды. Программа писала ответ в стандартный поток. Сервер
перехватывал его и выводил пользователю.

Схема была простой и удобной. Приложение могло быть скриптом на Perl или
программой на C\Plus\Plus. У сервера не было состояния. В любой момент
разработчик обновлял файл, и изменения вступали в силу немедленно.

За преимущества платили низкой скоростью. Каждый запрос к~серверу порождал новый
процесс. Даже если программа написана на Си, запуск процесса занимает
время. Индустрия пришла к тому, что приложение должно работать постоянно, а не
по запросу.

\index{протоколы!FastCGI}

Приложение на FastCGI устроено как самостоятельный сервер. Его
производительность на два порядка выше, чем у CGI. В нём появилось состояние~---
открытый порт и цикл ввода-вывода. Цикл читает запрос и~делегирует отдельному
потоку. Это усложнило разработку, но вместе с тем открыло новые парадигмы.

Похоже устроены соединения с базой данных. Представим, что на каждый запрос мы
открываем соединение, работаем с ним и закрываем. В машинном мире открыть
TCP-соединение~--- долгая операция. Так появились пулы соединений.

\index{пул соединений}

Пул~--- это объект, который держит несколько открытых соединений. Пул знает,
какое из них занято или свободно. Чтобы работать с~базой, мы занимаем одно из
свободных соединений, используем его и возвращаем. Для потребителя пул~---
примитивный объект, который выдаёт и забирает соединения.

Но логика пула довольно сложна. Если соединений не хватает, он увеличивает свою
ёмкость, а при избытке сокращает. Для каждого соединения пул считает время
работы, простоя и прочие метрики. Он же решает, когда закрыть соединение и
заменить его новым. Пул работает в~отдельном потоке, чтобы не блокировать
основную программу.

Столь сложное устройство компенсирует скорость доступа. Каждый запрос протекает
по заранее открытому соединению, что намного быстрее, чем открывать его каждый
раз.

Сама архитектура машин поощряет изменять данные. В школе нам объясняют память
компьютера как массив ячеек. Запись в ячейку по~адресу дёшева. И в C\Plus\Plus,
и в Python одинаково легко обновить элемент массива:

\begin{english}
  \begin{python}
items[i] = 5;
  \end{python}
\end{english}

Постоянные структуры хуже ложатся на эту модель памяти. Поэтому они сложнее:
неизменяемый список~--- уже не цепочка, а дерево узлов с указателем. Постоянные
коллекции умны и копируют данные не полностью, а частично. Всё же на больших
объёмах выгоднее работать с~изменяемыми структурами.

Мы не призываем всюду внедрять состояние. Древовидность и замедление~--- та
цена, которую платят за меньший риск ошибки. Инженер должен знать, на что идёт,
когда добавляет состояние или избавляется от него.

Далее мы изучим императивные возможности Clojure~--- как ими пользоваться и
когда это действительно нужно.

\section{Атомы}

\index{атом}

Clojure предлагает несколько способов менять данные. Самый простой из них~---
атом. Это объект, который прячет в себе другой объект. Атом получают одноимённой
функцией с начальным значением:

\begin{english}
  \begin{clojure}
(def store (atom 3))
  \end{clojure}
\end{english}

Если напечатать атом, увидим его номер и содержимое:

\begin{english}
  \begin{clojure}
#<Atom@10ed2e87: 3>
  \end{clojure}
\end{english}

Чтобы извлечь значение, применяют оператор \verb|@|. Это один из немногих
символов, который раскрывается ещё на этапе чтения кода компилятором. Запись
\verb|@store|~--- это укороченный вариант \verb|(deref store)|. Функция
\verb|deref| принимает атом и возвращает содержимое\footnote{Если точнее,
  \texttt{deref} вызывает одноимённый метод у переданного объекта, а что именно
  происходит в методе, зависит от типа объекта. Оператор \texttt{@} поддерживает
  не только атом, но и футуры, агенты и другие сущности. Более того: любой
  объект можно научить технике \texttt{deref}.}. Семантически это то же самое,
что получить значение по указателю. В русской литературе операцию называют
<<разыменование>>. В разговорном языке говорят <<дереф>> или <<дерефнуть>>.

\index{дереф}
\index{разыменование}
\index{синтаксис!@ (дереф)}
\index{clojure.core!deref}

\begin{english}
  \begin{clojure}
@store ;; 3
  \end{clojure}
\end{english}

В отличие от коллекций, атом меняет содержимое и остаётся тем самым
объектом. Это важно: если добавить к словарю ключ, получим новый словарь, при
этом старый не изменится. Если изменить содержимое атома, это будет всё тот
же атом с номером \verb|10ed2e87|.

\index{clojure.core!reset"!}

Наивный способ изменить атом~--- передать его в \verb|reset!|. Функция принимает атом
и новое значение. Оно может быть любого типа, в том числе \verb|nil|,
коллекцией, исключением:

\ifnarrow

\begin{english}
  \begin{clojure}
(reset! store nil)
(reset! store {:items [1 2 3]})
(reset! store (ex-info "error"
                {:id 3}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(reset! store nil)
(reset! store {:items [1 2 3]})
(reset! store (ex-info "error" {:id 3}))
  \end{clojure}
\end{english}
\fi

Если выполнить \verb|@store| после каждого выражения, получим то, что передали в
\verb|reset!|. Обратите внимание на последний случай: разыменование только
вернёт исключение, но не бросит его, потому что нет оператора \verb|throw|.

\subsection{Приращение атома}

\index{счётчики}
\index{атом!приращение}

Мы назвали \verb|reset!| наивным, потому что функция не учитывает текущего
значения атома. На практике атом изменяют, отталкиваясь от содержимого. Если это
счётчик, неважно, какое значение в нём сейчас. Атому посылают команду <<прибавь
единицу>>. Для вектора сообщение выглядит как <<добавь элемент>>, для
словаря~--- <<удали ключ>> и так далее.

Значение атома уходит на второй план; нас интересует действие. Чтобы обновить
атом с учётом состояния, ему посылают функцию. Функция принимает текущее
значение и возвращает новое, которое заменит содержимое. Подобное приращение
называется \verb|swap!|. В него передают атом и функцию для расчёта нового
значения:

\index{clojure.core!swap"!}

\begin{english}
  \begin{clojure}
(def counter (atom 0))
(swap! counter inc) ;; 1
  \end{clojure}
\end{english}

\noindent
Если повторять вызов \verb|swap!| с \verb|inc|, значение \verb|counter| каждый
раз будет увеличиваться на единицу, а с \verb|dec|~--- уменьшаться.

\verb|Swap!| принимает дополнительные параметры для расчёта. Предположим, мы
хотим увеличить счётчик сразу на три позиции или отмотать назад. Вместо
\verb|inc| возьмём сложение и вычитание, функции \verb|+| и \verb|-|. Их
первым аргументом станет текущее значение атома, а второй аргумент передают в
\verb|swap!|:

\begin{english}
  \begin{clojure}
(swap! counter + 3) ;; increase by 3
(swap! counter - 2) ;; decrease by 2
  \end{clojure}
\end{english}

Атом вычислит новое значение по правилу:

\begin{english}
  \begin{clojure}
(+ <current> 3)
(- <current> 2),
  \end{clojure}
\end{english}

\noindent
где \verb|<current>|~--- текущее значение.

Это был частный случай \verb|swap!| с одним аргументом. В общем случае функция
принимает их произвольное количество:

\begin{english}
  \begin{clojure}
(swap! <atom> func arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

\noindent
Новое значение будет найдено формой:

\begin{english}
  \begin{clojure}
(func <current> arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

\subsection{Атомы и словари}

До сих пор мы хранили в атомах счётчики, но на практике редко считают одну
сущность. Гораздо чаще счётчики ведут в разрезе чего-то. Например, просмотры
страниц по адресам, число сообщений у~пользователя и так далее.

Чтобы не создавать по атому на каждую сущность, их объединяют в
словарь. Рассмотрим подсчёт системных ресурсов. Ключи словаря означают тип
ресурса, значения~--- степень потребления в байтах или процентах.

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))
  \end{clojure}
\end{english}

Отдельная функция вычисляет потребление диска. Чтобы записать новое значение в
атом по ключу \verb|:store|, вызовем \verb|swap!| следующим образом:

\begin{english}
  \begin{clojure}
(defn get-disk-usage []
  (rand-int 99999999))

(let [store (get-disk-usage)]
  (swap! usage assoc :store store))
  \end{clojure}
\end{english}

Эта форма перепишет значение в поле \verb|:store| на новое. Возможен и~другой
подход, когда мы не считаем всё занятое место на диске, а~фиксируем разницу на
каждое изменение. Скажем, если пользователь создал или удалил файл, мы читаем
событие и обновляем \verb|:store| с~приращением.

Пусть функция \verb|get-file-event| каким-то образом вернёт событие файловой
системы. Это словарь с ключами \verb|:action| и \verb|:size|. В зависимости от
\verb|:action| мы наращиваем или уменьшаем потребление диска. Наша версия
\texttt{get-file-event}~--- заглушка, которая случайно вернёт одно из двух
событий: удаление или создание.

\begin{english}
  \begin{clojure}
(defn get-file-event []
  (rand-nth
   [{:action :delete
     :path "/path/to/deleted/file.txt"
     :size 563467}
    {:action :create
     :path "/path/to/new/photo.jpg"
     :size 7345626}]))
  \end{clojure}
\end{english}

Пересчёт потребления диска изменится: если тип события \verb|:delete|, уменьшим
поле \verb|:store| на размер \verb|size|, а для \verb|:create|~--- увеличим.

\ifnarrow

\begin{english}
  \begin{clojure}
(let [{:keys [action size]}
      (get-file-event)]
  (case action
    :delete
    (swap! usage update :store - size)
    :create
    (swap! usage update :store + size)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [{:keys [action size]} (get-file-event)]
  (case action
    :delete
    (swap! usage update :store - size)
    :create
    (swap! usage update :store + size)))
  \end{clojure}
\end{english}

\fi

\index{файлы}

Так считают ресурсы в облачных платформах. Обращение к диску~--- дорогая
операция: нельзя мгновенно обойти дерево папок и вычислить их объём. Иногда
файлы одного клиента лежат на разных дисках и~серверах. Поэтому ресурсы считают
итеративно и раз в интервал сверяют цифры.

\index{PID}
\index{процессы}

Усложним пример с ресурсами: теперь их считают в разрезе пользователей. Ключи
верхнего уровня означают номер пользователя, а~значения~--- словари ресурсов. К
уже знакомым ресурсам добавим ещё один с полем \verb|:pids|~--- множество
идентификаторов процессов \footurl{PID}{https://en.wikipedia.org/wiki/Process\_identifier}[PID]
\coderef{5}.

\ifnarrow

\begin{english}
  \begin{clojure/lines}
(def usage-all
  (atom {1005 {:cpu 35
               :store 63466734
               :memory 10442856
               :pids #{6266
                       5426
                       6542}}}))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(def usage-all
  (atom {1005 {:cpu 35
               :store 63466734
               :memory 10442856
               :pids #{6266, 5426, 6542}}}))
  \end{clojure/lines}
\end{english}
\fi

Чтобы добавить процесс 9999 пользователю 1005, выполним \verb|swap!|:

\ifnarrow

\begin{english}
  \begin{clojure}
(swap! usage-all
  update-in [1005 :pids] conj 9999)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] conj 9999)
  \end{clojure}
\end{english}

\fi

Это сложная комбинация: в \verb|swap!| передали функцию, которая принимает
функцию. Разберём по шагам, что произошло.

\begin{itemize}

\item
  Сперва получили множество старых процессов \verb|<pids>|:\\
  \verb|(get-in <current> [1005 :pids])|.

\item
  Добавили к нему новый процесс: \spverb|(conj <pids> 9999)|.\ifnarrow\else\\\fi
  Обозначим новое множество \verb|<pids*>|.

\item
  Обновили \verb|<current>| этим множеством по пути 1005 \arr{} \verb|:pids|:\\
  \ifnarrow
  \verb|(assoc-in <current>| \\
  \verb|  [1005 :pids] <pids*>)|
  \else
  \verb|(assoc-in <current> [1005 :pids] <pids*>)|.
  \fi

\end{itemize}

Чтобы удалить процесс, замените \verb|conj| на \verb|disj|. Это обратная
функция, которая удаляет элемент из множества.

\index{clojure.core!get-in}
\index{clojure.core!update-in}

\ifnarrow

\begin{english}
  \begin{clojure}
(swap! usage-all
  update-in [1005 :pids] disj 9999)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] disj 9999)
  \end{clojure}
\end{english}

\fi

Подытожим: функция \verb|reset!| нужна, чтобы сбросить атом в исходное
состояние. В других случаях важно знать текущее значение, чтобы вычислить
новое. Поэтому \verb|swap!| мощнее и гибче \verb|reset!|.

\subsection{Совместный доступ}

\index{чистые функции}
\index{атом!перезапуск}

Функция, которую передают в \verb|swap!|, должна быть без побочных эффектов. В
терминах функционального программирования её бы назвали чистой функцией. Она не
должна обращаться к базе данных, файлам, выводу на экран. Технически это
возможно, но вы столкнётесь со странным поведением атома. Дело в том, что иногда
функция срабатывает несколько раз за один \verb|swap!|. Причина кроется в
способе, которым атом обновляет содержимое.

Предположим, ресурсы считают в нескольких потоках: один слушает события файловой
системы, второй следит за памятью. Возникает проблема совместного
доступа. Возможна ситуация, когда два потока обновляют одни и те же
данные. Первый поток справился быстрее и~записал в атом свою версию
данных. Второй поток рассчитал другой вариант. Если он изменит атом, эффект
первого аннулируется.

\index{терминал}

Это классическая задача про терминал и семейную пару. Муж и~жена вносят наличные
на общий пустой счёт. Жена вносит 100 рублей, терминал прибавляет эту сумму к
нулю и записывает в базу. Муж вносит 50 рублей, терминал делает то же
самое. Итого на счёте 50 рублей, а 100 пропали.

Атом не допустит такого поведения. Он запоминает начальное значение в~момент
вычисления нового. Перед тем как обновить содержимое, атом проверяет, что
текущее значение совпадает с начальным. Если они не равны, атом обновили из
другого потока.

В этом случае атом повторяет цикл. Текущее становится начальным, и от него
вычисляют новое значение. Затем атом ещё раз сравнивает текущее и начальное
значения. Цикл повторяется до тех пор, пока они не будут равны. Это значит, что
за время вычислений атом не обновили. Атом меняет текущее значение на новое и
выходит из цикла.

Покажем сказанное на примере. Возьмем атом со словарём:

\begin{english}
  \begin{clojure}
(def sample (atom {:number 0}))
  \end{clojure}
\end{english}

Понадобится функция медленного сложения. Она принимает два числа и время
простоя. Для ясности добавим вывод в консоль.

\ifnarrow

\begin{english}
  \begin{clojure}
(defn +slow
  [a b timeout]
  (println
    (format "Current: %s, timeout: %s"
      a timeout))
  (Thread/sleep timeout)
  (+ a b))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn +slow
  [a b timeout]
  (println (format "Current: %s, timeout: %s" a timeout))
  (Thread/sleep timeout)
  (+ a b))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!future}
\index{футуры}

Обновим атом одновременно из двух потоков. Для этого вызовем \verb|swap!| в
футуре. В первой ждём две секунды, во второй~--- пять:

\ifnarrow

\begin{english}
  \begin{clojure}
(do (future (swap! sample update
              :number +slow 1 2000))
    (future (swap! sample update
              :number +slow 2 5000)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(do (future (swap! sample update :number +slow 1 2000))
    (future (swap! sample update :number +slow 2 5000)))
  \end{clojure}
\end{english}

\fi

\noindent
Проверим атом:

\begin{english}
  \begin{clojure}
@sample ;; {:number 3}
  \end{clojure}
\end{english}

\noindent
Это правильное значение: $0 + 1 + 2 = 3$. Вывод консоли:

\begin{english}
  \begin{text}
Current: 0, timeout: 2000 ;; 1
Current: 0, timeout: 5000 ;; 2
Current: 1, timeout: 5000 ;; 2
  \end{text}
\end{english}

Вторая функция сработала два раза, что и следует из алгоритма. Второй
\verb|swap!| начал расчёты с начальным значением \verb|{:number 0}|, а
к~завершению оно стало \verb|{:number 1}|~--- его записал первый
\verb|swap!|. Чтобы избежать ошибки, атом запустил второй \verb|swap!| ещё раз
относительно \verb|{:number 1}|.

Когда атом меняют из нескольких потоков, перезапуск может случиться больше двух
раз. Это недопустимо для функций, которые меняют окружение.

\subsection{Валидаторы и вотчеры}

\index{атом!валидация}
\index{валидация!в атоме}

Поведение атомов расширяют с помощью валидаторов и вотчеров (англ. watcher~---
<<наблюдатель>>). Валидаторы означают функции проверки. Они принимают новое
значение до того, как оно записано в текущее. Если валидатор вернул ложь, вызов
\verb|swap!| обернётся ошибкой.

\index{clojure.core!set-validator"!}

Функция \verb|set-validator!| добавляет валидатор к атому. Предположим, что
счётчик не может быть отрицательным. При попытке понизить его при нуле получим
исключение:

\ifnarrow

\begin{english}
  \begin{clojure}
(def counter (atom 2))
(set-validator!
  counter (complement neg?))
;;repeat 3 times...
(swap! counter dec)
;; Execution error IllegalStateException
;; Invalid reference state
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def counter (atom 2))
(set-validator! counter (complement neg?))
(swap! counter dec) ;; repeat 3 times...
;; Execution error (IllegalStateException)
;; Invalid reference state
  \end{clojure}
\end{english}

\fi

Вотчеры~--- это побочные эффекты атома. Они срабатывают после того, как атом
перешёл в новое состояние. Вотчер задают уникальным ключом и функцией. Она
принимает четыре аргумента: ключ, атом, старое и новое значения. Одному атому
можно назначить несколько вотчеров.

Разберёмся, когда полезны вотчеры. Вспомним подсчёт ресурсов: система получает
события и обновляет атом. Если потребление диска превысило лимит, мы не можем
бросить исключение. В этом нет смысла, потому что события поступают из внешней
системы. Исключение на нашей стороне не остановит поток событий.

\index{атом!вотчер}

Правильно задать реакцию на превышение лимита. Например, уведомить пользователя,
что ресурс исчерпан или обратиться в сервис, который отвечает за доступ. Для
этого и нужен вотчер: он связывает изменение атома с действием.

\index{логирование!в атоме}

В нашем случае, если потребление диска вышло за лимит, запишем в лог
сообщение. Объявим функцию вотчера \verb|store-watcher|. Из четырёх параметров
нам нужен только последний~--- \verb|value|, новое значение атома. В боевом коде
мы бы назначили первым трём символ подчёркивания. Оно затеняет лишние переменные
и поэтому работает быстрее. Однако мы оставили понятные имена, чтобы передать
семантику параметров.

\index{синтаксис!\textbf{\_} (затенение)}

\ifnarrow

\begin{english}
  \begin{clojure}
(def STORE_LIMIT (* 1024 1024 1024 25))
;; 25 Gb

(defn store-watcher
  [_key _atom _old value]
  (let [{:keys [store]} value]
    (when (> store STORE_LIMIT)
      (log/errorf
        "Disk usage %s has
                   reached the limit %s"
        store STORE_LIMIT))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def STORE_LIMIT (* 1024 1024 1024 25)) ;; 25 Gb

(defn store-watcher
  [_key _atom _old value]
  (let [{:keys [store]} value]
    (when (> store STORE_LIMIT)
      (log/errorf "Disk usage %s has reached the limit %s"
                  store STORE_LIMIT))))
  \end{clojure}
\end{english}

\fi

Добавим атому вотчер с ключом \verb|:watch-store|:

\ifnarrow

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))

(add-watch usage
  :watch-store store-watcher)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))

(add-watch usage :watch-store store-watcher)
  \end{clojure}
\end{english}

\fi

\noindent
Если потребление диска превысит лимит, увидим запись в лог:

\ifnarrow

\begin{english}
  \begin{clojure}
(swap! usage update :store + STORE_LIMIT)
;; Disk usage 26907012334
;; has reached the limit 26843545600
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(swap! usage update :store + STORE_LIMIT)
;; Disk usage 26907012334 has reached
;; the limit 26843545600
  \end{clojure}
\end{english}

\fi

Валидацию и вотчеры рассматривают как пре- и постэффекты. Разница в том, что
первые могут прервать исполнение, а вторые нет. У них разные задачи:
предварительные эффекты проверяют то, что может случиться, а постэффекты~--- то,
что уже случилось. Поэтому на них реагируют по-разному.

\subsection{Другие примеры}

\index{мемоизация}
\index{clojure.core!memoize}
\index{декораторы}

На атомы опираются некоторые функции Clojure, например \code{me\-moi\-ze}. Это
декоратор, который возвращает улучшенную версию функции. Она запоминает
результат относительно аргументов и записывает во внутреннюю таблицу. Если
вызвать функцию с теми же аргументами, получим результат из таблицы без
вычислений. Код функции \verb|memoize| из поставки Clojure:

\index{clojure.core!find}

\begin{english}
  \begin{clojure}
(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
  \end{clojure}
\end{english}

Роль таблицы играет атом. Функция-ре\-зуль\-тат \verb|memoize| замкнута на
атоме, который виден только ей. Заметим, что для поиска в~словаре используют
\verb|find| вместо \verb|get|. Разница в том, как функции трактуют пустое
значение. Если по ключу записан \verb|nil|, \verb|get| тоже вернёт \verb|nil|,
и~форма \verb|if-let| выполнит ложную ветку. Функция \verb|find| вернёт пару
\verb|MapEntry|, значение из которой находят при помощи \verb|val|.

Проверим декоратор на функции \verb|+slow|, которую задали выше. Объявим её
\verb|memoize|-версию и замерим вызовы:

\begin{english}
  \begin{clojure}
(def +mem (memoize +slow))

(time (+mem 1 2 2000))
;; Elapsed time: 2004.699832 msecs

(time (+mem 1 2 2000))
;; Elapsed time: 0.078052 msecs
  \end{clojure}
\end{english}

\index{классы!Thread}

Первый вызов долгий, потому что работает \verb|Thread/sleep| в теле
\verb|+slow|. Второй вызов получит результат из атома, что на порядки быстрее.

\index{счётчики}

Атомы полезны в веб-разработке: это дешёвый способ хранить состояние между
запросами. На атомах легко сделать счётчики просмотров, сессии, кэш. Счётчик
просмотра страниц~--- это комбинация атома и middleware:

\ifnarrow

\begin{english}
  \begin{clojure}
(def page-counter
  (atom {"/" 0}))

(defn wrap-page-counter
  [handler]
  (fn [request]
    (let [{:keys [uri request-method]}
          request]
      (when (= request-method :get)
        (swap! page-counter
          update uri (fnil inc 0)))
      (handler request))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def page-counter
  (atom {"/" 0}))

(defn wrap-page-counter
  [handler]
  (fn [request]
    (let [{:keys [uri request-method]} request]
      (when (= request-method :get)
        (swap! page-counter update uri (fnil inc 0)))
      (handler request))))
  \end{clojure}
\end{english}

\fi

\index{HTTP!GET}

На каждый GET-запрос мы увеличиваем счётчик для текущего адреса. Обратите
внимание на форму \verb|fnil| в вызове \verb|update| (предпоследняя строка). Она
возвращает версию \verb|inc|, которая не вызовет исключение, если первый
аргумент \verb|nil|. Это возможно, если в словаре ещё нет нужного ключа, и
вместо нуля функция получит \verb|nil|.

\index{форматы!HTML}
\index{библиотеки!Hiccup}

Чтобы узнать число просмотров, нужно достать из~атома словарь и~выполнить
\verb|get| по~текущему адресу. Напишем компонент для подвала сайта, где мелким
шрифтом указано, сколько раз смотрели страницу. Для HTML-разметки подойдут
библиотека \footurl{Hiccup}{https://github.com/weavejester/hiccup}[Hiccup]
и~аналоги.

\ifnarrow

\begin{english}
  \begin{clojure}
(defn component-footer [uri]
  [:div {:class "footer"}
   (let [seen (get @page-counter uri 0)]
     [:p [:small
          "The page has been seen " seen
          " time(s)."]])])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn component-footer [uri]
  [:div {:class "footer"}
   (let [seen (get @page-counter uri 0)]
     [:p [:small "The page has been seen "
                 seen
                 " time(s)."]])])
  \end{clojure}
\end{english}

\fi

\subsection{Замечания к атому}

У решений на атомах есть недостатки. Атомы не связаны с другими экземплярами
программы. Когда приложение занимает несколько нод, каждая хранит свой
счётчик. Если запросы расходятся по нодам случайно, клиент увидит разные
данные. Чтобы избежать странностей, используют сетевые хранилища вроде Redis.

\index{базы данных!Redis}

Атомы непостоянны: если завершить программу, они теряют состояние. С другой
стороны, атом быстрее, чем файловая система или сетевой сервис. Встречаются
гибридные схемы, когда на старте атом читает ресурс и раз в интервал сохраняет в
него изменения.

\section{Volatile}

Атом устроен довольно сложно: он отвечает за параллельный доступ, вызывает
валидацию и следит за изменениями. Иногда эти возможности излишни, и пользуются
его упрощённой версией~--- \verb|volatile|.

\index{clojure.core!volatile}
\index{clojure.core!vreset"!}

Объект \verb|volatile| тоже хранит и изменяет значение. Одноимённая функция
создаёт объект с состоянием. Функции \verb|vreset!| и \verb|vswap!|
аналогичны тем, что мы рассмотрели для атома. Префикс \verb|v| означает, что
они работают с \verb|volatile|.

Пример с ресурсами: на этот раз вместо атома используем другой тип хранилища:

\ifnarrow

\begin{english}
  \begin{clojure}
(def vusage (volatile! nil))
(vreset! vusage
         {:cpu 35
          :store 63466734
          :memory 10442856})
(vswap! vusage
  update :store + (* 1024 1024 5))
(println
  "Disk usage is" (get @vusage :store))
;; Disk usage is 68709614
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def vusage (volatile! nil))
(vreset! vusage
         {:cpu 35
          :store 63466734
          :memory 10442856})
(vswap! vusage update :store + (* 1024 1024 5))
(println "Disk usage is" (get @vusage :store))
;; Disk usage is 68709614
  \end{clojure}
\end{english}

\fi

Тип \verb|volatile| отличается от атома тем, что не контролирует запись
из~нескольких потоков. Перепишем пример с футурами:

\ifnarrow

\begin{english}
  \begin{clojure}
(def vnum (volatile! {:number 0}))
(do (future (vswap! vnum update
              :number +slow 1 2000))
    (future (vswap! vnum update
              :number +slow 2 5000)))
;; Current: 0, timeout: 2000
;; Current: 0, timeout: 5000
@vnum ;; {:number 2}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def vnum (volatile! {:number 0}))
(do (future (vswap! vnum update :number +slow 1 2000))
    (future (vswap! vnum update :number +slow 2 5000)))
;; Current: 0, timeout: 2000
;; Current: 0, timeout: 5000
@vnum ;; {:number 2}
  \end{clojure}
\end{english}

\fi

\index{clojure.core!future}
\index{футуры}

Вывод говорит, что второе действие сработало один раз. Если для атома итог был
3, то с \verb|volatile| получилось 2. Операцию \verb|+1| мы потеряли. Из
этого следует, что \verb|volatile| не подходит для многопоточного кода.

С другой стороны, в этом есть и преимущества. Из-за того, что \verb|volatile| не
упорядочивает доступ, изменения в нём протекают быстрее. По той же причине он не
поддерживает валидаторы и вотчеры. В целом \verb|volatile| нацелен на скорость.

\subsection{Применение}

У \verb|volatile| две области применения~--- трансдьюсеры и императивный
код. \footurl{Трансдьюсеры}{https://clojure.org/reference/transducers}[Trans\-ducers]~---
это особый способ работы с коллекциями. Они оборачивают функции \verb|map|,
\verb|reduce| и другие таким образом, что их комбинация не порождает
промежуточных списков. Трансдьюсеры часто полагаются на внутреннее состояние,
роль которого играет \texttt{volatile}. В данном случае возможности атома
излишни, потому что трансдьюсеры не делят состояние между потоками и не
нуждаются в валидаторах и вотчерах.

\verb|Volatile| полезен, когда пишут императивный код. Относитесь к этому
спокойно: иногда бизнес-требования слишком сложны, чтобы накладывать их на
функциональный стиль.

Представим, что нужно получить плоский список из дерева. Алгоритм обхода
сложный: если в первой ветке одно значение, то рассмотреть вторую, а иначе~---
третью. Когда для первой и третьей веток выполняется некое условие, добавить в
список произведение значений.

\index{императивный стиль}

Требования насквозь императивны, и выгодно задать их таким же образом. Этим мы
сделаем код ближе к бизнес-логике и облегчим поддержку. Малая часть дерева:

\ifnarrow

\begin{english}
  \begin{clojure}
(def data
  {:items [{:stats {:value 74}}
           {:stats {:value 65}}]
   :records [{:usage 99
              :date "2018-09-09"}
             {:usage 52
              :date "2018-11-05"}]})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def data
  {:items [{:stats {:value 74}}
           {:stats {:value 65}}]
   :records [{:usage 99 :date "2018-09-09"}
             {:usage 52 :date "2018-11-05"}]})
  \end{clojure}
\end{english}

\fi

Код разбивают на блоки, где каждый из них~--- это каскад \verb|when-let|. На
нижнем уровне мы изменяем коллекцию. Императивный стиль в данном случае удобен:
если одно из правил станет лишним, блок удаляют. Полезно ставить над блоком
комментарий или ссылку на документацию:

\ifnarrow

\begin{english}
  \begin{clojure}
(let [result (volatile! [])]

  ;; see section 5.4 from the doc
  (when-let [a (some-> data
                       :items
                       first
                       :stats
                       :value)]
    (when-let [b (some-> data
                       :records
                       last
                       :usage)]
      (when (> a b)
        (vswap! result conj (* a b)))))

  ;; more blocks...
  @result)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [result (volatile! [])]

  ;; see section 5.4 from the doc
  (when-let [a (some-> data :items first :stats :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (vswap! result conj (* a b)))))

  ;; more blocks...
  @result)
  \end{clojure}
\end{english}

\fi

\section{Переходные коллекции}

\index{коллекции!транзиентные}
\index{clojure.core!transient}

С помощью атома мы создали подобие изменяемых коллекций. Познакомьтесь с новой
техникой: Clojure предлагает настоящие изменяемые коллекции. По-другому
они называются \verb|transient| (англ.~временный, переходный).

Изменяемые коллекции получают из постоянных аналогов. С ними работают лишь
несколько функций, буквально добавить и удалить элемент. Стандартные \verb|map|,
\verb|filter| и другие не поддерживают \verb|transient|-коллекции. Происходит
своего рода обмен: мы теряем мощь стандартной библиотеки, но обретаем скорость и
императивный подход.

Транзиентные коллекции быстрее постоянных. Изменить ячейку памяти проще, чем
выделить новую и сдвинуть часть данных. Коллекция не должна пребывать в режиме
\verb|transient| всё время. Когда алгоритм закончил работу, её
замораживают и получают неизменяемую версию обратно.

\subsection{Примеры}

Функция \verb|transient| порождает переходную коллекцию из исходной. Для работы
с ней используют функции \verb|conj!|, \verb|assoc!|, \verb|dissoc!| и
другие. Восклицательный знак на конце предупреждает об изменении данных. Функции
меняют содержимое коллекции и возвращают её же по аналогии с обычными
\verb|conj| и \verb|assoc|

\index{clojure.core!persistent"!}

Функция \verb|persistent!| завершает работу с переходной коллекцией. Она
возвращает постоянную версию и одновременно <<запечатывает>> оригинал. После
\verb|persistent!| коллекцию уже нельзя изменить.

Рассмотрим переходный вектор. На него действуют функции \verb|conj!| и
\verb|pop!|, добавить и убрать элемент с конца:

\index{clojure.core!conj"!}

\begin{english}
  \begin{clojure}
(let [items* (transient [1 2 3])]
  (conj! items* :a)
  (conj! items* :b)
  (pop! items*)
  (persistent! items*))

;; [1 2 3 :a]
  \end{clojure}
\end{english}

\index{clojure.core!assoc"!}
\index{clojure.core!dissoc"!}

\noindent
Вариант со словарём, \verb|assoc!| и \verb|dissoc!|:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (assoc! params* :c 3)
  (dissoc! params* :b)
  (persistent! params*))

;; {:a 1, :c 3}
  \end{clojure}
\end{english}

Примечание: в примерах выше мы обозначили переменную звёздочкой. Это не нарушает
синтаксис Clojure. В отличие от других языков, в имени переменной могут быть
непривычные символы: дефис, штрих, знак вопроса. Особые переменные выделяют
штрихом или звёздочкой. Переходные коллекции встречаются редко, поэтому подходят
на роль особых.

Поскольку \verb|conj!| и аналоги возвращают переходную коллекцию, примеры выше
легко переписать на стрелочный оператор. С ним результат мутирующего вызова
переходит в следующее выражение:

\label{thread-transient}

\ifnarrow

\begin{english}

  \begin{clojure}
(-> [1 2 3]
    (transient)
    (conj! :a)
    (conj! :b)
    (pop!)
    (persistent!))

;; [1 2 3 :a]
  \end{clojure}

\splitter

  \begin{clojure}
(-> {:a 1}
    (transient)
    (assoc! :b 2)
    (assoc! :c 3)
    (dissoc! :b)
    (persistent!))

;; {:a 1 :c 3}
  \end{clojure}

\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
(-> [1 2 3]
    (transient)
    (conj! :a)
    (conj! :b)
    (pop!)
    (persistent!))

;; [1 2 3 :a]
  \end{clojure}

&

  \begin{clojure}
(-> {:a 1}
    (transient)
    (assoc! :b 2)
    (assoc! :c 3)
    (dissoc! :b)
    (persistent!))

;; {:a 1 :c 3}
  \end{clojure}

\end{tabular}

\end{english}

\fi

Переход к изменяемым коллекциями сводится к \verb|transient| и
\code{persistent!} на границах стрелочного оператора и восклицательным знакам в
\verb|assoc!| и аналогах. Заметим, что для одиночных \verb|transient| и
\verb|persistent!| скобки не обязательны, но мы добавили их, чтобы стиль кода
был одинаковым.

После вызова \verb|persistent!| коллекцию нельзя изменить. Следующий пример
бросит исключение:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (persistent! params*)
  (assoc! params* :c 3))

;; IllegalAccessError:
;; Transient used after persistent! call
  \end{clojure}
\end{english}

\subsection{Итерация с изменением}

\index{итерация}

Мы говорили, что переходные коллекции быстрее постоянных. Это заметно на долгих
итерациях через \verb|loop/recur|. Как правило, одна из переменных
\verb|loop|~--- это коллекция-результат. В каждом \verb|recur| мы передаем её
копию, дополненную через \verb|conj| или \verb|assoc|.

Когда итераций много, прибегают к уловке: вместо постоянной коллекции передают
её транзиентный вариант. Этим код ускоряют в 2--4 раза. Изменения в коде малы,
нужно лишь учесть следующее:

\begin{itemize}

\item
  обернуть коллекцию в \verb|transient|;

\item
  вместо \verb|conj| или \verb|assoc| вызвать их аналоги: \verb|conj!|
  и~\verb|assoc!|;

\item
  в конце вернуть постоянную коллекцию через \verb|persistent!|.

\end{itemize}

Для экспериментов объявим переменную \verb|nums|, список из миллиона целых
чисел:

\begin{english}
  \begin{clojure}
(def nums (range 999999))
  \end{clojure}
\end{english}

\index{clojure.core!loop}
\index{итерация!loop}

\noindent
Построим копию этого списка обычным \verb|loop|:

\begin{english}
  \begin{clojure}
(loop [result []
       [n & nums] nums]
  (if n
    (recur (conj result n) nums)
    result))
  \end{clojure}
\end{english}

\noindent
То же самое с изменяемым вектором:

\begin{english}
  \begin{clojure}
(loop [result* (transient [])
       [n & nums] nums]
  (if n
    (recur (conj! result* n) nums)
    (persistent! result*)))
  \end{clojure}
\end{english}

Число строк осталось прежним; изменилось только имя переменной и некоторые
детали. Правки не вышли за пределы \verb|loop|, что упрощает разработку. На
ранних стадиях мы напишем код без изменяемых коллекций, чтобы не отвлекаться на
них. Затем, если скорость критична, улучшим цикл так, что данные меняются.

Макрос \verb|time| принимает блок кода и печатает затраченное время. Если
обернуть в \verb|time| оба примера, получим результаты:

\begin{english}
  \begin{text}
;; 166.688721 msecs (persistent)
;;  69.415038 msecs (transient)
  \end{text}
\end{english}

Точные цифры зависят от оборудования и среды, в которой запущен код. Однако
отчётливо видна разница в несколько раз. Транзиентные коллекции действительно
быстрее постоянных аналогов.

\index{clojure.core!reduce}
\index{свёртка}

Ускорение работает и для \verb|reduce|. В других языках функция называется
\verb|fold| или <<свёртка>>. Центральная точка \verb|reduce|~---
аккумулятор результата. Им может быть любой тип, в том числе число или строка
для сложения и конкатенации. Однако чаще всего это список и словарь.

Различают два способа начать свёртку. В первом аккумулятор~--- начальный элемент
коллекции. Для списка \verb|(1, 2, 3)| и сложения им станет единица. Во втором
способе аккумулятор задают отдельно, например пустым вектором, куда в будущем
запишут данные.

Идея в том, чтобы сделать аккумулятор транзиентной коллекцией. На каждом шаге
\verb|reduce| меняет её функциями \verb|conj!| и~аналогами. Сравним
обычный \verb|reduce| и его мутабельную версию:

\ifnarrow

\begin{english}

  \begin{clojure}
(reduce
 (fn [result n]
   (conj result n))
 []
 nums)
  \end{clojure}

\splitter

  \begin{clojure}
(persistent!
 (reduce
  (fn [result* n]
    (conj! result* n))
  (transient [])
  nums))
  \end{clojure}

\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\linegap

  \begin{clojure}
(reduce
 (fn [result n]
   (conj result n))
 []
 nums)
  \end{clojure}

&

  \begin{clojure}
(persistent!
 (reduce
  (fn [result* n]
    (conj! result* n))
  (transient [])
  nums))
  \end{clojure}

\end{tabular}

\end{english}

\fi

Второй \verb|reduce| пришлось обернуть в \texttt{per\-sis\-tent!}. В случае с
\verb|loop| мы втянули \verb|persistent!| внутрь и изолировали изменения. В
этом плане \verb|reduce| не такой гибкий: внутри анонимной функции мы не
знаем, достигли конца итерации или нет. Без \verb|persistent!| второй пример
вернёт транзиентную коллекцию, что недопустимо.

\subsection{Скрытые детали}

Кажется, что изменяемые коллекции снимают преграды на пути к императивному
стилю. Это особенно помогает в сложной бизнес-логике. Представим, что нужно
наполнить вектор в зависимости от многих условий. Логично выразить это следующим
кодом:

\begin{english}
  \begin{clojure/lines}
(let [result* (transient [])
      push! (fn [item]
              (conj! result* item))]

  (when-let [a ...]
    (when-let [b ...]
      (when (> a b)
        (push! (- a b)))))

  ;; ... more of when/push! blocks

  (persistent! result*))
  \end{clojure/lines}
\end{english}

Функция \verb|push!| во второй строке замкнута на аккумуляторе \verb|result*|, чтобы не
требовать его в аргументах при каждом вызове. Обратите внимание, что результат
\verb|conj!| мы игнорируем. В английском языке приём называют
\footurl{<<bash in place>>}{https://clojure.org/reference/transients}[Transient\\*Structures].
Действительно, зачем нужен результат \verb|conj!|, если \verb|result*| доступен
в любом месте \verb|let|? Схема кажется удобной, но лучше воздержаться
от неё по двум причинам.

Во-первых, если код отталкивается от результата \verb|conj!| или \verb|assoc!|,
это делает его похожим на обычный вариант с постоянными коллекциями. Выше мы
рассмотрели пример со стрелочным оператором: изменяемая версия отличалась только
дополнительными \verb|persistent!| и \verb|transient| на
границах \page{thread-transient}. Похоже ведут себя итерация и свёртка: чтобы
ускорить обход, на каждом шаге передают транзиентный аккумулятор.

Из этого следует, что переход к транзиентным коллекциям (или вынужденный отказ
от них) должен проходить легко. В идеале вы добавляете \verb|persistent!| и
\verb|transient| и меняете \verb|conj| и \verb|assoc| на версии с
восклицательным знаком. Пример с локальной функцией \verb|push!| нарушает это
правило: его нельзя переписать на постоянные коллекции без серьёзных
изменений. В лучшем случае мы заменим \verb|transient| на \verb|atom|, а функция
\verb|push!| будет вызывать \verb|swap!| вместо \verb|conj!|.

Вторая и более важная причина в том, что иногда повторный вызов \verb|assoc!| на
исходной коллекции даёт неверный результат. Предположим, вы часто объединяете
словари и провели оптимизацию: написали функцию \verb|fast-merge| на переходных
коллекцях\footnote{Пример основан на комментариях к~функции \texttt{conj!} с
  сайта \texttt{clo\-ju\-re\-docs.org}}. Функция принимает два словаря. Из
первого она получает \verb|transient|-версию, затем в цикле добавляет пары из
второго словаря. Результат~--- постоянная коллекция:

\begin{english}
  \begin{clojure}
(defn fast-merge [map1 map2]
  (let [map* (transient map1)]
    (doseq [[k v] map2]
      (assoc! map* k v))
    (persistent! map*)))
  \end{clojure}
\end{english}

Проверка показывает, что всё верно: работает и замена ключей, и их дополнение:

\begin{english}
  \begin{clojure}
(fast-merge {:a 1 :b 2} {:a 3 :c 5})
;; {:a 3 :b 2 :c 5}
  \end{clojure}
\end{english}

Но для словаря объёмом более восьми ключей вы потеряете данные: в результате не
будет ключа \verb|:extra|:

\begin{english}
  \begin{clojure}
(fast-merge
 {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8}
 {:extra 9})

;; {:a 1 :b 2 :c 3 :d 4
;;  :e 5 :f 6 :g 7 :h 8}
  \end{clojure}
\end{english}

Если сократить первый словарь до семи ключей, \verb|:extra| попадёт в
него. Конечно, будет нелепо считать ключи и в зависимости от этого менять
алгоритм. Перепишем \verb|fast-merge| так, чтобы каждый \verb|assoc!| работал
относительно прошлого результата. Для этого подойдёт свёртка:

\begin{english}
  \begin{clojure}
(defn fast-merge [map1 map2]
  (persistent!
   (reduce-kv
    (fn [map* k v]
      (assoc! map* k v))
    (transient map1)
    map2)))
  \end{clojure}
\end{english}

Новая функция не теряет ключи, хотя их порядок отличается от исходного:

\begin{english}
  \begin{clojure}
(fast-merge
 {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8}
 {:extra 9})

;; {:extra 9 :e 5 :g 7 :c 3
;;  :h 8 :b 2 :d 4 :f 6 :a 1}
  \end{clojure}
\end{english}

Такое поведение связано со внутренним устройством класса
\texttt{Tran\-si\-ent\-Hash\-Map}, в который мы не будем сейчас
углубляться. Достаточно запомнить, что многократный вызов \verb|assoc!| на одной
и той же коллекции может подвести вас. Тесты на малых словарях пройдут без
ошибок, но в бою вы потеряете ключи. Найти подобную ошибку ст\'{о}ит больших усилий.

\subsection{Семантика и ограничения}

Изменяемые данные~--- это продвинутая техника, которая требует внимания. Как только
вы отказались от постоянных коллекций, контроль за изменениями ложится на вас.

Выигрыш в скорости ещё не значит, что их используют на каждом шагу. Худшее, что
может сделать разработчик,~--- написать код, где функции обмениваются
переходными коллекциями. Если это ваш случай, задумайтесь, почему автор языка
уделил так много внимания неизменяемости. Будет ошибкой игнорировать его идеи.

\index{люди!Дональд Кнут}

Феномен, когда на раннем этапе пытаются выжать из кода скорость, называется
преждевременной оптимизацией. Как заметил Дональд Кнут, это корень всех зол. Во
время оптимизации задавайте себе вопросы. Действительно важно ускорить этот
цикл? Не затруднит ли оптимизация поддержку кода? Это поможет проекту или вы
действуете из любопытства?

Изолируйте транзиентные коллекции в небольших функциях. Тогда переход от
постоянных типов к изменяемым не повлияет на результат. Рефакторинг должен
касаться только функции, а не её потребителей.

Изменяемая коллекция не имеет право быть глобальной. Воздержитесь от определений
\spverb|(def users* (transient []))| и~подобных. Вы придёте к~тому, что
\verb|users*| станет буфером обмена между функциями. Предсказать их результат
станет невозможно.

В отличие от атома, транзиентные типы не регулируют обращение из разных
потоков. Следите, чтобы только один поток изменял коллекцию. Не передавайте их в
футуры.

\section{Переменные и alter-var-root}

\index{переменные}
\index{clojure.core!alter-var-root}

\label{alter-var-root}

Атомы и переходные коллекции меняют объект, а не переменную. Это не всегда то,
чего мы ожидаем. Представим, что \verb|size|~--- это атом:

\begin{english}
  \begin{clojure}
(def size (atom 0))
  \end{clojure}
\end{english}

Чтобы изменить его, вызовем \verb|reset!| или \verb|swap!|, как в примерах
выше. Однако \verb|size| останется атомом. То же самое с переходными
коллекциями: легко добавить и удалить элемент, но это будет та же самая
коллекция. Невозможно присвоить ей \verb|nil|.

Иногда переменную нужно изменить: сделать так, чтобы сперва она была
\verb|nil|, затем словарём, затем снова \verb|nil|. Авторы намеренно
усложнили этот сценарий. Менять переменные можно, но нежелательно с точки зрения
языка.

Clojure не поощряет императивный стиль, когда переменную меняют много
раз. Глобальная переменная без уважительной причины~--- признак плохого кода.
Программист должен понимать, зачем она понадобилась и можно ли от неё
избавиться.

\index{monkey patch}

Всё же бывают случаи, когда глобальные переменные полезны. Один из них~---
компоненты системы.

Проект на Clojure состоит из отдельных компонентов или доменов. Это веб-сервер,
база данных, очередь сообщений. Каждый домен помещают в свой модуль:
\verb|http.clj|, \verb|db.clj| и так далее. В модуле объявляют переменную,
которая хранит состояние компонента. Например, \verb|server| в модуле сервера и
\verb|conn| в модуле базы. Возникает проблема, как объявить
переменную. Начинающие делают это в лоб:

\ifnarrow

\begin{english}
  \begin{clojure}
(def server
  (jetty/run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def server (jetty/run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

\fi

Выражение запустит сервер при загрузке модуля. Это плохая практика, потому что в
загрузке не должно быть побочных эффектов. С таким кодом невозможно работать в
REPL: он делает то, о чём не просили.

Сервер, базы данных и другие компоненты должны включаться по требованию, поэтому
их переменные вначале равны \verb|nil|. Функция \verb|start!| запускает
сервер и записывает его в \verb|server|. Функция \verb|stop!| останавливает
и меняет переменную на \verb|nil|.

\index{clojure.core!alter-var-root}

Чтобы изменить переменную, прибегают к \verb|alter-var-root|. Функция работает с
объектами, которые задали через \verb|def| и \verb|defn|. Вызов похож на
\verb|swap!| для атома: в параметры передают объект \verb|Var| и другую функцию,
которая вычислит новое значение из прежнего. Но перед тем как менять переменные,
познакомимся с ними ближе.

\ifafive\vspace{15mm}\fi

\subsection{Понятие переменной}

\label{var-section}

\index{переменные}
\index{классы!Var}

Рассмотрим, что такое \verb|Var|. Это экземпляр одноимённого класса из модуля
\verb|clojure.lang|. Класс описывает переменную в пространстве имён.  Чтобы
получить объект переменной, её символ передают в макрос \verb|var|, например
\verb|(var server)|. Эта запись аналогична \verb|#'server|, что немного короче.

\index{синтаксис!\texttt{\#\textquotesingle} (переменная)}

\index{символ}

Символ переменной и её объект~--- разные сущности. Сам по себе
символ ничего не значит: он равен только самому себе. Представьте, что символ~---
это слово языка, комбинация букв. В языке не бывает одинаковых слов, но у
слова может быть много значений.

\index{пространства имён}

Символ~--- это посредник между пространством имён и переменной. Когда мы пишем
\verb|(def num 42)|, это не значит, что переменная \verb|num| равна числу
42. На самом деле мы создали объект \verb|Var| со значением 42. Затем
поместили его в текущее пространство под символом \verb|num|.

Пространство имён работает как словарь. Его ключи~--- символы, а~значения~---
переменные. Формы \verb|def| и \verb|defn| наполняют этот словарь. Можно
сказать, \verb|def| задаёт слову смысл, и в момент компиляции Clojure
понимает это слово.

С символом связана операция вычисления. Если в REPL ввести \verb|num|,
он выполнит поиск с таким ключом в пространстве имён. Когда ключ найден, REPL
вернёт значение переменной, в нашем случае 42. В противном случае возникнет
ошибка.

Clojure намеренно скрывает от нас стадию переменной, и это правильно. Если бы
выражение \verb|num| вернуло переменную, в этом не было бы смысла. Технически
\verb|Var|~--- не цифра, а сложный объект. Значение 42~--- лишь одно из
множества его полей. Как правило, переменные скрыты от пользователя. Разработчик
видит либо их символ (\verb|num|), либо значение (\verb|42|). Функция
\verb|alter-var-root|~--- тот случай, когда переменные вступают в~игру.

\ifafive\vspace{20mm}\fi

\subsection{Запуск по требованию}

Вернёмся к серверу. Объявим переменную, которая в будущем станет объектом
\texttt{jetty.server\-.Server}. По умолчанию она равна \verb|nil|:

\begin{english}
  \begin{clojure}
(def server nil)
  \end{clojure}
\end{english}

Функция \verb|start!| заменяет \verb|server| результатом анонимной функции. Она
принимает текущее значение переменной. Если значение~--- \verb|nil|, создаём и
возвращаем новый сервер. Если нет, вернём текущий.

\ifnarrow

\begin{english}
  \begin{clojure}
(defn start! []
  (alter-var-root
   (var server)
   (fn [server]
     (if-not server
       (run-jetty app {:port 8080
                       :join? false})
       server))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn start! []
  (alter-var-root (var server)
    (fn [server]
      (if-not server
        (run-jetty app {:port 8080 :join? false})
        server))))
  \end{clojure}
\end{english}

\fi

\noindent
Аналогично работает \verb|stop!|: если сервер включен (не \verb|nil|),
остановим его и вернём \verb|nil|.

\begin{english}
  \begin{clojure}
(defn stop! []
  (alter-var-root
    (var server)
    (fn [server]
      (when server
        (.stop server))
      nil)))
  \end{clojure}
\end{english}

Вызов \verb|(start!)| запустит сервер в фоне. Браузер ответит на запросы по
адресу \texttt{localhost\-:8080}. Переменная \verb|server| напечатает в REPL
объект сервера.

\index{пул соединений}
\index{библиотеки!JDBC}

Похожим образом работают с базой. Чтобы не открывать подключение на каждый
запрос, применяют пулы соединений. В модуле объявляют переменную \verb|pool| со
значением \verb|nil|. Функция \verb|start!| создаёт новый пул и обновляет
переменную. После запуска к базе посылают запросы. Функции \verb|query|,
\verb|insert!| и другие из пакета JDBC принимают первым аргументом подключение к
базе или пул:

\ifnarrow

\begin{english}
  \begin{clojure}
(jdbc/query pool "select * from users")
(jdbc/insert! pool
  :users {:name "Ivan"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(jdbc/query pool "select * from users")
(jdbc/insert! pool :users {:name "Ivan"})
  \end{clojure}
\end{english}

\fi

Функция \verb|stop!| выключает пул, что закрывает открытые соединения, и
выставляет \verb|pool| в \verb|nil|. Опустим код этих функций, потому что они
аналогичны примерам для HTTP-сервера. Разница только в имени глобальной
переменной и выражении, которое создаёт сервер или пул.

\subsection{Коротко о системах}

\index{системы}

\label{systems-intro}

Техника \verb|alter-var-root| управляет состоянием модуля: включён или
выключен. С таким подходом проект удобно включать по частям, а не полностью. Для
отладки базы не нужен веб-сервер, а кэширование не зависит от рассылки писем.

Модули с состоянием называют компонентами. Вместе они образуют систему. С
помощью \verb|alter-var-root| строят системы в небольших проектах. В основном
это веб-приложение с сервером и базой данных. Подобные системы не зависят от
сторонних библиотек. Каждый модуль выставляет универсальные <<ручки
управления>>: функции \verb|start!| и \verb|stop!|, которые обращаются к
\verb|alter-var-root|. Это простая и удобная схема.

У этих систем недостаток: они не знают, как один компонент зависит от
другого. Со временем зависимости становятся проблемой, поэтому большие системы
строят с помощью библиотек. Некоторые из них тоже опираются на
\verb|alter-var-root|, но предлагают больше контроля за компонентами. Системам
посвящена отдельная глава этой книги \page{chapter-systems}.

\subsection{Патчинг}

\index{clojure.core!alter-var-root}
\index{патчинг}

Выше мы изменили переменную в текущем модуле. Истинная мощь
\verb|alter-var-root| в том, что функция работает с переменными любого
пространства. Под любым мы понимаем:

\begin{itemize}

\item
  текущий модуль;

\item
  соседние модули проекта;

\item
  сторонние библиотеки;

\item
  стандартные модули Clojure, например \texttt{clo\-ju\-re.co\-re}.

\end{itemize}

\index{monkey patch}

Это мощная техника, но к ней прибегают редко. Менять код в~полёте считается
сомнительной практикой. По-другому её называют
\footurl{monkey patch}{https://en.wikipedia.org/wiki/Monkey\_patch}[Monkey patch].
Термин означает изменение классов и функций не в~коде, а~когда программа уже запущена.

Если патчингом злоупотребляют, программа ведёт себя неочевидным образом. Ваши
коллеги не сразу поймут, почему в коде написано одно, а~выполняется другое. Это
затрудняет поддержку и вносит разногласие в коллектив. К патчингу прибегают,
если сошлись несколько условий:

\begin{itemize}

\item
  без изменений нельзя двигаться дальше;

\item
  проблема в сторонней библиотеке или платформе;

\item
  решение проблемы по регламенту займёт время, но вы не можете ждать.

\end{itemize}

Патчинг оправдан, когда вы нашли ошибку в чужой библиотеке. Даже если автор
принял изменения, новая версия появится не сразу. Чтобы не задерживать релиз,
подмените проблемную функцию с~помощью \verb|alter-var-root|.

Представим, что условная библиотека Yamler парсит файлы YAML. Её функция
\verb|read-yaml-tag| отвечает за теги. Выяснялось, что в особых случаях функция
бросает исключение вместо нормальной работы. Если ошибку легко исправить,
напишем функцию со звёздочкой и заменим оригинал:

\pagebreakafive

\ifnarrow

\begin{english}
  \begin{clojure}
(defn read-yaml-tag*
  "A fixed version of
   `yamler.tags/read-yaml-tag`.
   See pull request..."
  [stream tag]
  ...)

(alter-var-root
 (var yamler.tags/read-yaml-tag)
 (constantly read-yaml-tag*))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn read-yaml-tag*
  "A fixed version of `yamler.tags/read-yaml-tag`.
   See pull request..."
  [stream tag]
  ...)

(alter-var-root
 (var yamler.tags/read-yaml-tag)
 (constantly read-yaml-tag*))
  \end{clojure}
\end{english}

\fi

В комментарии добавьте ссылку на артефакт (GitHub, Jira), где описана проблема и
её решение. Создайте задачу, чтобы удалить патч по выходу новой версии
библиотеки.

Патчинг полезен и в разработке. Мы часто печатаем данные на экран, чтобы
исследовать их. Недостаток \verb|println| в том, что вывод не
структурирован. Коллекции слипаются в одну строку, поэтому их трудно читать.

\index{печать!с отступами}
\index{модули!clojure.pprint}

Пакет \verb|clojure.pprint| (сокращение от англ. \textbf{p}retty \textbf{p}rinting)
решает эту проблему. Функция \verb|pprint| выводит данные с отступами и~переносами строк,
что удобно для вложенных коллекций. Но писать \code{(clojure.\-pprint/\-pprint data)}
вместо \verb|(println data)| долго. Чтобы сократить код, заменим \verb|println|
на \verb|pprint|. Для этого пропатчим функцию:

\begin{english}
  \begin{clojure}
(alter-var-root
 (var println)
 (constantly clojure.pprint/pprint))
  \end{clojure}
\end{english}

Выполните этот патч один раз в любом месте проекта. Теперь вызов
\verb|(println data)| напечатает данные, как это делает \verb|pprint|:

\ifnarrow

\begin{english}
  \begin{clojure}
(println <vector-of-dicts-of-vectors>)

[{:foo 42
  :bar [1 2 3 4 5 {:foo 42
                   :bar [1 2 {# #}]}]}
 {:foo 42
  :bar [1 2 {:foo 42
             :bar [1 2 {# #}]}]}]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(println <vector-of-dicts-of-vectors>)

[{:foo 42
  :bar [1 2 3 4 5 {:foo 42
                   :bar [1 2 {# #}]}]}
 {:foo 42
  :bar [1 2 {:foo 42
             :bar [1 2 {# #}]}]}]
  \end{clojure}
\end{english}

\fi

Функция заменит глобоко вложенные участки на символ \verb|#|, чтобы не обрушить
на вас лавину данных. Глубину и длину печати задают особые переменные. Позже мы
узнаем, как управлять ими.

\subsection{В боевом режиме}

\label{install-logger}

\index{логирование!исключений}
\index{исключения!логирование}
\index{логирование!бекэнды}

Рассмотрим, когда \verb|alter-var-root| полезен в промышленном запуске. В
предыдущей главе мы отметили проблему: у нас нет контроля за тем, как выглядит
исключение в логе \page{log-ex-param}. Перевод исключения в текст остаётся на
усмотрение бекэнда (log4j, Logback и других Java-библиотек).

Мы написали функцию \verb|ex-print|, которая печатает исключение как нужно
нам. Функция не вываливает стек-трейс на весь экран, а обходит цепочку
исключений. Для каждого звена она выводит класс, сообщение и контекст:

\ifnarrow

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e
                   class
                   .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

\fi

\noindent
Минус в том, что вместо \verb|(log/error e)| приходится писать:

\begin{english}
  \begin{clojure}
(log/error (with-out-str (ex-print e)))
  \end{clojure}
\end{english}

Это долго и вынуждает импортировать \code{ex-print} в каждый модуль, где логируют
исключения. Будет удобней, если останется только \code{(log/\-error~e)}, а
\verb|ex-print| сработает где-то за кадром. Это возможно с помощью
\texttt{alter\-/var\-/root}.

Для начала заметим, что \verb|log/error|, \verb|log/info| и аналоги~--- это не
функции, а макросы. Макрос~--- эфемерная сущность, на которую нельзя сослаться
через \verb|var|. Макрос живет до компиляции программы. Позже на его месте
остаётся код, который он произвёл. Нельзя изменить макрос, но можно подменить
функцию, которую он вызывает.

\index{логирование}

Макрос \verb|log/error| и другие сводится к функции \verb|log/log*|. Это
бутылочное горлышко, через которое проходят все логи. Вот как выглядит её
сигнатура:

\ifnarrow

\begin{english}
  \begin{clojure}
(defn log*
  [logger level throwable message])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn log* [logger level throwable message])
  \end{clojure}
\end{english}

\fi

Параметр \verb|throwable|~--- исключение или \verb|nil|. Подменим \verb|log*| на
анонимную функцию со следующей логикой:

\begin{itemize}

\item
  если \verb|throwable| равен \verb|nil|, вызвать \verb|log*| с исходными
  аргументами;

\item
  если же нет, то перевести исключение в текст с помощью \verb|ex-print|;

\item
  добавить его к исходному сообщению через перенос строки;

\item
  вызвать оригинальный \verb|log*| с новым сообщением и \verb|nil| для
  \verb|throwable|. В исключении отпала потребность, поскольку теперь оно
  часть сообщения.

\end{itemize}

Для ясности разделим код на две части. Поместим первую часть в функцию
\code{install-better-logging}. Она подменяет \verb|log*| с помощью неизвестной
пока что \texttt{make-better-logger}.

\begin{english}
  \begin{clojure}
(defn install-better-logging []
  (alter-var-root
   #'clojure.tools.logging/log*
   make-better-logger))
  \end{clojure}
\end{english}

Заметим, что если модулю логирования назначили псевдоним, ссылку на \verb|log*|
можно записать короче:

\index{функции!install-better-logging}

\ifnarrow

\begin{english}
  \begin{clojure}
(require '[clojure.tools.logging :as log])

(defn install-better-logging []
  (alter-var-root
    #'log/log* make-better-logger))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.tools.logging :as log])

(defn install-better-logging []
  (alter-var-root #'log/log* make-better-logger))
  \end{clojure}
\end{english}

\fi

Вторая часть: функция \texttt{make-better-logger} принимает старую функцию
логирования и возвращает новую. Она принимает те же аргументы, но логика
логирования отличается. Новая функция меняет входные параметры и вызывает с ними
старую функцию логирования.

\ifnarrow

\begin{english}
  \begin{clojure/lines}
(defn make-better-logger
  [log*] ;; origin function
  (fn [logger lvl e msg]
    (if e
      (let [msg*
            (str msg \newline
                 (with-out-str
                   (ex-print e)))]
        (log* logger lvl nil msg*))
      (log* logger lvl e msg))))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(defn make-better-logger
  [log*] ;; origin function
  (fn [logger level throwable message]
    (if throwable
      (let [ex-out (with-out-str (ex-print throwable))
            message* (str message \newline ex-out)]
        (log* logger level nil message*))
      (log* logger level throwable message))))
  \end{clojure/lines}
\end{english}

\fi

Хитрость кроется во второй строке: параметр \verb|log*| ссылается на исходную
функцию \verb|clojure.tools.logging/log*|. Новая функция логирования замкнута на
исходной и может её вызывать.

Получился декоратор: мы только меняем входные параметры и передаём дальше. После
вызова \verb|(install-better-logging)| вывод исключений изменится. Достаточно
написать \texttt{(log/error e message)}, чтобы ошибка приняла нужный вид.

Преимущество в том, что мы управляем всем процессом на уровне Clojure. Если
понадобится улучшить логи, доработаем \verb|ex-print| в любой момент. Это
удобнее, чем наследовать условный \verb|com.logging.ErrorRenderer|
и~переопределять его методы.

Вред от необдуманного \verb|alter-var-root| сводит на нет плюсы, что мы
рассмотрели. Функция нужна, чтобы точечно менять переменные в~особых
случаях. Прибегайте к патчингу только если другие варианты исчерпаны.

\section{Присваивание с set!}

\index{печать!с отступами}
\index{модули!clojure.pprint}

Вернёмся к функции \verb|pprint| для красивой печати. Она интересна тем, что
проверяет длину и уровень коллекций. Так мы не допустим ситуации, когда печать
заливает несколько экранов. Проверка на длину особенно важна, потому что
некоторые коллекции не просто велики, а бесконечны.

\index{коллекции!бесконечные}
\index{clojure.core!*print-length*}
\index{clojure.core!set"!}

Глобальные переменные \verb|*print-length*| и \verb|*print-level*| задают длину
и вложенность вывода. По умолчанию переменная \verb|*print-length*| равна 100. Это довольно
много, особенно если учесть, что элементами могут быть другие
коллекции. Например, результат запроса к базе~--- список словарей. Печатать сто
словарей расточительно, поэтому уменьшим \verb|*print-length*| на старте
приложения. Для этого служит форма \verb|set!|:

\begin{english}
  \begin{clojure}
(set! *print-length* 8)
  \end{clojure}
\end{english}

Теперь вывод бесконечной коллекции покажет только первые восемь
элементов. Многоточие означает, что остальные элементы отбросили.

\begin{english}
  \begin{clojure}
(println (repeat 1))
;; (1 1 1 1 1 1 1 1 ...)
  \end{clojure}
\end{english}

Вложенность или уровень коллекции~--- это воображаемый индекс. Когда одна коллекция
становится элементом другой, её индекс увеличивается на единицу. Объявим
вложенную структуру:

\begin{english}
  \begin{clojure}
(def data {:foo
            {:bar
              {:baz [42]}}})
  \end{clojure}
\end{english}

\noindentnarrow
Вывод с различными значениями \texttt{*print\-/level*}:

\ifnarrow

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
;; {:foo {:bar #}}
  \end{clojure}

\splitter

  \begin{clojure}
(set! *print-level* 2)
(println data)
;; {:foo #}
  \end{clojure}
\end{english}

\else

\begin{english}
\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }


  \begin{clojure}
(set! *print-level* 4)
(println data)
;; {:foo {:bar #}}
  \end{clojure}

&

  \begin{clojure}
(set! *print-level* 2)
(println data)
;; {:foo #}
  \end{clojure}

\end{tabular}

\end{english}

\fi

\noindent
При нулевом уровне увидим только \verb|#|.

В Clojure около десяти переменных с <<ушками>>. По-другому их~называют
системными, потому что они влияют на поведение языка в~целом. Две переменных мы
уже рассмотрели: это \verb|*print-length*| и~\verb|*print-level*| для
печати. Перечислим несколько других:

\index{синтаксис!\texttt{*}ушки\texttt{*}}

\begin{itemize}

\index{рефлексия}
\index{clojure.core!*warn-on-reflection*}

\item
  \verb|*warn-on-reflection*|: если истина, компилятор предупредит о местах, где
  он обратился к рефлексии. Проблему решают расстановкой тегов с типами;

\index{clojure.core!assert}
\index{clojure.core!*assert*}

\item
  \verb|*assert*|: если ложь, отключает макрос assert. Этот макрос \verb|assert|
  проверяет выражение на истинность. Если оно ложно, макрос бросит исключение.
  По умолчанию \verb|assert|ы включены; ими пользуются в разработке и
  тестировании. В боевом режиме их~выключают, чтобы не тратить ресурсы;

\label{print-meta}

\index{метаданные}
\index{печать!метаданных}
\index{clojure.core!*print-meta*}
\index{библиотеки!Component}

\item
  \verb|*print-meta*|: выводить или нет метаданные объекта при печати. По
  умолчанию~--- ложь. Иногда в метаданных хранят поля, которые влияют на работу
  программы. Например, библиотека Component управляет зависимостями компонентов
  через метаданные. Чтобы увидеть их, установите \verb|*print-meta*| в~истину.

\end{itemize}

Эти и другие переменные изменяют формой \verb|set!|. Рассмотрим несколько
примеров.

Показать предупреждения, если компилятор не вывел тип:

\ifnarrow

\begin{english}
  \begin{clojure}
(set! *warn-on-reflection* true)
(def ms (System/currentTimeMillis))

(.toString ms) ;; reflection warning
(.toString ^Long ms) ;; no warning
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(set! *warn-on-reflection* true)
(def ms (System/currentTimeMillis))

(.toString ms)       ;; reflection warning
(.toString ^Long ms) ;; no warning
  \end{clojure}
\end{english}

\fi

Отключить формы \verb|assert|. Ложные выражения не вызовут ошибку:

\begin{english}
  \begin{clojure}
(set! *assert* false)
(assert (get {:foo 3} :bar))
;; won't throw an exception
  \end{clojure}
\end{english}

Вывести объект с метаданными (приведём фрагмент в~листинге
\ref{fig:print-var-meta}). Обратите внимание, что переменная хранит путь к файлу
и номер строки в~нём. Эти сведения используют плагины к редактору и IDE для
навигации по коду.

\begin{listing}[ht!]

\begin{english}
  \begin{clojure}
(set! *print-meta* true)
(var +)

^{:added "1.2"
  :name +
  :file "clojure/core.clj"
  :column 1
  :line 984
  :arglists ([] [x] [x y] [x y & more])
  :doc "Returns the sum of nums..."}
#'clojure.core/+
  \end{clojure}
\end{english}

\caption{Печать переменной в REPL с метаданными}
\label{fig:print-var-meta}

\end{listing}

\index{утилиты!lein}
\index{профили!lein}

Утилиты для управления проектами читают переменные с <<ушками>> из
настроек. Например, \verb|lein| учитывает ключ \texttt{:global\-/vars} в файле
\verb|project.clj|. Ещё большей гибкости можно добиться, если указать переменные
в профилях. Ниже мы задаём разные переменные в зависимости от режима разработки
(\verb|dev|) или сборки (\verb|uberjar|). Идея в том, чтобы видеть все случаи
рефлексии локально, но не засорять ими вывод в боевом режиме.

\ifnarrow

\begin{english}
  \begin{clojure}
{:profiles
 :dev {:global-vars
       {*warn-on-reflection* true
        *assert* true}}
 :uberjar {:global-vars
           {*warn-on-reflection* false
            *assert* false}}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:profiles
 :dev {:global-vars {*warn-on-reflection* true
                     *assert* true}}
 :uberjar {:global-vars {*warn-on-reflection* false
                         *assert* false}}}
  \end{clojure}
\end{english}

\fi

Внутри \verb|binding| форма \verb|set!| работает как оператор
присваивания. Переменная должна быть динамической. Умножим ставку на число дней
в императивном стиле:

\begin{english}
  \begin{clojure}
(def ^:dynamic *rate*)
(def ^:dynamic *days*)

(binding [*rate* 0
          *days* 0]
  (when-let [rate (calc-date)] ;; 3
    (set! *rate* rate))
  (when-let [days (calc-days)] ;; 4
    (set! *days* days))
  (* *rate* *days*))
;; 12
  \end{clojure}
\end{english}

За пределами \verb|binding| вызов \verb|set!| обернётся ошибкой, даже если
переменная с~<<ушками>>:

\ifnarrow

\begin{english}
  \begin{clojure}
(def ^:dynamic *data* nil)

(set! *data* {:user 1})
;; Unhandled IllegalStateException
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def ^:dynamic *data* nil)

(set! *data* {:user 1})
;; Unhandled java.lang.IllegalStateException
;; Can't change root binding of: *data* with set
  \end{clojure}
\end{english}

\fi

\section{Изменения в контексте}

\index{контекст}
\index{изменения!в контексте}

Приёмы, которые мы рассмотрели, похожи в следующем: их эффект длится до конца
программы. Изменения в атомах, транзиентных коллекциях и глобальных переменных
называют персистентными (англ.~persistent~--- постоянный).

Иногда изменения должны быть временными: глобальная переменная равна $x$, но
участок кода ожидает $y$. Можно сделать временные изменения на базе постоянных:
окружить код вызовом \verb|alter-var-root| с новым и старым значениями. У
такого подхода две проблемы: изоляция и откат.

\index{clojure.core!alter-var-root}

Как правило, от временных изменений ожидают, что они происходят в одном
потоке. У~\texttt{alter\-/var\-/root} противоположный эффект~--- функция меняет
переменную для всех потоков. Если фрагмент кода вызывает \verb|alter-var-root|,
он влияет на всех участников. Это приводит к странному поведению программы.

Проблема отката означает, что при выходе из блока переменную нужно вернуть в прежнее
состояние. Когда код оборачивают в формы \verb|alter-var-root| или \verb|set!|, одна
из них может потеряться или не получить управление из-за ошибки.

Clojure предлагает несколько форм, чтобы выполнить код в контексте переменных с
другими значениями. Одна из них называется \verb|binding| \eng{связывание}.

\index{связывание}
\index{clojure.core!binding}

Синтаксис \verb|binding| похож на \verb|let|: форма связывания и произвольный
код. Связывание~--- это вектор, где указаны символы переменных и~новые
значения. Символы ссылаются на уже объявленные переменные. Блок кода запускается
с новыми значениями переменных. Результат \verb|binding|~--- последнее выражение
блока. Изменения \verb|binding| протекают в рамках текущего потока и не влияют
на соседние. При выходе переменные получат старые значения.

\subsection{Динамические переменные}

\label{dynamic-vars}

\index{переменные!динамические}
\index{синтаксис!\texttt{\^} (метаданные)}

\verb|Binding| работает только с динамическими переменными. Компилятор считает
переменную таковой, если ей назначили тег \verb|^:dynamic|. Это сокращённая
форма \verb|^{:dynamic true}| перед именем переменной:

\begin{english}
  \begin{clojure}
(def ^:dynamic *server* nil)
;; or
(def ^{:dynamic true} *server* nil)
  \end{clojure}
\end{english}

Словарь с крышкой в \verb|def| называют метаданными. Это дополнительные
параметры будущей переменной. В данном случае мы сообщаем компилятору, что
переменная динамическая и может быть изменена в~будущем.

Глобальные переменные выделяют <<ушками>>, звёздочками по краям. В английском
языке такую запись называют earmuffs syntax. Правило возникло в старых диалектах
Лиспа, где было принято выделять глобальные переменные на общем фоне. В этом
плане Clojure следует традиции.

\index{языки!Lisp}

<<Ушки>> и динамичность связаны между собой. Если переменная с~<<ушками>>, но не
динамическая, компилятор предупредит о расхождении. Сами по себе <<ушки>> не
делают переменную динамической, это просто соглашение.

\pagebreakafive

\ifnarrow

\begin{english}
  \begin{clojure}
(def *server* nil)
;; Warning: *server* not declared dynamic
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def *server* nil)
;; Warning: *server* not declared dynamic and thus [...]
;; Please either indicate ^:dynamic *server*
;; or change the name.
  \end{clojure}
\end{english}

\fi

\noindent
Если переменная не динамическая, \verb|binding| бросит исключение:

\ifnarrow

\begin{english}
  \begin{clojure}
(binding [*server* {:port 8080}]
  (println *server*))
;; IllegalStateException
;; Can't dynamically bind
;; non-dynamic var: *server*
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(binding [*server* {:port 8080}]
  (println *server*))
;; Execution error (IllegalStateException)
;; Can't dynamically bind non-dynamic var: *server*
  \end{clojure}
\end{english}

\fi

\subsection{Отказ от set!}

Вспомним параметры длины и глубины печати. Чтобы обезопасить себя от бесконечных
данных, мы писали что-то вроде:

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
  \end{clojure}
\end{english}

\index{печать!с отступами}

Это неудачный пример: он нарушает принципы изоляции и отката, которые мы
рассмотрели. Изменение \verb|*print-level*| не изолировано и~влияет на систему
глобально. Если другой поток что-то напечатает, мы увидим результат с уровнем 4,
что может нас не устроить. После \verb|(println data)| нужно восстановить
прежнее значение \verb|*print-level*|, но об этом легко забыть.

Код ниже избавлен от недостатков. Вне \texttt{bin\-ding} переменные останутся с
прежними значениями, а внутри него изменения коснутся только текущего потока.

\ifnarrow

\begin{english}
  \begin{clojure}
(binding [*print-level* 8
          *print-length* 4]
  (println
    {:foo {:bar {:baz (repeat 1)}}}))
;; {:foo {:bar {:baz (1 1 1 1 ...)}}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(binding [*print-level* 8
          *print-length* 4]
  (println {:foo {:bar {:baz (repeat 1)}}}))
;; {:foo {:bar {:baz (1 1 1 1 ...)}}}
  \end{clojure}
\end{english}

\fi

\index{clojure.core!*out*}
\index{классы!Writer}

Чтобы направить печать в файл, свяжите переменную \verb|*out*| с~объектом
\verb|Writer|:

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(with-open [out (io/writer "dump.edn")]
  (binding [*out* out]
    (clojure.pprint/pprint {:test 42})))
  \end{clojure}
\end{english}

Объединим эти примеры в функцию для сброса данных в файл. Функция полезна для
отладки больших данных. Она принимает путь к файлу и коллекцию. Функция
связывает вывод с открытым файлом и печатает данные. Чтобы увидеть все элементы,
повысим длину и~глубину печати.

\begin{english}
  \begin{clojure}
(defn dump-data
  [data path]
  (with-open [out (io/writer path)]
    (binding [*out* out
              *print-level* 32
              *print-length* 512]
      (clojure.pprint/pprint data))))
  \end{clojure}
\end{english}

\noindent
Сброс данных в файл:

\ifnarrow

\begin{english}
  \begin{clojure}
(dump-data
  {:foo [1 2 3 {:foo [1 2 3]}]}
  "sample.edn")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(dump-data {:foo [1 2 3 {:foo [1 2 3]}]} "sample.edn")
  \end{clojure}
\end{english}

\fi

\noindent
и восстановление:

\begin{english}
  \begin{clojure}
(-> "sample.edn" slurp read-string)
;; {:foo [1 2 3 {:foo [1 2 3]}]}
  \end{clojure}
\end{english}

\index{clojure.core!*print-level*}
\index{clojure.core!*print-length*}

Доработайте функцию так, чтобы длину и глубину печати можно было задать
произвольно. В идеале это необязательный словарь \verb|opt|, в~котором функция
ищет настройки.

\subsection{Практика: перевод строк}

\label{translate}

Привёдем пример с \verb|binding| из реального проекта. Это веб-приложение на
разных языках. В зависимости от настроек клиент видит английский или русский
текст в интерфейсе и сообщениях.

\index{перевод}

Переводы хранят в словаре с двумя уровнями: локаль и теги. Локаль~--- это код
языка: \verb|ru|, \verb|en| и другие. Локаль может быть с доменами, например
\verb|en_US| или \verb|en_GB|. Части \verb|US| и \verb|GB| означают
американский и~британский диалекты. В редких случаях локаль бывает тройной,
чтобы указать местный алфавит или регион.

Под тегом понимают короткую машинную строку. Она описывает семантику фразы, на
которую позже её заменят. По тегу \verb|ui/add-to-cart| легко понять, что это
надпись <<добавить в корзину>> в интерфейсе.

Словари могут быть в коде или файлах, но принцип перевода не меняется. По локали
и тегу библиотека ищет перевод в словаре (или <<совершает lookup>>). Напишем
наивный подход на Clojure:

\ifnarrow

%% \begin{english}
  \begin{clojure}
(def tr-map
  {:en {:ui/add-to-cart "Add to Cart"}
   :ru {:ui/add-to-cart
        "Добавить в корзину"}})

(defn tr [locale tag]
  (or (get-in tr-map [locale tag])
      (format "<%s%s>" locale tag)))
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def tr-map
  {:en {:ui/add-to-cart "Add to Cart"}
   :ru {:ui/add-to-cart "Добавить в корзину"}})

(defn tr [locale tag]
  (or (get-in tr-map [locale tag])
      (format "<%s%s>" locale tag)))
  \end{clojure}
%% \end{english}

\fi

\index{локализация}

Функция \verb|tr| возвращает перевод по локали и тегу. Если перевод не найден,
получим машинное выражение, которое заметят локализаторы.

Недостаток функции в том, что каждый раз нужно указывать локаль. Это
утомительно, особенно с учётом того, что локаль не меняется в рамках
запроса. Между локалью и переводом большие физическая и ментальная
дистанции, и хотелось бы их сократить.

\index{стек вызовов}

Под физическим расстоянием понимают стек вызовов. Обычно локаль вычисляют в
начале запроса. Перевод текста, напротив, работает ближе к его концу. Если не
сделать локаль глобальной, придётся спускать её в аргументах по стеку вызовов,
что усложнит код.

\index{фреймворки!Django}

Ментальная дистанция означает, что в момент перевода нам не важно, откуда пришла
локаль. Эти сведения избыточны. Хотелось бы примитивную операцию <<перевести
тег>>, и не больше. По этим принципам работает шаблонная система в фреймворке
\footurl{Django}{https://docs.djangoproject.com/en/2.2/topics/templates/}[Django templates].
Она оказалась столь удобной, что со временем перешла на другие платформы.

\index{библиотеки!Selmer}
\index{шаблоны}

Аналог такой системы в Clojure называется \footurl{Selmer}{https://github.com/yogthos/Selmer}[Selmer].
Её шаблоны похожи на обычные HTML-файлы со вставками в фигурных скобках. Код в
скобках~--- значения или выражения. Вертикальные линии означают фильтры, функции
преобразования. Например, запись:

\begin{english}
  \begin{htmldjango}
<p>{{ user.email|lower }}</p>
  \end{htmldjango}
\end{english}

\noindent
означает, что между тегами параграфа находится поле \verb|:email| из словаря
\verb|user|. Регистр поля меняют на нижний фильтром \verb|lower|. На Clojure
это выглядело бы так:

\ifnarrow

\begin{english}
  \begin{clojure}
(str "<p>"
     (str/lower-case (:name user))
     "</p>")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(str "<p>" (str/lower-case (:name user)) "</p>")
  \end{clojure}
\end{english}

\fi

Хотелось бы, чтобы шаблон выглядел как можно проще: в фигурных скобках идёт тег
фразы, а за ним~--- фильтр перевода.

\ifnarrow

\begin{english}
  \begin{htmldjango}
<div class="widget">
  <a href="/login">
    {{ "ui/log-in"|tr }}
  </a>
  <a href="/help">
    {{ "ui/help"|tr }}
  </a>
</div>
  \end{htmldjango}
\end{english}

\else

\begin{english}
  \begin{htmldjango}
<div class="widget">
  <a href="/login">{{ "ui/log-in"|tr }}</a>
  <a href="/help">{{ "ui/help"|tr }}</a>
</div>
  \end{htmldjango}
\end{english}

\fi

Технически фильтр \verb|tr|~--- функция одной переменной. Она принимает строку
тега и возвращает перевод. Очевидно, локаль должна быть известна
заранее. Сделаем так, чтобы фильтр читал её из middleware и при этом не влиял на
перевод в параллельных запросах.

Поможет связывание через \verb|binding|. Объявим переменную \verb|*locale*| без
значения. В Clojure такая переменная называется несвязанной. Считайте её
ячейкой, в которой нет данных.

Изменим функцию \verb|tr|: теперь она принимает только тег, а в качестве
локали ссылается на глобальную \verb|*locale*|:

\pagebreakafive

\begin{english}
  \begin{clojure}
(def ^:dynamic *locale*)

(defn tr [tag]
  (get-in tr-map [*locale* tag]))
  \end{clojure}
\end{english}

\index{макросы!with-locale}

Чтобы изолировать \verb|*locale*| от потребителей, предоставим макрос
\verb|with-locale|. Он выполняет тело, пока переменная связана с заданной
локалью. Внутри макроса любой перевод сработает для этой локали:

\begin{english}
  \begin{clojure}
(defmacro with-locale
  [locale & body]
  `(binding [*locale* ~locale]
     ~@body))
  \end{clojure}
\end{english}

Примеры для разных языков:

\ifnarrow

\begin{clojure}
(with-locale :en
  (tr :ui/add-to-cart))
;; "Add to Cart"
\end{clojure}

\splitter

\begin{clojure}
(with-locale :ru
  (tr :ui/add-to-cart))
;; "Добавить в корзину"
\end{clojure}

\else

%% \begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
(with-locale :en
  (tr :ui/add-to-cart))
;; "Add to Cart"
  \end{clojure}

&

  \begin{clojure}
(with-locale :ru
  (tr :ui/add-to-cart))
;; "Добавить в корзину"
  \end{clojure}

\end{tabular}

%% \end{english}

\fi

\index{middleware!wrap-locale}

Напишем middleware, чтобы определить локаль. Для простоты решим, что это
параметр \verb|lang| из адресной строки. Если параметра нет, берём локаль по
умолчанию. Для удобства вынесем поиск локали в функцию:

Код ниже по стеку обёрнут в макрос \texttt{with\-/locale}:

\ifnarrow

\begin{english}
  \begin{clojure}
(defn request->locale [request]
  (let [lang (get-in request
               [:params "lang"])]
    (keyword
      (get #{"en" "ru"} lang "en"))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn request->locale [request]
  (let [lang (get-in request [:params "lang"])]
    (keyword (get #{"en" "ru"} lang "en"))))
  \end{clojure}
\end{english}

\fi

Так выглядит middleware. Код ниже по стеку сработает в рамках
\verb|with-locale|:

\ifnarrow

\begin{english}
  \begin{clojure}
(defn wrap-locale [handler]
  (fn [request]
    (with-locale
      (request->locale request)
      (handler request))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn wrap-locale [handler]
  (fn [request]
    (with-locale (request->locale request)
      (handler request))))
  \end{clojure}
\end{english}

\fi

Напишем фильтр \verb|tr| для шаблонной системы. В Selmer нельзя указать кейворд,
поэтому вместо \verb|{{ :ui/sign-in }}| пишут \verb|{{ "ui/sign-in"}}|.  Фильтр
\verb|tr| переводит строку в кейворд, а затем ищет по нему перевод. Функция
\verb|add-filter!| добавляет \verb|tr| в регистр фильтров.

\ifnarrow

\begin{english}
  \begin{clojure}
(require
 '[selmer.filters :refer [add-filter!]])

(add-filter! :tr
 (fn [line]
   (-> line keyword tr)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[selmer.filters :refer [add-filter!]])

(add-filter! :tr
 (fn [line]
   (-> line keyword tr)))
  \end{clojure}
\end{english}

\fi

Теперь нам не важен источник локали в переводах. В любой момент мы изменим код
\verb|with-locale| и \verb|wrap-locale|, но это не отразится на
шаблонах. Запись \verb={{ "ui/log-in"|tr }}= останется прежней, даже если
механизм переводов изменится.

\section{Локальные переменные в~контексте}

\index{clojure.core!with-local-vars}
\index{clojure.core!let}
\index{clojure.core!var-get}
\index{clojure.core!var-set}
\index{переменные!локальные}

Макрос \verb|with-local-vars| задаёт локальные переменные. Внутри макроса они
ведут себя как маленькие атомы. В переменную можно записать значение и получить
его обратно <<дерефом>>. Локальные переменные полезны в запутанной
бизнес-логике. Блок с ними выглядит линейно, и его проще читать.

Форма \verb|with-local-vars| похожа на \verb|let|: это вектор связывания и
произвольный код. Разница в том, что внутри макроса работают функции
\verb|var-get| и \verb|var-set|. С их помощью читают и~записывают
переменные. Если макрос объявил переменную \verb|a|, форма \verb|(var-set a 9)|
присвоит ей~9.

Важно: символ переменной вернёт её объект, а не значение. В~примере ниже получим
не ноль, а объект типа \verb|Var|. Запись \verb|(+ a 1)| приведёт~к ошибке
типов.

\begin{english}
  \begin{clojure}
(with-local-vars [a 0] a)
;; #<Var: --unnamed-->
  \end{clojure}
\end{english}

Функция \verb|var-get| получает значение из переменной. Для краткости
прибегают к оператору \verb|@|: \verb|(+ @a 1)|.

Представим: нужно найти в дереве несколько величин и вернуть их композицию. В
прошлый раз мы работали с атомом, теперь решим задачу на локальных переменных.

Функция \verb|calc-billing| рассчитывает сумму к оплате для клиента. В параметре
\verb|data|~--- данные о потреблении ресурсов. Итоговую сумму находят из трёх
составляющих. Каждую из них рассчитывают по сложным условиям. Чтобы код был
ближе к бизнес-логике, запишем его императивно:

\begin{english}
  \begin{clojure}
(defn calc-billing [data]
  (with-local-vars [a 0 b 0]

    ;; find a
    (when-let [usage ...]
      (when-let [days ...]
        (var-set a (* usage days))))

    ;; find b
    (when-let [vms ...]
      (when-let [limits ...]
        (var-set b (* limits vms))))

    (* @a @b))) ;; result
  \end{clojure}
\end{english}

Расчёт делится на блоки, каждый из которых находит составляющую. Каскад
\verb|when-let| собирает нужные переменные, и если они нашлись, завершается
\verb|var-set|. Если исполнение не дошло до \verb|var-set|, переменная останется
нулём.

Локальные переменные не настолько продвинуты, как атомы. Для переменных нет
аналога \verb|swap!|, когда значение меняют функцией. \verb|With-local-vars| не
подходит для приращения коллекций. Если \verb|user|~--- это локальный словарь,
добавить ему новое поле будет трудно. Функция \verb|var-set| задаёт только новый
словарь, а комбинация \verb|var-set| и \verb|var-get| выглядит неуклюже:

\ifnarrow

\begin{english}
  \begin{clojure}
(with-local-vars [user {:name "Ivan"}]
  ;; won't work
  ;; (var-set user assoc :age 33)
  ;; ugly
  (var-set user (assoc @user :age 33))
  @user)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-local-vars [user {:name "Ivan"}]
  ;; (var-set user assoc :age 33) ;; won't work
  (var-set user (assoc @user :age 33)) ;; ugly
  @user)
  \end{clojure}
\end{english}

\fi

Макрос \verb|with-local-vars| полезен, когда логика опирается на простые типы
(числа, строки). На локальных переменных удобно писать конечные автоматы и
алгоритмы с состоянием. Техника редко встречается в Clojure, но в нужный момент
экономит время и код.

\section{Глобальные изменения в~контексте}

\index{clojure.core!binding}
\index{изменения!глобальные}

\label{with-redefs}

Преимущество \verb|binding| в том, что изменения протекают только в~текущем
потоке. Говорят, что эффект \verb|binding| потокобезопасный, что расценивают
как благо. И всё же бывают случаи, когда изменения должны быть глобальными. Для
этого служит форма \verb|with-redefs|.

Её синтаксис похож на \verb|binding|: вектор связывания и произвольный
код. Эффект \verb|with-redefs| действует \emph{на все} потоки. Представим
веб-сервер, который отвечает на запросы параллельно. Если одна из страниц
выполняет логику в \verb|with-redefs|, это повлияет на соседние
запросы. По аналогии с \verb|binding| и \verb|let|, изменения откатываются при
выходе из макроса.

Пример ниже объясняет принципы \texttt{with\-/redefs}. Мы подменяем функцию
\verb|println| на суррогат, который печатает постоянный текст. Если обратиться к
\verb|println| внутри макроса, увидим на экране fake print независимо от того,
какие аргументы передали в функцию.

\begin{english}
  \begin{clojure}
(with-redefs [println
              (fn [& _]
                (print "fake print\n"))]
  (println {:some "data"}))
;; fake print
  \end{clojure}
\end{english}

\index{clojure.core!future}
\index{футуры}

Более интересный случай связан с футурой. Футура (или фьючер,
англ.~\emph{future}, <<будущее>>)~--- это посредник между клиентом и
многопоточностью. Футура принимает блок кода и передаёт его исполнителю
(executor). Чаще всего исполнитель занимает несколько тредов (потоков
процессора) и распределяет по ним задачи. Когда задача выполнена, клиент
получает результат <<дерефом>> футуры.

В следующем коде тело футуры \spverb|(println "hello")| сработает в другом
потоке. Оператор \verb|@| перед футурой означает: ждать до тех пор, пока не
придёт результат от исполнителя. Код ниже напечатает <<fake print>>:

\index{clojure.core!constantly}

\ifnarrow

\begin{english}
  \begin{clojure}
(with-redefs
  [println (constantly
             (print "fake print"))]
  @(future (println "hello")))
;; fake print
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-redefs
  [println (constantly (print "fake print\n"))]
  @(future (println "hello")))
;; fake print
  \end{clojure}
\end{english}

\fi

Это произошло потому, что \verb|with-redefs| повлиял в том числе и на тот
поток, в котором исполнитель обработал задачу.

Если убрать оператор \verb|@|, эффект \verb|with-redefs| пропадёт: футура
напечатает <<hello>>. Причина в том, что цикл футуры занимает хоть и малое, но
время. Без оператора \verb|@| мы только запускаем футуру и сразу выходим из
\verb|with-redefs|. Пул доберётся до задачи \verb|(println "hello")|, когда
эффект макроса уже закончится.

Документация \verb|with-redefs| подчёркивает, что макрос полезен в
тестировании. Иногда приложение опирается на сторонние сервисы вроде геопоиска
или графа социальных связей. При тестировании возникает проблема доступа к
сервисам. Приложение не должно обращаться к~ним: это усложняет тесты и делает их
зависимыми.

Идея в том, чтобы на время тестов подменить функции, которые обращаются в
сеть. Рассмотрим на практике, как это сделать.

\subsection{Практика: приложение с~координатами}

\index{HTTP!POST}
\index{координаты}
\index{геолокация}

Мобильное приложение шлёт на сервер координаты устройства~--- долготу и
широту. Позже пользователь изучает историю путешествий. Очевидно, он ожидает не
машинные цифры, а названия мест. Для каждой пары координат нужно найти данные об
этом месте.

Страница \verb|POST /location| принимает координаты в теле запроса. Чтобы узнать
данные о месте, мы обращаемся к стороннему сервису. Из ответа читаем его поля и
пишем в базу вместе с координатами. Возвращаем клиенту ответ 200 OK. Схематично
изобразим HTTP-обработчик этой страницы:

\ifnarrow

\begin{english}
  \begin{clojure}
(defn location-handler [request]
  (let [{:keys [params]} request
        point (select-keys params
                [:lat :lon])
        place (geo/place-info point)]
    (db/create-location
      (merge place point))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn location-handler [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        place (geo/place-info point)]
    (db/create-location (merge place point))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\fi

Функция \verb|geo/place-info| обращается к сетевому сервису. На выходе получим
словарь с ключами \verb|:title|, \verb|:country|, \verb|:image_url| и
другими. Условный код:

\begin{english}
  \begin{clojure}
(defn place-info
  [{:keys [lat lon]}]
  (let [http-opt
        {:headers {:token "..."}
         :query-params {:lat lat
                        :lon lat}}]
    (-> "https://api.maps.com/search"
        (client/get http-opt)
        :body)))
  \end{clojure}
\end{english}

\noindent
и пример работы:

\ifnarrow

\begin{english}
  \begin{clojure}
(place-info {:lat 51.678790
             :lon 39.206855})

{:title "Voronezh"
 :country "Russia"
 ...}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(place-info {:lat 51.678790 :lon 39.206855})

;; {:title "Voronezh" :country "Russia" ...}
  \end{clojure}
\end{english}

\fi

Пока мы ищем данные о точке, мобильное приложение ждёт ответа. С машинной точки
зрения это долго, ведь сеть не гарантирует мгновенный отклик. Чем больше
клиентов шлют координаты, тем больше запросов мы посылаем геосервису. Растёт
число открытых соединений, система замедляется.

\index{clojure.core!future}

Быстрое решение в том, чтобы записать координаты в базу и сразу ответить
клиенту, а сбор данных о месте вынести в футуру. Этим мы сократим ожидание:
теперь приложение ждёт только запись в базу, что быстрее, чем запрос к сторонней
службе.

В новой версии функция \verb|db/create-point| пишет координаты в базу
и~возвращает \verb|id| новой записи. Ключ нужен, чтобы позже обновить запись по
\verb|id| данными о месте. Поиск данных и обновление протекают в~футуре.

\ifnarrow

\begin{english}
  \begin{clojure}
(defn location-handler
  [request]
  (let [{:keys [params]} request
        point (select-keys params
                [:lat :lon])
        row-id (db/create-point point)]
    (future
      (let [place (geo/place-info
                    point)]
        (db/update-place row-id place)))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn location-handler
  [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        row-id (db/create-point point)]
    (future
      (let [place (geo/place-info point)]
        (db/update-place row-id place)))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\fi

Возможны и другие способы решить эту задачу, например очередь сообщений. Но этот
вариант дольше в реализации и вдобавок требует изменений в инфраструктуре, а
футура займёт пару строк. Футура~--- простое и дешёвое решение, которое даст
время на поиск более проработанного.

\subsection{Тесты}

\index{тесты}
\index{clojure.core!with-redefs}

Напишем тест для нового обработчика. Чтобы не порождать сетевых запросов,
временно заменим функцию \verb|geo/place-info|. Для полноты картины проверим,
что случится, если геопоиск бросит исключение.

Каждый тест начинается с выражения \code{with-re\-defs} для замены
\code{geo/\-place-info}. Для краткости напишем макрос
\texttt{with\-/place\-/info}. Он~принимает тело функции и~блок теста:

\begin{english}
  \begin{clojure}
(defmacro with-place-info
  [result & body]
  `(with-redefs [geo/place-info
                 (fn [~'point] ~result)]
     ~@body))
  \end{clojure}
\end{english}

Приведём положительный сценарий. В макросе \texttt{with\-/place\-/info} геопоиск
вернёт заданный словарь. Мы вызываем обработчик и проверяем, что ответ
положительный. Чтобы убедиться, что футура записала данные в базу, мы немного
ждём и~читаем последнюю локацию. В~ней должны быть значения из геопоиска.

\ifnarrow

\begin{english}
  \begin{clojure}
(deftest test-place-ok
  (with-place-info
    {:title "test_title"
     :country "test_country"}
    (let [request {:params
                   {:lat 11.111
                    :lon 22.222}}
          {:keys [status]}
          (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location
            (db/get-last-location)
            {:keys [title country]}
            location]
        (is (= "test_title" title))
        (is (= "test_country"
               country))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-place-ok
  (with-place-info
    {:title "test_title"
     :country "test_country"}
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (= "test_title" title))
        (is (= "test_country" country))))))
  \end{clojure}
\end{english}

\fi

\index{HTTP!429}

Негативный сценарий: пусть геопоиск бросил исключение с кодом 429. Это
возможно, если превышен лимит на число запросов. Объявим исключение:

\ifnarrow

\begin{english}
  \begin{clojure}
(def ex-quota
  (ex-info
    "The limit of requests
               has been reached"
    {:status 429
     :body {:code :QUOTA_REACHED}}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def ex-quota
  (ex-info "The limit of requests has been reached"
           {:status 429 :body {:code :QUOTA_REACHED}}))
  \end{clojure}
\end{english}

\fi

Проверим, что приложение вернёт положительный статус, но в базе нет данных о
месте, потому что запрос геопоискa не прошёл.

\ifnarrow

\begin{english}
  \begin{clojure}
(deftest test-place-quota-reached
 (with-place-info
   (throw ex-quota)
   (let [request {:params {:lat 11.111
                          :lon 22.222}}
        {:keys [status body]}
        (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (is (nil?
            (db/get-last-location))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-place-quota-reached
  (with-place-info
    (throw ex-quota)
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status
                  body]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (is (nil? (db/get-last-location))))))
  \end{clojure}
\end{english}

\fi

С помощью \verb|with-place-info| можно спровоцировать любое исключение. Приём
полезен, когда \verb|catch| ожидает конкретные классы. Следующий тест имитирует
сбой в сети. Если в приложении особая реакция этот случай, тест его
зафиксирует. Правки в коде станут невозможны без изменений в тестах.

\index{тесты!ошибки}

\ifnarrow

\begin{english}
  \begin{clojure}
(deftest test-place-conn-err
  (with-place-info
    (throw (new java.net.ConnectException
             "test_timeout"))
    ...))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-place-conn-err
  (with-place-info
    (throw (new java.net.ConnectException "test_timeout"))
    ...))
  \end{clojure}
\end{english}

\fi

\index{моки}

Подмена функций и классов называется мокинг (англ.~mock~--- <<подделка>>). Мы
подробно рассмотрим тесты в последней главе \page{chapter-tests}. Пока что
заметим, что макрос \verb|with-redefs|~--- это простой способ что-то <<замокать>>,
то есть подменить на время тестов.

\subsection{Коротко о with-redefs-fn}

\index{clojure.core!with-redefs-fn}

Макрос \verb|with-redefs| опирается на функцию \verb|with-redefs-fn|. Отличие
в~синтаксисе: она принимает словарь и функцию без аргументов. Ключи словаря~---
объекты \verb|Var|. Функция сработает в момент, когда переменные получили новые
значения.

Перепишем пример с \verb|geo/place-info| на \texttt{with\-/redefs\-/fn}. Напомним, что
запись \verb|#'|\texttt{something} означает \verb|(var something)|:

\ifnarrow

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point]
                      {:title "test"})}
  (fn []
    (geo/place-info {:lat 1 :lon 2})))

;; {:title "test"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  (fn []
    (geo/place-info {:lat 1 :lon 2})))

;; {:title "test"}
  \end{clojure}
\end{english}

\fi

\index{синтаксис!\texttt{\#} (решётка)}

Важно, что \verb|with-redefs-fn|~--- это именно функция, поэтому она не может
принять произвольный код, как это делают макросы. Чтобы передать код, его
оборачивают в функцию без аргументов. Если код~--- одна большая форма
(\verb|let| или \verb|do|), необязательно заключать её в
\verb|(fn [])|. Поставьте спереди знак \verb|#|, чтобы превратить форму в
анонимную функцию.

\ifnarrow

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point]
                      {:title "test"})}
  #(let [point {:lat 1 :lon 2}
         place (geo/place-info point)]
     ...))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  #(let [point {:lat 1 :lon 2}
         place (geo/place-info point)]
     ...))
  \end{clojure}
\end{english}

\fi

Функция \verb|with-redefs-fn| выглядит непривычно из-за словаря и~символов
\verb|#'|. Она не похожа на \verb|let|, \verb|binding| и другие формы
связывания в Clojure. Макрос \verb|with-redefs| скрывает эти особенности; по
возможности пользуйтесь им.

\section{Заключение}

Clojure предлагает специальные типы для изменяемых данных. В~отличие от
императивных языков, где изменения встроены в синтаксис, в~Clojure пользуются
особыми формами. Язык устроен так, что данные меняют редко. Это продвинутый
уровень, к которому приходят после азов неизменяемости. Перечислим техники,
которые мы рассмотрели, и случаи, когда они полезны.

Атом~--- это обёртка вокруг значения. Чтобы получить содержимое, применяют
оператор \verb|@| или функцию \verb|(deref <atom>)|. Новое значение сообщают
функцией \verb|reset!|. В основном атом изменяют итеративно с~помощью
\verb|swap!|, которая вычисляет новое значение из текущего.

В атомах хранят состояние проекта: счётчики, сессии, локальный кэш для ускорения
расчётов. Атомы подходят на роль переменных в императивном коде. Иногда атом
используют в качестве состояния модуля, например текущего подключения к базе.

Объект \verb|volatile|~--- облегчённый вариант атома. В отличие от него,
\verb|volatile| не поддерживает валидаторы и вотчеры и не управляет доступом из
разных потоков.

Переходные, или транзиентные, коллекции получают из постоянных аналогов. С~ними
работают функции \verb|conj!|, \verb|assoc!| и другие с восклицательным знаком
на конце.  Когда коллекция транзиентна, меняется её содержимое. Функция
\verb|persistent!| запечатывает коллекцию и~возвращает её постоянную копию.

Транзиентные коллекции полезны на больших данных, потому что быстрее
неизменяемых. Работайте с ними из одного потока. Другие части кода не должны
знать о том, что коллекция изменяется. Обмен переходными коллекциями~--- грубая
ошибка.

Функция \verb|alter-var-root| заменяет глобальную переменную. С её помощью можно
вторгнуться в чужое пространство и что-то исправить. К~\verb|alter-var-root|
прибегают, чтобы изменить код, которым не владеют. Другое её применение~---
модули с состоянием, из которых собирается система.

У формы \verb|set!| несколько применений. Одно из них~--- изменять системные
переменные Clojure. Это особые переменные с~<<ушками>>, которые влияют на
поведение системы в целом. \verb|Set!| редко встречается в коде; лучше указать
переменные в настройках проекта.

Макрос \verb|binding| выполняет код в рамках временных изменений. Макрос
связывает динамическую переменную с новым значением. Чтобы переменная была
динамической, ей сообщают флаг \verb|^:dynamic| и выделяют <<ушками>>.

\verb|Binding| действует только в текущем потоке. К нему прибегают, чтобы
участок кода вёл себя по-иному. Например, выводил текст не на экран, а в
файл. Динамические переменные легче спустить по стеку вызовов, как в примере с
локалью. Внутри \verb|binding| форма \verb|set!| работает как обычное
присваивание.

Макрос \verb|with-local-vars| выполняет тело с произвольными переменными. Они
похожи на атом с двумя действиями: прочитать и записать значение. Форма полезна,
когда имеют дело со сложной императивной логикой. При выходе из макроса
переменные исчезают.

Конструкция \verb|with-redefs| временно изменяет
\verb|def|-оп\-ре\-де\-ле\-ния. В~отличие от \verb|binding|, она действует глобально:
все фоновые сущности (футуры, агенты) подхватят
изменения. \verb|With-redefs|~--- это обёртка над низкоуровневой функцией
\texttt{with-redefs-fn}. В~основном ей пользуются в~тестах (<<мокинг>>).
