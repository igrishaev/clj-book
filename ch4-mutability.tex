
\chapter{Изменяемость}

\index{изменяемость}

\begin{teaser}
В классических языках данные меняются, а стандартная библиотека предлагает
ограничения: локи, атомарные действия, постоянные коллекции. В Clojure,
наоборот, данные не меняются, а мутабельные типы задвинуты на второй план. Это
сделано специально, потому что неизменяемость~--- центральная идея языка.
\end{teaser}

Руководства по Clojure учат постоянными коллекциям. Это правильный подход, но
когда появляется состояние, новички испытывают трудности. В этой главе мы займём
другую позицию: рассмотрим, как управлять состоянием в программах.

\section{Общие проблемы}

На Clojure трудно писать в императивном стиле, когда акцент сделан на изменении
данных. Скажем, чтобы получить список удвоенных чисел, выполняют шаги:

\index{итерация}

\begin{itemize}
\item
  создать пустой список~--- будущий результат;
\item
  пройти по элементам исходного списка;
\item
  на каждом шаге вычислить новый элемент;
\item
  добавить его к результату.
\end{itemize}

Базовые типы Clojure не меняются, и к ним нельзя применить алгоритм выше. Те,
кто пришёл из императивных языков, поначалу не могут писать код с
постоянными коллекциями. Привычка менять данные так сильно укрепилась в них, что
иммутабельность кажется физическим ограничением.

Создатель Clojure полагает, что изменяемость~--- основная проблема в разработке
ПО. Когда мы пишем код, то видим его начальное состояние, в котором он будет
первый такт машинного времени. Затем программа инициирует классы, заполнит поля,
и объекты изменятся.

Некоторые ошибки трудно расследовать, потому что код и состояние
расходятся. Чтобы исправить ошибку, её повторяют в локальном окружении. Однако
привести код в конкретное состояние не так просто. Неизменяемые данные отсекают
целый пласт ошибок, от которых страдают императивные языки.

\index{языки!Python}

Рассмотрим примеры на Python. В модуле заданы параметры запроса по
умолчанию. Функция \verb|api_call| принимает дополнительные параметры,
объединяет со стандартными и передаёт в HTTP-клиент:

\ifx\devicetype\mobile

\begin{english}
  \begin{python/lines}
DEFAULT_PARAMS = {
    "allow_redirects": True,
    "timeout": 5,
    "headers": {"Content-Type":
                "application/json"},
    "auth": ("username", "password"),
}

def api_call(**params):
    api_params = DEFAULT_PARAMS
    api_params.update(params)
    url = "https://api.host.com"
    response = \
      requests.post(url, **api_params)
    return response.json()
  \end{python/lines}
\end{english}

\else

\begin{english}
  \begin{python/lines}
DEFAULT_PARAMS = {
    "allow_redirects": True,
    "timeout": 5,
    "headers": {"Content-Type": "application/json"},
    "auth": ("username", "password"),
}

def api_call(**params):
    api_params = DEFAULT_PARAMS
    api_params.update(params)
    resp = requests.post("https://api.host.com", **api_params)
    return resp.json()
  \end{python/lines}
\end{english}

\fi

\index{передача по ссылке}

В теле \verb|api_call| грубая ошибка: переменная \verb|api_params| получает
не копию глобальных параметров, а \emph{ссылку} на них \ifx\devicetype\mobile\coderef{10}\else\coderef{9}\fi. Изменяя
\verb|api_params|, мы на самом деле меняем \verb|DEFAULT_PARAMS|
\ifx\devicetype\mobile\coderef{11}\else\coderef{10}\fi. На каждый вызов глобальные параметры меняются, что ведёт к
странному поведению программы. Код и состояние <<разъехались>>.

На собеседованиях часто задают следующий вопрос. Представьте функцию с
сигнатурой ниже. Объясните, что в ней не так, и приведите пример ошибки.

\begin{english}
  \begin{python}
def foo(bar=[]):
  \end{python}
\end{english}

Ответ: параметры функции по умолчанию создаются однажды. В~данном случае
\verb|bar| равен пустому списку. В Python список изменяется. Если в
\verb|bar| ничего не передали, получим исходный список. Добавим в~него
элемент, и в следующий раз \verb|bar| будет уже не пустой:

\begin{english}
  \begin{python}
def foo(bar=[]):
    bar.append(1)
    return bar
  \end{python}
\end{english}

Вызов \verb|foo| вернёт списки \verb|[1]|, \verb|[1, 1]| и так
далее. Ещё хуже: если результат \verb|foo| сохранить в переменную и позже
добавить к нему элемент, на самом деле изменится злосчастный \verb|bar|.

Современные IDE проверяют код на неявные ошибки. Про список в~сигнатуре знают
все анализаторы и линтеры. Но мы не можем целиком положиться на утилиты: если
данные меняются постоянно, трудно понять, где ошибка, а где умысел.

Начинающих кложуристов выдаёт код:

\begin{english}
  \begin{clojure}
(let [result (atom [])
      data [1 2 3 4 5]]
  (doseq [item data]
    (let [new-item (* 2 item)]
      (swap! result conj new-item)))
  @result)
  \end{clojure}
\end{english}

\index{императивный стиль}

\noindent
Это привычка из императивного прошлого. Атом-аккумулятор лишний, достаточно
\verb|map| или \verb|for|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(map (partial * 2)
     [1 2 3 4 5])
  \end{clojure}

\splitter

  \begin{clojure}
(for [n [1 2 3 4 5]]
  (* n 2))
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
(map (partial * 2)
     [1 2 3 4 5])
  \end{clojure}

&

  \begin{clojure}
(for [n [1 2 3 4 5]]
  (* n 2))
  \end{clojure}

\end{tabular}

\end{english}

\fi

Оба выражения короче и понятней. Не нужно создавать вектор и добавлять в него
элементы~--- это делают функции. Если обход коллекции завязан на
атоме, скорее всего это слабое решение.

Авторы Clojure сделали всё, чтобы выделить состояние на общем фоне. К
состоянию прибегают только в крайних случаях. Если вы написали код на атомах без
уважительной причины, вам сделают замечание или не примут работу.

\index{состояние}

\subsection{В защиту состояния}

Мы говорили, что состояние несёт потенциальные ошибки. Это слишком линейное
заявление: без состояния работают только небольшие программы. Например, скрипты,
которые запускают раз в день. Писать промышленный код без состояния невозможно.

\index{ресурсы}

Постоянные данные избавляют нас от ошибок с перезаписью полей. Это значимый
выигрыш, но кроме данных приложение полагается на \emph{ресурсы}. Для них
действует правило: дешевле работать с открытым ресурсом, чем постоянно открывать
и закрывать его. Состояние повышает скорость программы.

\index{веб-разработка}
\index{протоколы!CGI}

Много лет назад веб-серверы работали по протоколу CGI,
\footurl{Common Gateway Interface}{https://en.wikipedia.org/wiki/Common\_Gateway\_Interface}[CGI].
На каждый запрос сервер запускал скрипт или бинарный файл. Скрипт получал данные
запроса из переменных среды. Программа писала ответ в стандартный поток. Сервер
перехватывал его и выводил пользователю.

Схема была простой и удобной. Приложение могло быть скриптом на Perl или
программой на C\Plus\Plus. У сервера не было состояния. В любой момент
разработчик обновлял файл, и изменения вступали в силу немедленно.

За преимущества платили низкой скоростью. Каждый запрос к~серверу порождал новый
процесс. Даже если программа написана на Си, запуск процесса занимает
время. Индустрия пришла к тому, что приложение должно работать постоянно, а не
по запросу.

\index{протоколы!FastCGI}

Приложение на FastCGI устроено как самостоятельный сервер. Его
производительность на два порядка выше, чем у CGI. В нём появилось
состояние~--- открытый порт и цикл ввода-вывода. Цикл читает запрос и~делегирует
отдельному потоку. Это усложнило разработку, что привело к новым парадигмам
и фреймворкам.

Похоже устроены соединения с базой данных. Представим, что на каждый запрос мы
открываем соединение, работаем с ним и закрываем. В машинном мире открыть
TCP-соединение~--- это долгая операция. Так появились пулы соединений.

\index{пул соединений}

Пул~--- это объект, который держит несколько открытых соединений. Пул знает, какое
из них занято или свободно. Чтобы работать с~базой, мы занимаем одно из
свободных соединений, работаем с ним и возвращаем. Для потребителя пул~--- это
примитивный объект, который выдаёт и забирает соединения.

Логика пула довольно сложна. Если соединений не хватает, он увеличивает свою
ёмкость, а при избытке сокращает. Для каждого соединения пул считает время
работы и прочие метрики. Он же решает, когда закрыть соединение и заменить его
новым. Пул работает в~отдельном потоке, чтобы не блокировать основную программу.

Столь сложное устройство компенсирует скорость доступа. Каждый запрос протекает
по заранее открытому соединению, что намного быстрее, чем открывать его каждый
раз.

Сама архитектура машин поощряет изменять данные. В школе нам объясняют память
компьютера как массив ячеек. Запись в ячейку по~адресу дёшева. И в C\Plus\Plus,
и в Python одинаково легко обновить элемент массива:

\begin{english}
  \begin{python}
items[i] = 5;
  \end{python}
\end{english}

Постоянные структуры хуже ложатся на эту модель памяти. Поэтому они сложнее:
неизменяемый список~--- это не цепочка, а дерево узлов с указателем. Постоянные
коллекции умны и копируют данные не полностью, а частично. Всё же на больших
объёмах выгоднее работать с~изменяемыми структурами.

Мы не призываем всюду внедрять состояние. Древовидность и замедление~--- это цена,
которую платят за меньший риск ошибки. Инженер должен знать, на что идёт,
когда добавляет состояние или избавляется от него. По ходу главы мы изучим
императивные возможности Clojure~--- как ими пользоваться и когда это
действительно нужно.

\section{Атомы}

\index{атом}

Clojure предлагает несколько способов менять данные. Самый простой из них~---
атом~--- объект, который прячет в себе другой объект. Атом получают
одноимённой функцией с начальным значением:

\begin{english}
  \begin{clojure}
(def store (atom 42))
  \end{clojure}
\end{english}

Если напечатать атом, увидим следующее:

\begin{english}
  \begin{clojure}
#<Atom@10ed2e87: 42>
  \end{clojure}
\end{english}

Чтобы извлечь значение, применяют оператор \verb|@|. Запись \verb|@store|~---
это укороченный вариант \verb|(deref store)|. Функция \verb|deref| принимает
атом и возвращает содержимое. Семантически это то же самое, что получить
значение по указателю. В русской литературе операцию называют
<<разыменование>>. В разговорном языке про оператор \verb|@| говорят
<<дереф>>, <<дерефнуть>>.

\index{дереф}
\index{разыменование}
\index{синтаксис!@ (дереф)}
\index{clojure.core!deref}

\begin{english}
  \begin{clojure}
@store ;; 42
  \end{clojure}
\end{english}

В отличие от коллекций, атом меняет содержимое и остаётся тем самым
объектом. Это важно: если добавить к словарю ключ, получим новый словарь, при
этом старый не изменится. Если изменить содержимое атома, это будет всё тот
же атом с номером \verb|10ed2e87|.

\index{clojure.core!reset"!}

Наивный способ изменить атом~--- вызвать \verb|reset!|. Функция принимает атом
и новое значение. Оно может быть любого типа, в том числе \verb|nil|,
коллекцией, исключением:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(reset! store nil)
(reset! store {:items [1 2 3]})
(reset! store (ex-info "error"
                {:id 42}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(reset! store nil)
(reset! store {:items [1 2 3]})
(reset! store (ex-info "error" {:id 42}))
  \end{clojure}
\end{english}
\fi


Если выполнить \verb|@store| после каждого выражения, получим то, что передали
в \verb|reset!|. Последний случай не бросит исключение, потому что нет
оператора \verb|throw|.

\subsection{Приращение атома}

\index{счётчики}
\index{атом!приращение}

Мы назвали \verb|reset!| наивным, потому что функция не учитывает текущего
значения атома. На практике атом изменяют, отталкиваясь от содержимого. Если это
счётчик, неважно, какое значение в нём сейчас. Атому посылают команду <<прибавь
единицу>>. Для вектора сообщение выглядит как <<добавь элемент>>, для
словаря~--- <<удали ключ>> и так далее.

Значение атома уходит на второй план; нас интересует \emph{действие}. Чтобы
обновить атом с учётом состояния, ему посылают функцию. Она принимает текущее
значение и возвращает новое, которое заменит содержимое. В функцию
\verb|swap!| передают атом и функцию для расчёта нового значения:

\index{clojure.core!swap"!}

\begin{english}
  \begin{clojure}
(def counter (atom 0))
(swap! counter inc) ;; 1
  \end{clojure}
\end{english}

\noindent
Если повторять вызов \verb|swap!|, значение \verb|counter| каждый раз
будет увеличиваться на единицу.

\verb|Swap!| принимает дополнительные параметры для расчёта. Предположим, мы
хотим увеличить счётчик сразу на три позиции или отмотать назад. Вместо
\verb|inc| возьмём сложение и вычитание, функции \verb|+| и \verb|-|. Их
первым аргументом станет текущее значение атома, а второй аргумент передают в
\verb|swap!|:

\begin{english}
  \begin{clojure}
(swap! counter + 3) ;; increase by 3
(swap! counter - 2) ;; decrease by 2
  \end{clojure}
\end{english}

Атом вычислит новое значение по правилу:

\begin{english}
  \begin{clojure}
(+ <current> 3)
(- <current> 2),
  \end{clojure}
\end{english}

\noindent
где \verb|<current>|~--- текущее значение.

Это был частный случай \verb|swap!| с одним аргументом. В общем случае функция
принимает их произвольное количество:

\begin{english}
  \begin{clojure}
(swap! <atom> func arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

\noindent
Новое значение находят формой:

\begin{english}
  \begin{clojure}
(func <current> arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

До сих пор мы хранили в атомах счётчики. На практике редко считают одну
сущность. Гораздо чаще счётчики ведут в разрезе чего-то. Например, просмотры
страниц по адресам, число сообщений у~пользователя и так далее.

Чтобы не создавать по атому на каждую сущность, их объединяют в
словарь. Рассмотрим подсчёт системных ресурсов. Ключи словаря означают тип
ресурса, значения~--- степень потребления в байтах или процентах.

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))
  \end{clojure}
\end{english}

Отдельная функция вычисляет потребление диска. Чтобы записать новое значение в
атом по ключу \verb|:store|, вызовем \verb|swap!| следующим образом:

\begin{english}
  \begin{clojure}
(defn get-disk-usage []
  (rand-int 99999999))

(let [store (get-disk-usage)]
  (swap! usage assoc :store store))
  \end{clojure}
\end{english}

Эта форма перепишет значение в поле \verb|:store| на новое. Возможен и~другой
подход, когда мы не считаем всё занятое место на диске, а~фиксируем разницу на
каждое изменение. Скажем, если пользователь создал или удалил файл, мы читаем
событие и обновляем \verb|:store| с~приращением.

\ifx\devicetype\mobile
\noindent
\else
\fi
Функция \verb|get-file-event| каким-то образом вернёт событие файловой
системы. Это словарь с ключами \verb|:action| и \verb|:size|. В зависимости
от \verb|:action| мы наращиваем или уменьшаем потребление диска. Наша версия
\verb|get-file-event|~--- это заглушка, которая случайно вернёт одно из двух
событий:

\begin{english}
  \begin{clojure}
(defn get-file-event []
  (rand-nth
   [{:action :delete
     :path "/path/to/deleted/file.txt"
     :size 563467}
    {:action :create
     :path "/path/to/new/photo.jpg"
     :size 7345626}]))
  \end{clojure}
\end{english}

\noindent
Пересчёт потребления диска изменится:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [{:keys [action size]}
      (get-file-event)]
  (case action
    :delete
    (swap! usage update :store - size)
    :create
    (swap! usage update :store + size)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [{:keys [action size]} (get-file-event)]
  (case action
    :delete
    (swap! usage update :store - size)
    :create
    (swap! usage update :store + size)))
  \end{clojure}
\end{english}

\fi

\index{файлы}

Так считают ресурсы в облачных платформах. Обращение к диску~--- это дорогая
операция: нельзя пробежаться по дереву папок и найти объём. Иногда файлы
одного клиента лежат на разных дисках и~серверах. Поэтому ресурсы считают
итеративно и раз в интервал сверяют цифры.

\index{PID}
\index{процессы}

Усложним пример с ресурсами: теперь их считают в разрезе пользователей. Ключи
верхнего уровня означают номер пользователя, а~значения~--- словари
ресурсов. Для каждого пользователя ведём список его процессов, множество
идентификаторов \footurl{\texttt{PID}}{https://en.wikipedia.org/wiki/Process\_identifier}[PID][-9mm]
\coderef{5}.

\ifx\devicetype\mobile
\begin{english}
  \begin{clojure/lines}
(def usage-all
  (atom {1005 {:cpu 35
               :store 63466734
               :memory 10442856
               :pids #{6266 5426
                       6542}}}))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(def usage-all
  (atom {1005 {:cpu 35
               :store 63466734
               :memory 10442856
               :pids #{6266, 5426, 6542}}}))
  \end{clojure/lines}
\end{english}
\fi


Чтобы добавить процесс пользователю 1005, выполним \verb|swap!|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(swap! usage-all
  update-in [1005 :pids] conj 9999)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] conj 9999)
  \end{clojure}
\end{english}

\fi

Это сложная комбинация: в \verb|swap!| передали функцию, которая принимает
функцию. Разберём по шагам, что произошло.

\begin{itemize}

\item
  Получим множество старых процессов \verb|<pids>|:\\
  \verb|(get-in <current> [1005 :pids])|.

\item
  Добавим к нему новый процесс: \spverb|(conj <pids> 9999)|.\\
  Обозначим новое множество \verb|<pids*>|.

\item
  Обновим \verb|<current>| этим множеством по пути 1005 \arr{} \verb|:pids|:\\
  \ifx\devicetype\mobile
    \verb|(assoc-in <current>|\\
    \verb|  [1005 :pids] <pids*>)|.
  \else
    \verb|(assoc-in <current> [1005 :pids] <pids*>)|.
  \fi

\end{itemize}

\noindent
Чтобы удалить процесс, замените \verb|conj| на \verb|disj|. Это обратная
функция, которая удаляет элемент из множества.

\index{clojure.core!get-in}
\index{clojure.core!update-in}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(swap! usage-all
  update-in [1005 :pids] disj 9999)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] disj 9999)
  \end{clojure}
\end{english}

\fi

Функция \verb|reset!| нужна, чтобы сбросить атом в исходное состояние. В
других случаях важно знать текущее значение, чтобы вычислить новое. Поэтому
\verb|swap!| мощнее и гибче \verb|reset!|.

\subsection{Совместный доступ}

\index{чистые функции}
\index{атом!перезапуск}

Функция, которую передают в \verb|swap!|, должна быть без побочных эффектов. В
терминах функционального программирования её бы назвали \emph{чистой функцией}.
Она не должна обращаться к базе данных, файлам, выводу на экран. Технически
это возможно, но вы столкнётесь со странным поведением атома. Дело в том,
что иногда функция срабатывает \emph{несколько} раз за один \verb|swap!|.
Причина кроется в способе, которым атом обновляет содержимое.

Предположим, ресурсы считают в нескольких потоках: один слушает события файловой
системы, второй следит за памятью. Возникает проблема совместного
доступа. Возможна ситуация, когда два потока обновляют одни и те же
данные. Первый поток справился быстрее и~записал в атом свою версию
данных. Второй поток рассчитал другой вариант. Если он изменит атом, эффект
первого аннулируется.

\index{терминал}

Это классическая задача про терминал и семейную пару. Муж и~жена вносят наличные
на общий пустой счёт. Жена вносит 100 рублей, терминал прибавляет эту сумму к
нулю и записывает в базу. Муж вносит 50 рублей, терминал делает то же
самое. Итого на счёте 50 рублей, а 100 пропали.

Атом не допустит такого поведения. Он запоминает начальное значение в~момент
вычисления нового. Перед тем как обновить содержимое, атом проверяет, что
текущее значение совпадает с начальным. Если они не равны, атом обновили из
другого потока.

В этом случае атом повторяет цикл. Текущее становится начальным, и от него
вычисляют новое значение. Атом ещё раз сравнивает текущее и начальное
значения. Цикл повторяется до тех пор, пока они не будут равны. Это значит, что за время
вычислений атом не обновили. Атом меняет текущее значение на новое и выходит из
цикла.

Покажем сказанное на примере. Возьмем атом со словарём:

\begin{english}
  \begin{clojure}
(def sample (atom {:number 0}))
  \end{clojure}
\end{english}

Понадобится функция \emph{медленного} сложения. Она принимает текущее значение,
приращение и время простоя. Для ясности добавим вывод в консоль.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn +slow
  [num delta timeout]
  (println
    (format "Current: %s, timeout: %s"
      num timeout))
  (Thread/sleep timeout)
  (+ num delta))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn +slow
  [num delta timeout]
  (println (format "Current: %s, timeout: %s" num timeout))
  (Thread/sleep timeout)
  (+ num delta))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!future}
\index{футуры}

Обновим атом одновременно из двух потоков. Для этого вызовем \verb|swap!| в
футуре. В первой ждём две секунды, во второй~--- пять:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(do (future (swap! sample update
              :number +slow 1 2000))
    (future (swap! sample update
              :number +slow 2 5000)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(do (future (swap! sample update :number +slow 1 2000))
    (future (swap! sample update :number +slow 2 5000)))
  \end{clojure}
\end{english}

\fi

\noindent
Проверим атом:

\begin{english}
  \begin{clojure}
@sample ;; {:number 3}
  \end{clojure}
\end{english}

\noindent
Это правильное значение: $0 + 1 + 2 = 3$. Вывод консоли:

\begin{english}
  \begin{text}
Current: 0, timeout: 2000 ;; 1
Current: 0, timeout: 5000 ;; 2
Current: 1, timeout: 5000 ;; 2
  \end{text}
\end{english}

Вторая функция сработала два раза, что и следует из алгоритма. Второй
\verb|swap!| начал расчёты с начальным значением \verb|{:number 0}|, а
к~завершению оно стало \verb|{:number 1}|~--- его записал первый
\verb|swap!|. Чтобы избежать ошибки, атом запустил второй \verb|swap!| ещё раз
относительно \verb|{:number 1}|.

Когда атом меняют из нескольких потоков, перезапуск может случиться больше двух
раз. Это недопустимо для функций, которые зависят от окружения.

\subsection{Валидаторы и вотчеры}

\index{атом!валидация}
\index{валидация!в атоме}

Поведение атомов расширяют валидаторы и вотчеры (англ.~watcher~--- <<наблюдатель>>).
Валидаторы означают функции проверки. Они принимают новое значение
\emph{до того}, как оно записано в текущее. Если валидатор вернул ложь, вызов
\verb|swap!| обернётся ошибкой.

\index{clojure.core!set-validator"!}

Функция \verb|set-validator!| добавляет валидатор к атому. Для счётчика
предположим, что он не может быть отрицательным. Попытка понизить его при нуле
вызовет исключение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def counter (atom 2))
(set-validator!
  counter (complement neg?))
;;repeat 3 times...
(swap! counter dec)
;; Execution error IllegalStateException
;; Invalid reference state
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def counter (atom 2))
(set-validator! counter (complement neg?))
(swap! counter dec) ;; repeat 3 times...
;; Execution error (IllegalStateException)
;; Invalid reference state
  \end{clojure}
\end{english}

\fi

Вотчеры~--- это побочные эффекты атома. Они срабатывают \emph{после того}, как атом
перешёл в новое состояние. Вотчер задают уникальным ключом и функцией. Она
принимает четыре аргумента: ключ, атом, старое и новое значения. Одному атому
можно назначить несколько вотчеров.

Разберёмся, когда полезны вотчеры. Вспомним подсчёт ресурсов: система получает
события и обновляет атом. Если потребление диска превысило лимит, мы не можем
бросить исключение. В этом нет смысла, потому что события поступают из внешней
системы. Исключение на нашей стороне не остановит поток событий.

\index{атом!вотчер}

Правильно задать \emph{реакцию} на превышение лимита. Например, уведомить
пользователя письмом, что ресурс исчерпан. Или отправить запрос в подсистему,
которая отвечает за доступ. Для этого и нужен вотчер: он связывает изменение
атома и реакцию на него.

\index{логирование!в атоме}

Если потребление вышло за лимит, запишем в лог сообщение. Объявим функцию
вотчера \verb|store-watcher|. Заметим, что из четырёх параметров нам нужен
только последний~--- \verb|value|. Это новое значение атома. В боевом коде мы бы
назначили первым трём символ подчёркивания. Оно затеняет лишние переменные и
поэтому работает быстрее. Однако мы оставили понятные имена, чтобы передать
семантику.

\index{синтаксис!\textbf{\_} (затенение)}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def STORE_LIMIT (* 1024 1024 1024 25))
;; 25 Gb

(defn store-watcher
  [_key _atom _old value]
  (let [{:keys [store]} value]
    (when (> store STORE_LIMIT)
      (log/errorf
        "Disk usage %s has
                   reached the limit %s"
        store STORE_LIMIT))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def STORE_LIMIT (* 1024 1024 1024 25)) ;; 25 Gb

(defn store-watcher
  [_key _atom _old value]
  (let [{:keys [store]} value]
    (when (> store STORE_LIMIT)
      (log/errorf "Disk usage %s has reached the limit %s"
                  store STORE_LIMIT))))
  \end{clojure}
\end{english}

\fi

\ifx\devicetype\mobile
\noindent
\else
\fi
Добавим атому вотчер с ключом \verb|:watch-store|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))

(add-watch usage
  :watch-store store-watcher)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))

(add-watch usage :watch-store store-watcher)
  \end{clojure}
\end{english}

\fi

\noindent
Если потребление диска превысит лимит, увидим запись в лог:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(swap! usage update :store + STORE_LIMIT)
;; Disk usage 26907012334
;; has reached the limit 26843545600
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(swap! usage update :store + STORE_LIMIT)
;; Disk usage 26907012334 has reached the limit 26843545600
  \end{clojure}
\end{english}

\fi

Валидацию и вотчеры рассматривают как пре- и постэффекты. Разница в том, что
первые могут прервать исполнение, а вторые нет. У них разные задачи:
предварительные эффекты проверяют то, что \emph{может случиться}, а
постэффекты~--- то, что \emph{уже случилось}. Поэтому на них реагируют
по-разному.

\subsection{Другие примеры}

\index{мемоизация}
\index{clojure.core!memoize}
\index{декораторы}

На атомы опираются некоторые функции Clojure, например \verb|memoize|. Это
декоратор, который возвращает улучшенную версию функции. Она запоминает
результат относительно аргументов и записывает во внутреннюю таблицу. Если
вызвать функцию с теми же аргументами, получим результат из таблицы без
вычислений.

\begin{listing}[ht!]

\begin{english}
  \begin{clojure}
(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
  \end{clojure}
\end{english}

\caption{Код функции memoize из поставки Clojure}
\label{fig:clj-memoize}

\end{listing}

\index{clojure.core!find}

%%TODO hyp
Роль таблицы играет атом. Функция-результат \verb|memoize| замкнута на атоме,
который виден только ей. Изучите код декоратора
в~листинге~\ref{fig:clj-memoize}. Заметим, что для поиска в~словаре используют
\verb|find| вместо \verb|get|. Разница в том, как функции трактуют пустое
значение. Если по ключу записан \verb|nil|, \verb|get| тоже вернёт \verb|nil|,
и~форма \verb|if-let| выполнит ложную ветку. Функция \verb|find| вернёт пару
\verb|MapEntry|, значение из которой находят при помощи \verb|val|.

Проверим декоратор на функции \verb|+slow|, которую задали выше. Объявим её
\verb|memoize|-версию и замерим вызовы:

\begin{english}
  \begin{clojure}
(def +mem (memoize +slow))

(time (+mem 1 2 2000))
;; Elapsed time: 2004.699832 msecs

(time (+mem 1 2 2000))
;; Elapsed time: 0.078052 msecs
  \end{clojure}
\end{english}

\index{классы!Thread}

Первый вызов долгий, потому что работает \verb|Thread/sleep| в теле
\verb|+slow|. Второй вызов получает результат из атома, что на порядки
быстрее.

\index{счётчики}

Атомы полезны в веб-разработке: это дешёвый способ хранить состояние между
запросами. На атомах легко сделать счётчики просмотров, сессии, кэш. Счётчик
просмотра страниц~--- это комбинация атома и middleware:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def page-counter
  (atom {"/" 0}))

(defn wrap-page-counter
  [handler]
  (fn [request]
    (let [{:keys [uri request-method]}
          request]
      (when (= request-method :get)
        (swap! page-counter
          update uri (fnil inc 0)))
      (handler request))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def page-counter
  (atom {"/" 0}))

(defn wrap-page-counter
  [handler]
  (fn [request]
    (let [{:keys [uri
                  request-method]} request]
      (when (= request-method :get)
        (swap! page-counter update uri (fnil inc 0)))
      (handler request))))
  \end{clojure}
\end{english}

\fi

\index{HTTP!GET}

На каждый GET-запрос мы увеличиваем счётчик для текущего адреса. Обратите
внимание на форму \verb|fnil| в вызове \verb|update|. Она возвращает версию
\verb|inc|, которая не вызовет исключение, если первый аргумент
\verb|nil|. Это возможно, если в словаре ещё нет нужного ключа, и вместо
\verb|nil| функция получит ноль.

\index{форматы!HTML}
\index{библиотеки!Hiccup}

Функция \verb|page-seen| вернёт число просмотров по адресу страницы. Напишем
компонент для подвала сайта, где мелким шрифтом указано, сколько раз смотрели
страницу. Для HTML-разметки подойдут библиотека
\footurl{Hiccup}{https://github.com/weavejester/hiccup}[Hiccup][-10mm] и аналоги.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn component-footer [uri]
  [:div {:class "footer"}
   (let [seen (get @page-counter uri 0)]
     [:p [:small
          "The page has been seen " seen
          " time(s)."]])])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn component-footer [uri]
  [:div {:class "footer"}
   (let [seen (get @page-counter uri 0)]
     [:p [:small "The page has been seen " seen " time(s)."]])])
  \end{clojure}
\end{english}

\fi

\subsection{Замечания к атому}

У решений на атомах есть недостатки. Атомы не связаны с другими экземплярами
программы. Когда приложение занимает несколько нод, каждая хранит свой
счётчик. Если запросы расходятся по ним равномерно, клиент увидит разные
данные. Чтобы избежать странностей, используют сетевые хранилища вроде Redis.

\index{базы данных!Redis}

Атомы непостоянны: если завершить программу, они теряют состояние. С другой
стороны, атом быстрее, чем файловая система или сетевой сервис. Встречаются
гибридные схемы, когда на старте атом читает ресурс и раз в интервал сохраняет в
него изменения.

\section{Volatile}

Атом устроен довольно сложно: он отвечает за параллельный доступ, вызывает
валидацию и следит за изменениями. Иногда эти возможности излишни, и пользуются
его упрощённой версией~--- \verb|volatile|.

\index{clojure.core!volatile}
\index{clojure.core!vreset"!}

Объект \verb|volatile| тоже хранит и изменяет значение. Одноимённая функция
создаёт объект с состоянием. Функции \verb|vreset!| и \verb|vswap!|
аналогичны тем, что мы рассмотрели для атома. Префикс \verb|v| означает, что
они работают с \verb|volatile|.

Пример с ресурсами: на этот раз вместо атома используем другой тип хранилища:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def vusage (volatile! nil))
(vreset! vusage
         {:cpu 35
          :store 63466734
          :memory 10442856})
(vswap! vusage
  update :store + (* 1024 1024 5))
(println
  "Disk usage is" (get @vusage :store))
;; Disk usage is 68709614
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def vusage (volatile! nil))
(vreset! vusage
         {:cpu 35
          :store 63466734
          :memory 10442856})
(vswap! vusage update :store + (* 1024 1024 5))
(println "Disk usage is" (get @vusage :store))
;; Disk usage is 68709614
  \end{clojure}
\end{english}

\fi

\verb|Volatile| отличается от атома тем, что не контролирует запись
из~нескольких потоков. Перепишем пример с футурами:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def vsample (volatile! {:number 0}))
(do (future (vswap! vsample update
              :number +slow 1 2000))
    (future (vswap! vsample update
              :number +slow 2 5000)))
;; Current: 0, timeout: 2000
;; Current: 0, timeout: 5000
@vsample ;; {:number 2}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def vsample (volatile! {:number 0}))
(do (future (vswap! vsample update :number +slow 1 2000))
    (future (vswap! vsample update :number +slow 2 5000)))
;; Current: 0, timeout: 2000
;; Current: 0, timeout: 5000
@vsample ;; {:number 2}
  \end{clojure}
\end{english}

\fi

\index{clojure.core!future}
\index{футуры}

Вывод говорит, что второе действие сработало один раз. Если для атома итог был
3, то с \verb|volatile| получилось 2. Операцию \verb|+1| мы потеряли. Из
этого следует, что \verb|volatile| не подходит для многопоточного кода.

С другой стороны, в этом есть и преимущества. Из-за того, что \verb|volatile|
не ограничивает доступ, изменения протекают быстрее. По той же причине он не
поддерживает валидаторы и вотчеры. В целом \verb|volatile| нацелен на
скорость.

\subsection{Применение}

У \verb|volatile| две области применения~--- трансдьюсеры и императивный
код. Трансдьюсеры~--- это особый способ работы с коллекцией. Они оборачивают функции
\verb|map|, \verb|reduce| и другие таким образом, что их комбинация не
порождает промежуточных списков. Это возможно за счёт внутреннего состояния. Для
трансдьюсера важна скорость записи, поэтому \verb|volatile| подходит на роль
состояния лучше, чем атом.

\verb|Volatile| полезен, когда пишут императивный код. Относитесь к~нему
спокойно: иногда бизнес-требования слишком сложны, чтобы накладывать их на
функциональный стиль.

Представим, что нужно получить плоский список из дерева. Алгоритм обхода
сложный: если в первой ветке одно значение, то рассматривать вторую, а иначе~---
третью. Когда для первой и третьей веток выполняется некое условие, добавить в
список произведение значений.

\index{императивный стиль}

Требования насквозь императивны, и выгодно задать их таким же образом. Так мы
сделаем код ближе к бизнес-логике и облегчим поддержку. Малая часть дерева:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def data
  {:items [{:result {:value 74}}
           {:result {:value 65}}]
   :records [{:usage 99
              :date "2018-09-09"}
             {:usage 52
              :date "2018-11-05"}]})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def data
  {:items [{:result {:value 74}}
           {:result {:value 65}}]
   :records [{:usage 99 :date "2018-09-09"}
             {:usage 52 :date "2018-11-05"}]})
  \end{clojure}
\end{english}

\fi

Код разбивают на блоки, где каждый из них~--- это каскад \verb|when-let|. На
нижнем уровне мы изменяем коллекцию. Императивный стиль в данном случае удобен:
если одно из правил станет лишним, блок удаляют. Полезно ставить над блоком
комментарий или ссылку на документацию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [result (volatile! [])]

  ;; see section 5.4 from the doc
  (when-let [a (some-> data
                       :items
                       first
                       :result
                       :value)]
    (when-let [b (some-> data
                       :records
                       last
                       :usage)]
      (when (> a b)
        (vswap! result conj (* a b)))))

  ;; more blocks...
  @result)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [result (volatile! [])]

  ;; see section 5.4 from the doc
  (when-let [a (some-> data :items first :result :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (vswap! result conj (* a b)))))

  ;; more blocks...
  @result)
  \end{clojure}
\end{english}

\fi

\section{Переходные коллекции}

\index{коллекции!транзиентные}
\index{clojure.core!transient}

С помощью атома мы создали подобие изменяемых коллекций. Познакомьтесь с новой
техникой: Clojure предлагает \emph{настоящие} изменяемые коллекции. По-другому
они называются \verb|transient| (англ.~временный, переходный).

Изменяемые коллекции получают из постоянных аналогов. С ними работают лишь
несколько функций, буквально добавить и удалить элемент. Стандартные
\verb|map|, \verb|filter| и другие функции не поддерживают
\verb|transient|-коллекции. Происходит своего рода обмен: мы теряем мощь
стандартной библиотеки, но обретаем скорость и императивный подход.

Транзиентные коллекции быстрее постоянных. Изменить ячейку памяти проще, чем
выделить новую и сдвинуть часть данных. Коллекция не должна пребывать в режиме
\verb|transient| всё время. Когда алгоритм закончил работу, её
замораживают и получают неизменяемую версию обратно.

\subsection{Примеры}

Функция \verb|transient| порождает переходную коллекцию из исходной. Для
работы с ней используют функции \verb|conj!|, \verb|assoc!|,
\verb|dissoc!| и другие. Восклицательный знак на конце предупреждает об
изменении данных. Функции меняют \emph{содержимое} коллекции, а не возвращают
новую копию, как это делают обычные \verb|conj| и \verb|assoc|.

\index{clojure.core!persistent"!}

Функция \verb|persistent!| завершает работу с переходной коллекцией. Она
возвращает постоянную версию и одновременно <<запечатывает>> оригинал. После
\verb|persistent!| коллекцию уже нельзя изменить.

Рассмотрим переходный вектор. На него действуют функции \verb|conj!| и
\verb|pop!|, добавить и убрать элемент из хвоста:

\begin{english}
  \begin{clojure}
(let [items* (transient [1 2 3])]
  (conj! items* :a)
  (conj! items* :b)
  (pop! items*)
  (persistent! items*))
;; [1 2 3 :a]
  \end{clojure}
\end{english}

\index{clojure.core!assoc"!}
\index{clojure.core!dissoc"!}

\noindent
Вариант со словарём, \verb|assoc!| и \verb|dissoc!|:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (assoc! params* :c 3)
  (dissoc! params* :b)
  (persistent! params*))
;; {:a 1, :c 3}
  \end{clojure}
\end{english}

Примечание: в примерах выше мы обозначили переменную звёздочкой. Это не нарушает
синтаксис Clojure. В отличие от других языков, в имени переменной могут быть не
совсем привычные символы: дефис, штрих, знак вопроса. Особые переменные выделяют
штрихом или звёздочкой. Переходные коллекции встречаются редко, поэтому подходят
на роль особых.

После \verb|persistent!| коллекцию нельзя изменить. Следующий пример бросит
исключение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (persistent! params*)
  (assoc! params* :c 3))
;; IllegalAccessError:
;; Transient used after persistent! call
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (persistent! params*)
  (assoc! params* :c 3))
;; IllegalAccessError: Transient used after persistent! call
  \end{clojure}
\end{english}

\fi

Форма \verb|(persistent! <data*>)|, как правило, замыкает блок с~изменяемой
переменной. Переходные коллекции помогают там, где нужен императивный
подход. Выше мы работали с деревом и \verb|volatile| для сбора данных. Перепишем
код на транзиентный вектор:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(let [result* (transient [])
      push! (fn [item]
              (conj! result* item))]

  ;; see section 5.4 from the doc:
  ;; http://...
  (when-let [a (some-> data
                       :items
                       first
                       :result
                       :value)]
    (when-let [b (some-> data
                       :records
                       last
                       :usage)]
      (when (> a b)
        (push! (* a b)))))

  ;; more blocks...
  (persistent! result*))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(let [result* (transient [])
      push! (fn [item]
              (conj! result* item))]

  ;; see section 5.4 from the doc: http://...
  (when-let [a (some-> data :items first :result :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (push! (* a b)))))

  ;; more blocks...
  (persistent! result*))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!conj"!}

Чтобы не писать каждый раз \clojureinline{(conj! result* item)}, мы вводим
локальную функцию \verb|push!|. Она замкнута на \verb|result*| и принимает
только значение. Чтобы добавить элемент, достаточно вызвать
\verb|(push! x)|. Это сокращает код и скрывает способ, которым накапливают
данные.

\subsection{Итерация с изменением}

\index{итерация}

Мы говорили, что переходные коллекции быстрее постоянных. Это заметно на долгих
итерациях через \verb|loop/recur|. Как правило, одна из переменных
\verb|loop|~--- это коллекция-результат. В каждом \verb|recur| мы передаем её
копию, дополненную через \verb|conj| или \verb|assoc|.

Когда итераций много, прибегают к уловке: вместо постоянной коллекции передают
транзиентный вариант. Этим код ускоряют в 2--4 раза. Изменения в коде малы,
нужно лишь учесть следующее:

\begin{itemize}

\item
  изменить тип коллекции на \spverb|(transient <coll>)|;

\item
  вместо \verb|conj| или \verb|assoc| вызывать их аналоги \verb|conj!|
  и~\verb|assoc!|;

\item
  в конце вернуть постоянную коллекцию через \verb|persistent!|.

\end{itemize}

Для экспериментов объявим переменную \verb|nums|, список из миллиона целых
чисел:

\begin{english}
  \begin{clojure}
(def nums (range 999999))
  \end{clojure}
\end{english}

\index{clojure.core!loop}
\index{итерация!loop}

\noindent
Построим второй список обычным \verb|loop|:

\begin{english}
  \begin{clojure}
(loop [result []
       [n & nums] nums]
  (if n
    (recur (conj result n) nums)
    result))
  \end{clojure}
\end{english}

\noindent
То же самое с изменяемым вектором:

\begin{english}
  \begin{clojure}
(loop [result* (transient [])
       [n & nums] nums]
  (if n
    (recur (conj! result* n) nums)
    (persistent! result*)))
  \end{clojure}
\end{english}

Число строк осталось прежним, изменилось имя переменной и некоторые
детали. Правки не выходят за пределы \verb|loop|, что даёт свободу
действий. На ранних стадиях код пишут без изменяемых коллекций. Если скорость
критична, цикл улучшают так, что данные меняются.

Макрос \verb|time| принимает блок кода и печатает затраченное время. Если
обернуть в \verb|time| оба примера, получим результаты:

\begin{english}
  \begin{text}
;; 166.688721 msecs (persistent)
;;  69.415038 msecs (transient)
  \end{text}
\end{english}

Точные цифры зависят от оборудования и среды, но разница в~несколько раз
остаётся. Транзиентные коллекции действительно быстрее постоянных аналогов.

\index{clojure.core!reduce}
\index{свёртка}

Ускорение работает и для \verb|reduce|. В других языках функция называется
\verb|fold| или <<свёртка>>. Центральная точка \verb|reduce|~---
аккумулятор результата. Им может быть любой тип, в том числе число или строка
для сложения и конкатенации. Однако чаще всего это список и словарь.

Различают два способа начать свёртку. В первом аккумулятор~--- это начальный
элемент коллекции. Для списка \verb|(1, 2, 3)| и сложения им станет
единица. Во втором способе аккумулятор задают отдельно, например пустым вектором, куда в
будущем запишут данные.

Идея в том, чтобы сделать аккумулятор транзиентной коллекцией. На каждом шаге
\verb|reduce| меняет её функциями \verb|conj!| и~аналогами. Сравним
обычный \verb|reduce| и его мутабельную версию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(reduce
 (fn [result n]
   (conj result n))
 []
 nums)
  \end{clojure}

\splitter

  \begin{clojure}
(persistent!
 (reduce
  (fn [result* n]
    (conj! result* n))
  (transient [])
  nums))
  \end{clojure}
\end{english}

\else

\begin{english}
\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\linegap

  \begin{clojure}
(reduce
 (fn [result n]
   (conj result n))
 []
 nums)
  \end{clojure}

&

  \begin{clojure}
(persistent!
 (reduce
  (fn [result* n]
    (conj! result* n))
  (transient [])
  nums))
  \end{clojure}

\end{tabular}

\end{english}

\fi

\ifx\devicetype\mobile
\noindent
\else
\fi
Второй \verb|reduce| пришлось обернуть в \verb|persistent!|. В случае с
\verb|loop| мы втянули \verb|persistent!| внутрь и изолировали изменения. В
этом плане \verb|reduce| не такой гибкий: внутри анонимной функции мы не
знаем, достигли конца итерации или нет. Без \verb|persistent!| второй пример
вернёт транзиентную коллекцию, что недопустимо.

\subsection{Семантика и ограничения}

Изменяемые данные~--- это продвинутая техника, которая требует внимания. Как только
вы отказались от постоянных коллекций, контроль за изменениями ложится на вас.

Выигрыш в скорости ещё не значит, что их применяют на каждом шагу. Худшее, что
может сделать разработчик,~--- написать код, где функции обмениваются такими
коллекциями. Если это ваш случай, задумайтесь, почему автор языка уделил так
много внимания неизменяемости. Будет ошибкой игнорировать его идеи.

\index{люди!Дональд Кнут}

Феномен, когда на раннем этапе пытаются выжать скорость, называется
преждевременной оптимизацией. Как заметил Дональд Кнут, это корень всех зол. Во
время оптимизации задавайте себе вопросы. Действительно важно ускорить этот
цикл? Это поможет проекту или вы действуете из любопытства?

Изолируйте транзиентные коллекции в небольших функциях. Тогда переход от
постоянных типов к изменяемым не повлияет на результат. Рефакторинг должен
касаться только функции, а не её потребителей.

Изменяемая коллекция не имеет право быть глобальной. Воздержитесь от определений
\clojureinline{(def users* (transient []))} и~подобных. Вы придёте к~тому, что
\verb|users*| станет буфером обмена между функциями. Предсказать их результат
станет невозможно.

В отличие от атома, транзиентные типы не регулируют обращение из разных
потоков. Следите, чтобы только один поток изменял коллекцию. Не передавайте их в
футуры.

\section{Переменные и alter-var-root}

\index{переменные}
\index{clojure.core!alter-var-root}

\label{alter-var-root}

Атомы и переходные коллекции меняют объект, а не переменную. Это не всегда то,
чего мы ожидаем. Представим, что \verb|size|~--- это атом:

\begin{english}
  \begin{clojure}
(def size (atom 0))
  \end{clojure}
\end{english}

Чтобы изменить его, вызовем \verb|reset!| или \verb|swap!|, как в примерах
выше. Однако \verb|size| останется атомом. То же самое с переходными
коллекциями: легко добавить и удалить элемент, но это будет та же самая
коллекция. Невозможно присвоить ей \verb|nil|.

Иногда переменную нужно изменить: сделать так, чтобы сперва она была
\verb|nil|, затем словарём, затем снова \verb|nil|. Авторы намеренно
усложнили этот сценарий. Менять переменные можно, но нежелательно с точки зрения
языка.

Clojure не поощряет императивный стиль, когда переменную меняют много
раз. Глобальная переменная без уважительной причины~--- признак плохого кода.
Программист должен понимать, зачем она понадобилась и можно ли от неё
избавиться.

\index{monkey patch}

Всё же бывают случаи, когда глобальные переменные полезны. Это \emph{компоненты}
и \emph{monkey patch}. Разберём новые термины.

Проект на Clojure состоит из отдельных компонентов или доменов. Это веб-сервер,
база данных, очередь сообщений. Каждый домен помещают в свой модуль:
\verb|http.clj|, \verb|db.clj| и так далее. В модуле объявляют переменную,
которая хранит состояние компонента. Например, \verb|server| в модуле сервера и
\verb|conn| в модуле базы. Возникает проблема, как задать переменную. Начинающие
делают это в лоб:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def server
  (jetty/run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def server (jetty/run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

\fi

Выражение запустит сервер при загрузке модуля. Это плохая практика, потому что в
загрузке не должно быть побочных эффектов. С~кодом невозможно работать в REPL:
он делает то, о чём не просили.

Сервер, базы данных и другие компоненты должны включаться по требованию, поэтому
их переменные вначале равны \verb|nil|. Функция \verb|start!| запускает
сервер и записывает его в \verb|server|. Функция \verb|stop!| останавливает
и меняет переменную на \verb|nil|.

\subsection{Понятие переменной}

\index{переменные}
\index{clojure.core!alter-var-root}

\label{var-section}

Чтобы изменить \emph{переменную}, прибегают к \verb|alter-var-root|. Функция
меняет объекты, которые задали через \verb|def| и \verb|defn|. Вызов похож
на \verb|swap!| для атома: функция принимает объект \verb|Var| и другую
функцию, которая вычислит новое значение из прежнего.

\index{классы!Var}

Рассмотрим, что такое \verb|Var|. Это экземпляр класса \verb|clojure.lang.Var|
из библиотеки Clojure. \verb|Var| описывает переменную в пространстве имён.
Чтобы получить объект переменной, её символ передают в макрос \verb|var|,
например \verb|(var server)|. Эта запись аналогична \verb|#'server|,
что немного короче.

\index{синтаксис!\texttt{\#\textquotesingle} (переменная)}

\index{символ}

\emph{Символ} переменной и её \emph{объект}~--- это разные сущности. Сам по себе
символ ничего не значит: он равен только самому себе. Представьте, что символ~---
это слово языка, комбинация букв. В языке не бывает одинаковых слов, однако у
слова может быть несколько значений.

\index{пространства имён}

Символ~--- это посредник между пространством имён и переменными. Когда мы пишем
\verb|(def num 42)|, это не значит, что переменная \verb|num| равна числу
42. На самом деле мы создали объект \verb|Var| со значением 42. Затем
поместили его в текущее пространство под символом \verb|num|.

Пространство имён работает как словарь. Ключи~--- это символы, а~значения~---
переменные. Формы \verb|def| и \verb|defn| наполняют этот словарь. Можно
сказать, \verb|def| задаёт слову смысл, и в момент компиляции Clojure
понимает это слово.

С символом связана операция \emph{вычисления}. Если в REPL ввести \verb|num|,
он выполнит поиск с таким ключом в пространстве имён. Когда ключ найден, REPL
вернёт значение переменной, в нашем случае 42. В противном случае возникнет
ошибка.

Clojure намеренно скрывает от нас стадию переменной, и это правильно. Если бы
выражение \verb|num| вернуло переменную, в этом не было бы
смысла. \verb|Var|~--- не цифра, а сложный объект. Значение 42~--- это лишь одно
из множества его полей.  Как правило, переменные скрыты от
пользователя. Разработчик видит либо их символ (\verb|num|), либо значение
(\verb|42|). Функция \verb|alter-var-root|~--- тот случай, когда переменные
вступают в~игру.

\subsection{Запуск по требованию}

Вернёмся к серверу. Объявим переменную, которая в будущем станет объектом
\texttt{jetty.server\zspace.Server}. По умолчанию она равна \verb|nil|:

\begin{english}
  \begin{clojure}
(def server nil)
  \end{clojure}
\end{english}

Функция \verb|start!| заменяет \verb|server| результатом анонимной
функции. Она принимает текущее значение переменной. Когда это \verb|nil|,
создаём и возвращаем новый сервер. Если нет, вернём текущий.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn start! []
  (alter-var-root
   (var server)
   (fn [server]
     (if-not server
       (run-jetty app {:port 8080
                       :join? false})
       server))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn start! []
  (alter-var-root
   (var server)
   (fn [server]
     (if-not server
       (run-jetty app {:port 8080 :join? false})
       server))))
  \end{clojure}
\end{english}

\fi

\noindent
Аналогично работает \verb|stop!|: если сервер включен (не \verb|nil|),
остановим его и вернём \verb|nil|.

\begin{english}
  \begin{clojure}
(defn stop! []
  (alter-var-root
   (var server)
   (fn [server]
     (when server
       (.stop server))
     nil)))
  \end{clojure}
\end{english}

Вызов \verb|(start!)| запустит сервер в фоне. Браузер ответит на запросы по
адресу \texttt{localhost\zspace:8080}. Переменная \verb|server| напечатает в REPL
объект сервера.

\index{пул соединений}
\index{библиотеки!JDBC}

Похожим образом работают с базой. Чтобы не открывать подключение на каждый
запрос, применяют пулы соединений. В модуле объявляют переменную \verb|pool|
со значением \verb|nil|. Функция \verb|start!| создаёт новый пул и обновляет
переменную. После запуска к базе посылают запросы. Функции \verb|query|,
\verb|insert!| и другие из пакета JDBC принимают подключение к базе или пул:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(jdbc/query pool "select * from users")
(jdbc/insert! pool
  :users {:name "Ivan"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(jdbc/query pool "select * from users")
(jdbc/insert! pool :users {:name "Ivan"})
  \end{clojure}
\end{english}

\fi

Функция \verb|stop!| выключает пул, закрывает соединения и выставляет
\verb|pool| в \verb|nil|. Опустим код этих функций, потому что они
аналогичны примерам для HTTP-сервера. Разница только в имени глобальной
переменной и выражении, где создают сервер и пул.

\subsection{Коротко о системах}

\index{системы}

\label{systems-intro}

Техника \verb|alter-var-root| сообщает модулю состояние: включен или
выключен. С таким подходом проект удобно включать по частям, а не всё
разом. Для отладки базы не нужен веб-сервер, а кэширование не зависит от
рассылки писем.

Модули с состоянием называют компонентами. Вместе они образуют систему. С
помощью \verb|alter-var-root| строят системы в небольших проектах. В основном
это веб-приложение с сервером и базой данных. В шутку их называют системами для
бедных.

\index{системы!бедные}

<<Бедные>> системы не зависят от сторонних библиотек. Каждый модуль выставляет
универсальные <<ручки управления>>: функции \verb|start!| и \verb|stop!|,
которые обращаются к \verb|alter-var-root|. Это простая и удобная схема.

С другой стороны, <<бедные>> системы не знают, как один компонент зависит от
другого. Со временем зависимости становятся проблемой, поэтому большие системы
строят с помощью библиотек. Некоторые из них тоже опираются на
\verb|alter-var-root|. Системам посвящена отдельная глава этой
книги \page{chapter-systems}.

\subsection{Патчинг}

\index{clojure.core!alter-var-root}
\index{патчинг}

Выше мы изменили переменную в текущем модуле. Истинная мощь
\verb|alter-var-root| в том, что функция работает с переменными \emph{любого}
пространства. Под любым мы понимаем:

\begin{itemize}

\item
  текущий модуль;

\item
  соседние модули проекта;

\item
  сторонние библиотеки;

\item
  стандартные модули Clojure, например \verb|clojure.core|.

\end{itemize}

\index{monkey patch}

Это мощная техника, но к ней прибегают редко. Менять код в~полёте считается
сомнительной практикой. По-другому её называют \footurl{monkey patch}{https://en.wikipedia.org/wiki/Monkey\_patch}[Monkey patch][-7mm]. Термин означает изменение классов и функций не в~коде, а~когда программа уже запущена.

Если патчингом злоупотребляют, программа ведёт себя неочевидным
образом. Коллеги не сразу поймут, почему в коде написано одно, а~выполняется
другое. Это затрудняет поддержку и вносит раздражение. К патчингу прибегают,
если сошлись несколько условий:

\begin{itemize}

\item
  без изменений нельзя двигаться дальше;

\item
  проблема в сторонней библиотеке или платформе;

\item
  на устранение проблемы уйдёт время.

\end{itemize}

Патчинг оправдан, когда вы нашли ошибку в чужой библиотеке. Даже если изменения
примут сразу, выпуск новой версии займёт время. Если ошибка задерживает релиз,
подмените проблемную функцию с~помощью \verb|alter-var-root|.

Представим: условная библиотека Yamler парсит файлы YAML. Функция
\verb|read-yaml-tag| отвечает за теги. Выяснилось, что в разборе тегов ошибка,
а нам нужно расставить их файле. Если ошибку легко исправить, напишем функцию со
звёздочкой и заменим оригинал:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn read-yaml-tag*
  "The fixed version of
  `yamler.tags/read-yaml-tag`."
  [stream tag]
  ...)

(alter-var-root
 (var yamler.tags/read-yaml-tag)
 (constantly read-yaml-tag*))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn read-yaml-tag*
  "The fixed version of `yamler.tags/read-yaml-tag`."
  [stream tag]
  ...)

(alter-var-root
 (var yamler.tags/read-yaml-tag)
 (constantly read-yaml-tag*))
  \end{clojure}
\end{english}

\fi

В комментарии добавьте ссылку на артефакт (GitHub, Jira). Создайте задачу,
чтобы удалить патч по выходу новой версии библиотеки.

Патчинг полезен в разработке. Данные часто печатают на экран, чтобы исследовать
их. Недостаток \verb|println| в том, что вывод не структурирован. Коллекции
слипаются в одну строку, поэтому их трудно читать.

\index{печать!с отступами}
\index{модули!clojure.pprint}

Пакет \verb|clojure.pprint| (сокращение от англ.~\textbf{p}retty \textbf{p}rinting)
решает эту проблему. Функция \verb|pprint| выводит данные с отступами и~переносами строк,
что удобно для вложенных словарей. Но писать \verb|(clojure.pprint/pprint data)|
вместо \verb|(println data)| долго. Чтобы сократить код, заменим \verb|println|
на \verb|pprint|. Для этого пропатчим функцию:

\begin{english}
  \begin{clojure}
(alter-var-root
 (var println)
 (constantly clojure.pprint/pprint))
  \end{clojure}
\end{english}

Выполните этот патч один раз в любом месте проекта. Теперь вызов
\verb|(println data)| напечатает данные, как это делает \verb|pprint|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(println <vector-of-dicts-of-vectors>)

[{:foo 42
  :bar [1 2 3 4 5 {:foo 42
                   :bar [1 2 {#, #}]}]}
 {:foo 42
  :bar [1 2 {:foo 42
             :bar [1 2 {#, #}]}]}]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(println <vector-of-dicts-of-vectors>)

[{:foo 42, :bar [1 2 3 4 5 {:foo 42, :bar [1 2 {#, #}]}]}
 {:foo 42, :bar [1 2 {:foo 42, :bar [1 2 {#, #}]}]}]
  \end{clojure}
\end{english}

\fi

Функция заменит вложенные участки на символ \verb|#|, чтобы не обрушить на
вас лавину данных. Глубину и длину печати задают особые переменные. Позже мы
узнаем, как управлять ими.

\subsection{В боевом режиме}

\label{install-logger}

\index{логирование!исключений}
\index{исключения!логирование}
\index{логирование!бекэнды}

Рассмотрим, когда \verb|alter-var-root| полезен в промышленном запуске. В
предыдущей главе мы отметили проблему: у нас нет контроля за тем, как выглядит
исключение в логе \page{log-ex-param}. Перевод исключения в текст остаётся на
усмотрение бекэнда (log4j, Logback и других).

Мы написали функцию \verb|ex-print|, которая печатает исключение как нужно
нам. Функция не вываливает стек-трейс на весь экран, а обходит цепочку. Для
каждого звена она выводит класс, сообщение и контекст:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e
                   class
                   .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

\fi

\noindent
Минус в том, что вместо \verb|(log/error e)| приходится писать:

\begin{english}
  \begin{clojure}
(log/error (with-out-str (ex-print e)))
  \end{clojure}
\end{english}

\noindent
Это долго и вынуждает импортировать \verb|ex-print| в каждый модуль, где логируют
исключения. Будет удобней, если останется только \verb|(log/error e)|, а
\verb|ex-print| сработает где-то за кадром. Это возможно с помощью
\texttt{alter-var\zspace-root}.

Заметим, что \verb|log/error|, \verb|log/info| и аналоги~--- это не функции, а
макросы. Макрос~--- это эфемерная сущность, на которую нельзя сослаться через
\verb|var|. Макрос живет \emph{до} компиляции программы. Позже на его месте
остаётся код, который он произвёл. Нельзя изменить макрос, но можно подменить
функции, которые он вызывает.

\index{логирование}

Макросы \verb|log/error| и другие сводится к функции \verb|log/log*|. Это
бутылочное горлышко, через которое проходят все логи. Вот как выглядит её
сигнатура:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn log*
  [logger level throwable message])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn log* [logger level throwable message])
  \end{clojure}
\end{english}

\fi

Параметр \verb|throwable|~--- это исключение или \verb|nil|. Подменим
\verb|log*| на анонимную функцию со следующей логикой:

\begin{itemize}

\item
  если \verb|throwable| не \verb|nil|, перевести исключение в текст;

\item
  добавить его к исходному сообщению через перенос строки;

\item
  вызвать оригинальный \verb|log*| с новым сообщением и \verb|nil| для
  \verb|throwable|. В исключении отпала потребность, поскольку теперь оно
  часть сообщения;

\item
  если \verb|throwable| \verb|nil|, вызвать \verb|log*| с исходными
  аргументами.

\end{itemize}

\noindent
Реализация:

\index{функции!install-better-logging}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure/lines}
(defn install-better-logging []
  (alter-var-root
   (var clojure.tools.logging/log*)
   (fn [log*] ;; origin function
     (fn [logger level
          throwable message]
       (if throwable
         (let [ex-out (with-out-str
                        (ex-print
                          throwable))
               message* (str message
                          \newline
                          ex-out)]
           (log* logger
             level nil message*))
           (log* logger level
             throwable message))))))
  \end{clojure/lines}
\end{english}

\else

\begin{english}
  \begin{clojure/lines}
(defn install-better-logging []
  (alter-var-root
   (var clojure.tools.logging/log*)
   (fn [log*] ;; origin function
     (fn [logger level throwable message]
       (if throwable
         (let [ex-out (with-out-str (ex-print throwable))
               message* (str message \newline ex-out)]
           (log* logger level nil message*))
         (log* logger level throwable message))))))
  \end{clojure/lines}
\end{english}

\fi

Хитрость кроется в параметре \verb|log*| \coderef{4}. Анонимная функция в
\verb|alter-var-root| принимает текущее значение переменной. Это исходная
функция \verb|clojure.tools.logging/log*|, и параметр \verb|log*| ссылается
на неё. Новая функция замкнута на исходной и может её вызывать.

Получился декоратор: мы только меняем входные параметры и передаём дальше После
вызова \verb|(install-better-logging)| вывод исключений изменится. Достаточно
написать \verb|(log/error e)|, чтобы ошибка приняла нужный вид.

Преимущество в том, что мы управляем \emph{всем} на уровне Clojure. Если
понадобится улучшить логи, доработаем \verb|ex-print| в любой момент. Это
удобнее, чем наследовать условный \verb|com.logging.ErrorRenderer|
и~переопределять его методы.

Вред от необдуманного \verb|alter-var-root| сводит на нет плюсы, что мы
рассмотрели. Функция нужна, чтобы точечно менять переменные в~особых
случаях. Прибегайте к патчингу только если другие варианты исчерпаны.

\section{Присваивание с set!}

\index{печать!с отступами}
\index{модули!clojure.pprint}

Вернёмся к функции \verb|pprint| для красивой печати. Она интересна тем, что
проверяет длину и уровень коллекций. Так мы не допустим ситуации, когда печать
заливает несколько экранов. Проверка на длину особенно важна, потому что
некоторые коллекции не просто велики, а~\emph{бесконечны}.

\index{коллекции!бесконечные}
\index{clojure.core!*print-length*}
\index{clojure.core!set"!}

Глобальные переменные \verb|*print-length*| и \verb|*print-level*| задают длину
и вложенность вывода. По умолчанию \verb|*print-length*| равна 100. Это довольно
много, особенно если учесть, что элементами могут быть другие
коллекции. Результат запроса к базе~--- это список словарей. Печатать сто словарей
расточительно, поэтому уменьшим \verb|*print-length*| на старте приложения. Для
этого служит форма \verb|set!|:

\begin{english}
  \begin{clojure}
(set! *print-length* 8)
  \end{clojure}
\end{english}

Вывод бесконечной коллекции покажет только первые восемь элементов. Многоточие
означает, что остальные элементы отбросили.

\begin{english}
  \begin{clojure}
(println (repeat 1))
;; (1 1 1 1 1 1 1 1 ...)
  \end{clojure}
\end{english}

Вложенность или уровень коллекции~--- это воображаемый индекс. Когда одна коллекция
становится элементом другой, её индекс увеличивается на единицу. Объявим
вложенную структуру:

\begin{english}
  \begin{clojure}
(def data {:foo
            {:bar
              {:baz [42]}}})
  \end{clojure}
\end{english}

\noindent
Вывод с различными значениями \verb|*print-level*|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
;; {:foo {:bar #}}
  \end{clojure}

\splitter

  \begin{clojure}
(set! *print-level* 2)
(println data)
;; {:foo #}
  \end{clojure}
\end{english}

\else

\begin{english}
\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }


  \begin{clojure}
(set! *print-level* 4)
(println data)
;; {:foo {:bar #}}
  \end{clojure}

&

  \begin{clojure}
(set! *print-level* 2)
(println data)
;; {:foo #}
  \end{clojure}

\end{tabular}

\end{english}

\fi

\noindent
При нулевом уровне увидим только \verb|#|.

В Clojure около десяти переменных с <<ушками>>. По-другому их~называют
системными, потому что они влияют на поведение языка в~целом. Две переменных мы
уже рассмотрели: это \verb|*print-length*| и~\verb|*print-level*| для
печати. Перечислим несколько других:

\index{синтаксис!\texttt{*}ушки\texttt{*}}

\begin{itemize}

\index{рефлексия}
\index{clojure.core!*warn-on-reflection*}

\item
  \verb|*warn-on-reflection*|: если истина, компилятор предупреждает о местах,
  где он обратился к рефлексии. Проблему решают расстановкой тегов с типами;

\index{clojure.core!assert}
\index{clojure.core!*assert*}

\item
  \verb|*assert*|: если ложь, отключает \verb|assert|-макрос. Форма
  \verb|assert| проверяет выражение на истинность. Когда оно ложно, макрос
  бросает исключение.  По умолчанию \verb|assert|ы включены; ими пользуются в
  разработке и тестировании. В боевом режиме их~выключают, чтобы не тратить
  ресурсы;

\label{print-meta}

\index{метаданные}
\index{печать!метаданных}
\index{clojure.core!*print-meta*}
\index{библиотеки!Component}

\item
  \verb|*print-meta*|: выводить или нет метаданные объекта при печати. По
  умолчанию~--- ложь. Иногда в метаданных хранят поля, которые влияют на работу
  программы. Например, библиотека Component управляет зависимостями компонентов
  через метаданные. Чтобы увидеть их, установите \verb|*print-meta*| в~истину.

\end{itemize}

Эти и другие переменные изменяют формой \verb|set!|. Рассмотрим несколько
примеров. Показать предупреждения, если компилятор не вывел тип:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(set! *warn-on-reflection* true)
(def ms (System/currentTimeMillis))

(.toString ms) ;; reflection warning
(.toString ^Long ms) ;; no warning
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(set! *warn-on-reflection* true)
(def ms (System/currentTimeMillis))

(.toString ms)       ;; reflection warning
(.toString ^Long ms) ;; no warning
  \end{clojure}
\end{english}

\fi

\noindent
Отключить формы \verb|assert|. Ложные выражения не вызовут ошибку:

\begin{english}
  \begin{clojure}
(set! *assert* false)
(assert (get {:foo 3} :bar))
;; won't throw an exception
  \end{clojure}
\end{english}

\noindent
Вывести объект с метаданными (приведём фрагмент в~листинге
\ref{fig:print-var-meta}). Обратите внимание, что переменная хранит имя файла
и~позицию в~нём. Эти сведения используют плагины для навигации по коду.

\begin{listing}[ht!]

\begin{english}
  \begin{clojure}
(set! *print-meta* true)
(var +)

^{:added "1.2"
  :name +
  :file "clojure/core.clj"
  :column 1
  :line 984
  :arglists ([] [x] [x y] [x y & more])
  :doc "Returns the sum of nums..."}
#'clojure.core/+
  \end{clojure}
\end{english}

\caption{Печать переменной в REPL с метаданными}
\label{fig:print-var-meta}

\end{listing}

\index{утилиты!lein}
\index{профили!lein}

Утилиты для управления проектами читают переменные с <<ушками>> из
словаря. Конфигурация \verb|lein| учитывает ключ \verb|:global-vars|. Ещё
большей гибкости можно добиться, если указать переменные в профилях. Ниже мы
задаём разные переменные в зависимости от режима разработки (\verb|dev|) или
сборки (\verb|uberjar|).

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:profiles
 :dev {:global-vars
       {*warn-on-reflection* true
        *assert* true}}
 :uberjar {:global-vars
           {*warn-on-reflection* false
            *assert* false}}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:profiles
 :dev {:global-vars {*warn-on-reflection* true
                     *assert* true}}
 :uberjar {:global-vars {*warn-on-reflection* false
                         *assert* false}}}
  \end{clojure}
\end{english}

\fi

Внутри \verb|binding| форма \verb|set!| работает как оператор
присваивания. Переменная должна быть динамической:

\begin{english}
  \begin{clojure}
(def ^:dynamic *rate*)
(def ^:dynamic *days*)

(binding [*rate* 0
          *days* 0]
  (when-let [rate (calc-date)] ;; 3
    (set! *rate* rate))
  (when-let [days (calc-days)] ;; 4
    (set! *days* days))
  (* *rate* *days*))
;; 12
  \end{clojure}
\end{english}

\noindent
За пределами \verb|binding| вызов \verb|set!| обернётся ошибкой, даже если
переменная с~<<ушками>>:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def ^:dynaimc *data* nil)

(set! *data* {:user 1})
;; Unhandled IllegalStateException
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def ^:dynaimc *data* nil)

(set! *data* {:user 1})
;; Unhandled java.lang.IllegalStateException
;; Can't change/establish root binding of: *data* with set
  \end{clojure}
\end{english}

\fi

\section{Изменения в контексте}

\index{контекст}
\index{изменения!в контексте}

Приёмы, которые мы рассмотрели, похожи в следующем: их эффект длится до конца
программы. Изменения в атомах, транзиентных коллекциях и глобальных переменных
называют \emph{персистентными} (англ.~persistent~--- <<постоянный>>).

Иногда изменения должны быть временными: глобальная переменная равна $x$, но
участок кода ожидает $y$. Можно сделать временные изменения на базе постоянных:
окружить код вызовом \verb|alter-var-root| с новым и старым значениями. У
такого подхода две проблемы: изоляция и откат.

\index{clojure.core!alter-var-root}

Временные изменения протекают в одном потоке. У~\verb|alter-var-root|
противоположный эффект~--- функция меняет переменную для всех потоков. Если
фрагмент кода вызывает \verb|alter-var-root|, он задевает всех участников. Это
приводит к странному поведению программы.

Проблема отката означает, что при выходе из блока переменную нужно вернуть в прежнее
состояние. Когда код оборачивают в формы \verb|alter-var-root| или \verb|set!|, одна
из них может потеряться или не получить управление из-за ошибки.

Clojure предлагает несколько форм, чтобы выполнить код в контексте переменных с
другими значениями. Одна из них называется \verb|binding| \eng{связывание}.

\index{связывание}
\index{clojure.core!binding}

Синтаксис \verb|binding| похож на \verb|let|: форма связывания и
произвольный код. Связывание~--- это вектор, где указаны символы переменных и~новые
значения. Символы ссылаются на уже объявленные переменные. Блок кода запускается
с новыми значениями у переменных. Результат \verb|binding|~--- это последнее
выражение блока. Изменения \verb|binding| протекают в рамках текущего потока и
не влияют на соседние. При выходе переменные получат старые значения.

\subsection{Динамические переменные}

\label{dynamic-vars}

\index{переменные!динамические}
\index{синтаксис!\texttt{\^} (метаданные)}

\verb|Binding| работает только с динамическими переменными. Компилятор считает
переменную таковой, если ей назначили тег \verb|^:dynamic|. Это сокращённая
форма \verb|^{:dynamic true}|:

\begin{english}
  \begin{clojure}
(def ^:dynamic *server* nil)
;; or
(def ^{:dynamic true} *server* nil)
  \end{clojure}
\end{english}

Словарь с крышкой в \verb|def| называют метаданными. Это дополнительные
параметры будущей переменной. В данном случае мы сообщаем компилятору, что
переменная динамическая и может быть изменена в~будущем.

Глобальные переменные выделяют <<ушками>>, звёздочками по краям. В английском
языке такую запись называют earmuffs syntax. Правило возникло в старых
диалектах Лиспа, и Clojure следует традиции. Глобальные переменные не совсем
вписываются в идеи Clojure, поэтому их выделяют на общем фоне.

\index{языки!Lisp}

<<Ушки>> и динамичность связаны между собой. Если переменная с~<<ушками>>, но не
динамическая, компилятор скажет о расхождении. Сами по себе <<ушки>> не делают
переменную динамической, это просто соглашение.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def *server* nil)
;; Warning: *server* not declared dynamic
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def *server* nil)
;; Warning: *server* not declared dynamic and thus [...]
;; Please either indicate ^:dynamic *server* or change the name.
  \end{clojure}
\end{english}

\fi

\noindent
Если переменная не динамическая, \verb|binding| бросит исключение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(binding [*server* {:port 8080}]
  (println *server*))
;; IllegalStateException
;; Can't dynamically bind
;; non-dynamic var: *server*
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(binding [*server* {:port 8080}]
  (println *server*))
;; Execution error (IllegalStateException)
;; Can't dynamically bind non-dynamic var: *server*
  \end{clojure}
\end{english}

\fi

\subsection{Отказ от set!}

Вспомним параметры длины и глубины печати. Чтобы обезопасить себя от больших
данных, мы писали что-то вроде:

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
  \end{clojure}
\end{english}

\index{печать!с отступами}

Это неудачный пример: он нарушает принципы изоляции и отката, которые мы
рассмотрели. Изменение \verb|*print-level*| не изолировано и~влияет на систему
глобально. Если другой поток что-то напечатает, мы увидим результат с уровнем 4,
что может нас не устроить. После \verb|(println data)| нужно восстановить
прежнее значение \verb|*print-level*|, но об этом легко забыть.

Код ниже избавлен от недостатков. Вне \verb|binding| переменные получат
прежние значения, а соседние потоки ничего не заметят.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(binding [*print-level* 8
          *print-length* 4]
  (println
    {:foo {:bar {:baz (repeat 1)}}}))
;; {:foo {:bar {:baz (1 1 1 1 ...)}}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(binding [*print-level* 8
          *print-length* 4]
  (println {:foo {:bar {:baz (repeat 1)}}}))
;; {:foo {:bar {:baz (1 1 1 1 ...)}}}
  \end{clojure}
\end{english}

\fi

\index{clojure.core!*out*}
\index{классы!Writer}

Чтобы направить печать в файл, свяжите переменную \verb|*out*| с~объектом
\verb|Writer|:

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(with-open [out (io/writer "dump.edn")]
  (binding [*out* out]
    (clojure.pprint/pprint {:test 42})))
  \end{clojure}
\end{english}

Объединим эти примеры в функцию для сброса данных в файл. Функция полезна для
отладки больших данных. Она принимает путь к файлу и коллекцию. Функция
связывает вывод с открытым файлом и печатает данные. Чтобы увидеть все элементы,
повысим длину и~глубину печати.

\begin{english}
  \begin{clojure}
(defn dump-data
  [path data]
  (with-open [out (io/writer path)]
    (binding [*out* out
              *print-level* 32
              *print-length* 512]
      (clojure.pprint/pprint data))))
  \end{clojure}
\end{english}

\noindent
Сброс данных в файл:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(dump-data "sample.edn"
  {:foo [1 2 3 {:foo [1 2 3]}]})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(dump-data "sample.edn" {:foo [1 2 3 {:foo [1 2 3]}]})
  \end{clojure}
\end{english}

\fi

\noindent
и восстановление:

\begin{english}
  \begin{clojure}
(-> "sample.edn" slurp read-string)
;; {:foo [1 2 3 {:foo [1 2 3]}]}
  \end{clojure}
\end{english}

\index{clojure.core!*print-level*}
\index{clojure.core!*print-length*}

Доработайте функцию так, чтобы в длину и глубину печати можно было передать свои
значения. В идеале это необязательный словарь \verb|opt|, в~котором функция ищет
настройки.

\subsection{Практика: перевод строк}

\label{translate}

Привёдем пример с \verb|binding| из реального проекта. Это веб-приложение на
разных языках. В зависимости от настроек клиент видит английский или русский
текст.

\index{перевод}

Переводы хранят в виде словаря с двумя уровнями: локаль и теги. Локаль~--- это код
языка: \verb|ru|, \verb|en| и другие. Локаль может быть с доменами, например
\verb|en_US| или \verb|en_GB|. Части \verb|US| и \verb|GB| означают
американский и~британский диалекты. В редких случаях локаль бывает тройной,
чтобы указать местный алфавит или регион.

Под тегом понимают короткую машинную строку. Она описывает семантику фразы, на
которую позже её заменят. По тегу \verb|ui/add-to-cart| легко угадать, что
это надпись <<добавить в корзину>> в интерфейсе.

Словари могут быть в коде или файлах, но принцип перевода не меняется. По локали
и тегу библиотека ищет перевод в словаре (или <<совершает lookup>>). Напишем
наивный подход на Clojure:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(def tr-map
  {:en {:ui/add-to-cart "Add to Cart"}
   :ru {:ui/add-to-cart
        "Добавить в корзину"}})

(defn tr [locale tag]
  (or (get-in tr-map [locale tag])
      (format "<%s%s>" locale tag)))
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def tr-map
  {:en {:ui/add-to-cart "Add to Cart"}
   :ru {:ui/add-to-cart "Добавить в корзину"}})

(defn tr [locale tag]
  (or (get-in tr-map [locale tag])
      (format "<%s%s>" locale tag)))
  \end{clojure}
%% \end{english}

\fi

\index{локализация}

Функция \verb|tr| возвращает перевод по локали и тегу. Если перевод не найден,
получим машинное выражение, которое заметят локализаторы.

Недостаток функции в том, что каждый раз нужно указывать локаль. Это
утомительно, особенно с учётом того, что локаль не меняется в рамках
запроса. Между локалью и переводом большая физическая и ментальная
дистанция, и хотелось бы её сократить.

\index{стек вызовов}

Под физическим расстоянием понимают стек вызовов. Обычно локаль вычисляют в
начале запроса. Перевод текста, напротив, работает ближе к его концу. Если не
сделать локаль глобальной, придётся спускать её в аргументах по стеку вызовов,
что усложнит код.

\index{фреймворки!Django}

Ментальная дистанция означает, что в момент перевода нам не важно, откуда пришла
локаль. Эти сведения избыточны. Хотелось бы примитивную операцию <<перевести
тег>>, и не больше. Польза упрощения видна на примере шаблонной системы,
устроенной по принципу \footurl{Django}{https://docs.djangoproject.com/en/2.2/topics/templates/}[Django templates][-23mm].

\index{библиотеки!Selmer}
\index{шаблоны}

Аналог такой системы в Clojure называется
\footurl{Selmer}{https://github.com/yogthos/Selmer}[Selmer]. Её шаблоны похожи на
обычные HTML-файлы со вставками в фигурных скобках. Код в скобках~--- это значения
или выражения. Вертикальные линии означают фильтры, функции
преобразования. Например, запись

\begin{english}
  \begin{htmldjango}
<p>{{ user.email|lower }}</p>
  \end{htmldjango}
\end{english}

\noindent
означает, что между тегами параграфа находится поле \verb|:email| из словаря
\verb|user|. Регистр поля меняют на нижний фильтром \verb|lower|. На Clojure
это выглядело бы так:

\begin{english}
  \begin{clojure}
(str/lower-case (:name user))
  \end{clojure}
\end{english}

Фильтром может быть любая функция, в том числе \verb|tr|. Хотелось бы,
чтобы шаблон выглядел как можно проще:

\ifx\devicetype\mobile

\begin{english}
  \begin{htmldjango}
<div class="widget">
  <a href="/login">
    {{ "ui/log-in"|tr }}
  </a>
  <a href="/help">
    {{ "ui/help"|tr }}
  </a>
</div>
  \end{htmldjango}
\end{english}

\else

\begin{english}
  \begin{htmldjango}
<div class="widget">
  <a href="/login">{{ "ui/log-in"|tr }}</a>
  <a href="/help">{{ "ui/help"|tr }}</a>
</div>
  \end{htmldjango}
\end{english}

\fi

Фильтр \verb|tr|~--- это функция одной переменной. Она принимает строку тега и
возвращает перевод. Очевидно, локаль должна быть известна заранее. Сделаем так,
чтобы фильтр читал её из middleware и при этом не влиял на перевод в параллельных
запросах.

Поможет связывание через \verb|binding|. Объявим переменную \verb|*locale*| без
значения. В Clojure такая переменная называется несвязанной. Считайте её
ячейкой, в которой нет данных.

Изменим функцию \verb|tr|: теперь она принимает только тег, а в качестве
локали ссылается на глобальную \verb|*locale*|:

\begin{english}
  \begin{clojure}
(def ^:dynamic *locale*)

(defn tr [tag]
  (get-in tr-map [*locale* tag]))
  \end{clojure}
\end{english}

\index{макросы!with-locale}

Чтобы изолировать \verb|*locale*| от потребителей, предоставим макрос
\verb|with-locale|. Он выполняет тело, пока переменная связана с заданной
локалью. Внутри макроса любой перевод сработает для этой локали:

\begin{english}
  \begin{clojure}
(defmacro with-locale
  [locale & body]
  `(binding [*locale* ~locale]
     ~@body))
  \end{clojure}
\end{english}

\index{middleware!wrap-locale}
\ifx\devicetype\mobile

\begin{clojure}
(with-locale :en
  (tr :ui/add-to-cart))
;; "Add to Cart"
\end{clojure}

\splitter

\begin{clojure}
(with-locale :ru
  (tr :ui/add-to-cart))
;; "Добавить в корзину"
\end{clojure}

\else

%% \begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
(with-locale :en
  (tr :ui/add-to-cart))
;; "Add to Cart"
  \end{clojure}

&

  \begin{clojure}
(with-locale :ru
  (tr :ui/add-to-cart))
;; "Добавить в корзину"
  \end{clojure}

\end{tabular}

%% \end{english}

\fi

Напишем middleware, чтобы определить локаль. Для простоты решим, что это
параметр \verb|lang| из адресной строки. Если параметра нет, берём локаль по
умолчанию. Код ниже по стеку обёрнут в макрос \verb|with-locale|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn request->locale [request]
  (let [lang (get-in request
               [:params "lang"])]
    (keyword
      (get #{"en" "ru"} lang "en"))))

(defn wrap-locale [handler]
  (fn [request]
    (with-locale
      (request->locale request)
      (handler request))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn request->locale [request]
  (let [lang (get-in request [:params "lang"])]
    (keyword (get #{"en" "ru"} lang "en"))))

(defn wrap-locale [handler]
  (fn [request]
    (with-locale (request->locale request)
      (handler request))))
  \end{clojure}
\end{english}

\fi

Напишем фильтр \verb|tr| для шаблонов. В Selmer нельзя указать кейворд,
поэтому вместо \verb|{{ :ui/sign-in }}| пишут \verb|{{ "ui/sign-in"}}|.
Фильтр \verb|tr| переводит строку в тег, а затем ищет по нему
перевод. Функция \verb|add-filter!| добавляет \verb|tr| в регистр фильтров.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
 '[selmer.filters :refer [add-filter!]])

(add-filter! :tr
 (fn [line]
   (-> line keyword tr)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[selmer.filters :refer [add-filter!]])

(add-filter! :tr
 (fn [line]
   (-> line keyword tr)))
  \end{clojure}
\end{english}

\fi

Теперь нам не важен источник локали в переводах. В любой момент мы изменим код
\verb|with-locale| и \verb|wrap-locale|, но это не отразится на
шаблонах. Запись \verb={{ "ui/log-in"|tr }}= останется прежней, даже если
механизм переводов изменится.

\section{Локальные переменные в контексте}

\index{clojure.core!with-local-vars}
\index{clojure.core!let}
\index{clojure.core!var-get}
\index{clojure.core!var-set}
\index{переменные!локальные}

Макрос \verb|with-local-vars| задаёт локальные переменные. Внутри макроса
они ведут себя как маленькие атомы. В переменную можно записать значение и
получить обратно <<дерефом>>. Локальные переменные полезны для запутанной
бизнес-логики. Блок с ними выглядит линейно, и его проще читать.

Форма \verb|with-local-vars| похожа на \verb|let|: это вектор связывания и
произвольный код. Разница в том, что внутри макроса работают функции
\verb|var-get| и \verb|var-set|. С их помощью переменные читают
и~записывают. Если макрос задал переменную \verb|a|, форма \verb|(var-set a 9)|
установит её содержимое в 9.

Важно: символ переменной вернёт её \emph{объект}, а не значение. В~примере ниже
получим не ноль, а объект типа \verb|Var|. Запись \verb|(+ a 1)| приведёт~к
ошибке типов.

\begin{english}
  \begin{clojure}
(with-local-vars [a 0] a)
;; #<Var: --unnamed-->
  \end{clojure}
\end{english}

Функция \verb|var-get| получает значение из переменной. Для краткости
прибегают к оператору \verb|@|: \verb|(+ @a 1)|.

Представим: нужно найти в дереве несколько величин и вернуть их композицию. В
прошлый раз мы работали с атомом, теперь решим задачу на локальных переменных.

Функция \verb|calc-billing| рассчитывает сумму к оплате для клиента. Параметр
\verb|data|~--- это данные о потреблении ресурсов. Итоговую сумму находят из трёх
составляющих. Каждую из них рассчитывают по сложным условиям. Чтобы код был
ближе к бизнес-логике, запишем его императивно:

\begin{english}
  \begin{clojure}
(defn calc-billing [data]
  (with-local-vars
    [a 0 b 0 c 0]
    ;; find a
    (when-let [usage ...]
      (when-let [days ...]
        (var-set a (* usage days))))
    ;; find b
    (when-let [vms ...]
      (when-let [limits ...]
        (var-set b (* limits vms))))
    ;; find c ...
    (+ (* @a @b) @c)))
  \end{clojure}
\end{english}

Расчёт делится на три блока, каждый из которых находит составляющую. Каскад
\verb|when-let| собирает нужные переменные, и если они нашлись, завершается
\verb|var-set|. Если исполнение не дошло до \verb|var-set|, переменная
останется нулём.

Локальные переменные не настолько продвинуты, как атомы. Для переменных нет
аналога \verb|swap!|, когда значение меняют функцией. \verb|With-local-vars|
не подходит для наращивания коллекций. Если \verb|user|~--- это локальный словарь,
добавить ему новое поле будет трудно. Функция \verb|var-set| задаёт только
новый словарь, а комбинация \verb|var-set| и \verb|var-get| выглядит
неуклюже:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(with-local-vars [user {:name "Ivan"}]
  ;; won't work
  ;; (var-set user assoc :age 33)
  ;; ugly
  (var-set user (assoc @user :age 33))
  @user)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-local-vars [user {:name "Ivan"}]
  ;; (var-set user assoc :age 33) ;; won't work
  (var-set user (assoc @user :age 33)) ;; ugly
  @user)
  \end{clojure}
\end{english}

\fi

Макрос \verb|with-local-vars| полезен, когда логика завязана на простых типах
(числах, строках). На локальных переменных удобно писать конечные автоматы и
алгоритмы с состоянием. Техника редко встречается в Clojure, но в нужный момент
экономит время и код.

\section{Глобальные изменения в контексте}

\index{clojure.core!binding}
\index{изменения!глобальные}

\label{with-redefs}

Преимущество \verb|binding| в том, что изменения протекают только в~текущем
потоке. Говорят, что эффект \verb|binding| потокобезопасный, что расценивают
как благо. И всё же бывают случаи, когда изменения должны быть глобальными. Для
этого служит форма \verb|with-redefs|.

Её синтаксис похож \verb|binding|: вектор связывания и произвольный
код. Эффект \verb|with-redefs| действует \emph{на все} потоки. Представим
веб-сервер, который отвечает на запросы параллельно. Если одна из страниц
выполняет логику в \verb|with-redefs|, это повлияет на соседние
запросы. По аналогии с \verb|binding| и \verb|let|, изменения откатываются при
выходе из макроса.

\ifx\devicetype\mobile
\noindent
\else
\fi
Пример ниже объясняет принципы \verb|with-redefs|. Мы подменяем функцию
\verb|println| на суррогат, который печатает постоянный текст. В~теле макроса
запускают футуру с телом \verb|(println 42)|.

\index{clojure.core!future}
\index{футуры}

Футура (или \emph{фьючер}, англ.~\emph{future}, <<будущее>>)~--- это посредник между
клиентом и многопоточностью. Футура принимает блок кода и передаёт его
исполнителю (executor). Чаще всего исполнитель занимает несколько тредов
(потоков процессора) и распределяет по ним задачи. Когда задача выполнена,
клиент получает результат <<дерефом>> футуры.

Тело \verb|(println 42)| выполняется в другом потоке. Оператор \verb|@|
перед футурой означает: ждать до тех пор, пока не придёт результат от
исполнителя. Код ниже напечатает fake print:

\index{clojure.core!constantly}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(with-redefs
  [println (constantly
             (print "fake print"))]
  @(future (println 42)))
;; fake print
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-redefs
  [println (constantly (print "fake print"))]
  @(future (println 42)))
;; fake print
  \end{clojure}
\end{english}

\fi

Это произошло потому, что \verb|with-redefs| повлиял в том числе и на тот
поток, в котором исполнитель обработал задачу.

Если убрать оператор \verb|@|, эффект \verb|with-redefs| пропадёт: футура
напечатает 42. Причина в том, цикл футуры занимает хоть и малое, но время. Без
оператора \verb|@| мы только запускаем футуру и сразу выходим из
\verb|with-redefs|. Пул доберётся до задачи \verb|(println 42)|, когда
эффект макроса уже закончится.

Документация \verb|with-redefs| подчёркивает, что макрос полезен при
тестировании. Иногда приложение опирается на сторонние сервисы вроде геопоиска
или графа социальных связей. При тестировании возникает проблема доступа к
сервисам. Приложение не должно обращаться к~ним: это усложняет тесты и делает их
зависимыми.

Идея в том, чтобы на время тестов подменить функции, которые обращаются в
сеть. Рассмотрим на практике, как это сделать.

\subsection{Практика: приложение с координатами}

\index{HTTP!POST}
\index{координаты}
\index{геолокация}

Мобильное приложение шлёт на сервер координаты пользователя~--- долготу и
широту. Позже пользователь изучает историю путешествий. Очевидно, он ожидает не
машинные цифры, а названия мест. Для каждой пары координат нужно найти данные об
этом месте.

Страница \verb|POST /location| принимает координаты в теле запроса. Чтобы
узнать данные о месте, мы обращаемся к стороннему сервису. Читаем из ответа поля
и пишем в базу вместе с координатами. Возвращаем клиенту ответ \verb|200 OK|.

Функция \verb|geo/place-info| выполняет геопоиск. На выходе получим
словарь с ключами \verb|:title|, \verb|:country|, \verb|:image_url| и
другими. Обработчик запроса:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn location-handler [request]
  (let [{:keys [params]} request
        point (select-keys params
                [:lat :lon])
        place (geo/place-info point)]
    (db/create-location
      (merge place point))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn location-handler [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        place (geo/place-info point)]
    (db/create-location (merge place point))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\fi

Во время поиска мобильное приложение ждёт ответа. С машинной точки зрения это
долго, ведь сеть не гарантирует мгновенный отклик. Чем больше клиентов шлют
координаты, тем больше запросов мы посылаем геосервису. Растёт число
открытых соединений, система замедляется.

\index{clojure.core!future}

Быстрое решение в том, чтобы записать координаты в базу и сразу ответить
клиенту, а сбор данных о месте вынести в футуру. Этим мы сократим ожидание:
теперь приложение ждёт только запись в базу, что быстрее, чем запрос к сторонней
службе.

В новой версии функция \verb|db/create-point| пишет координаты и~возвращает
\verb|id| новой записи. Ключ нужен, чтобы позже обновить локацию данными о
месте. Поиск данных и запись в базу протекают в~футуре.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn location-handler
  [request]
  (let [{:keys [params]} request
        point (select-keys params
                [:lat :lon])
        row-id (db/create-point point)]
    (future
      (let [place (geo/place-info
                    point)]
        (db/update-place row-id place)))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn location-handler
  [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        row-id (db/create-point point)]
    (future
      (let [place (geo/place-info point)]
        (db/update-place row-id place)))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

\fi

Возможны и другие варианты, например фоновый обработчик или очередь задач. Но
они дольше в реализации, а футура займёт пару строк. Это дешёвое решение,
которое даст время на поиск более проработанного.

\subsection{Тесты}

\index{тесты}
\index{clojure.core!with-redefs}

Напишем тест для нового обработчика. Чтобы не порождать сетевых запросов,
временно заменим функцию \verb|geo/place-info|. Для полноты картины проверим,
что случится, если геопоиск бросит исключение.

Каждый тест начинается с выражения \verb|with-redefs| для замены
\verb|geo/place-info|. Для краткости напишем макрос
\verb|with-place-info|. Он~принимает тело функции и~блок кода:

\begin{english}
  \begin{clojure}
(defmacro with-place-info
  [result & body]
  `(with-redefs [geo/place-info
                 (fn [~'point] ~result)]
     ~@body))
  \end{clojure}
\end{english}

Приведём положительный сценарий. В макросе \verb|with-place-info| геопоиск
вернёт заданный словарь. Мы вызываем обработчик и проверяем, что ответ
положительный. Чтобы убедиться, что футура записала данные в базу, мы ждём
и~читаем последнюю локацию. В~ней должны быть значения из геопоиска.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-place-ok
  (with-place-info
    {:title "test_title"
     :country "test_country"}
    (let [request {:params
                   {:lat 11.111
                    :lon 22.222}}
          {:keys [status]}
          (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location
            (db/get-last-location)
            {:keys [title country]}
            location]
        (is (= "test_title" title))
        (is (= "test_country"
               country))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-place-ok
  (with-place-info
    {:title "test_title"
     :country "test_country"}
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (= "test_title" title))
        (is (= "test_country" country))))))
  \end{clojure}
\end{english}

\fi

\index{HTTP!429}

Негативный сценарий: пусть геопоиск бросит исключение с кодом 429. Это
возможно, если превышен лимит на число запросов. Объявим исключение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def ex-quota
  (ex-info
    "The limit of requests
               has been reached"
    {:status 429
     :body {:code :QUOTA_REACHED}}))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def ex-quota
  (ex-info "The limit of requests has been reached"
           {:status 429 :body {:code :QUOTA_REACHED}}))
  \end{clojure}
\end{english}

\fi

\noindent
Проверим, что приложение вернёт положительный статус, но в базе нет данных о
месте, потому что запрос геопоиску не прошёл.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-place-quota-reached
  (with-place-info (throw ex-quota)
  (let [request {:params {:lat 11.111
                          :lon 22.222}}
        {:keys [status body]}
        (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location
            (db/get-last-location)
            {:keys [title country]}
            location]
        (is (nil? title))
        (is (nil? country))))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-place-quota-reached
  (with-place-info (throw ex-quota)
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status body]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (nil? title))
        (is (nil? country))))))
  \end{clojure}
\end{english}

\fi

С помощью \verb|with-place-info| можно спровоцировать любое исключение. Приём
полезен, когда \verb|catch| ожидает конкретные классы. Следующий тест имитирует
сбой в сети. Если в приложении особая реакция на исключение, тест зафиксирует
это. Правки в коде станут невозможны без изменений в тестах.

\index{тесты!ошибки}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(deftest test-place-conn-err
  (with-place-info
    (throw (new java.net.ConnectException
             "test_timeout"))
    ...))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(deftest test-place-conn-err
  (with-place-info
    (throw (new java.net.ConnectException "test_timeout"))
    ...))
  \end{clojure}
\end{english}

\fi

\index{моки}

Подмена функций и классов называется \emph{мокинг} (англ.~mock~--- <<подделка>>). Мы
подробно рассмотрим тесты в последней главе \page{chapter-tests}. Пока что
заметим, что макрос \verb|with-redefs|~--- это простой способ что-то <<замокать>>,
то есть подменить на время тестов.

\subsection{Коротко о with-redefs-fn}

\index{clojure.core!with-redefs-fn}

Макрос \verb|with-redefs| опирается на функцию \verb|with-redefs-fn|. Отличие
в~синтаксисе: она принимает словарь и функцию без аргументов. Ключи словаря~---
это объекты \verb|Var|. Функция сработает в момент, когда переменные получили
новые значения.

Перепишем пример с \verb|geo/place-info| на \verb|with-redefs-fn|. Напомним, что
запись \verb|#'|\texttt{<some\zspace{}thing>} означает \verb|(var <something>)|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point]
                      {:title "test"})}
  (fn []
    (geo/place-info {:lat 1 :lon 2})))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  (fn []
    (geo/place-info {:lat 1 :lon 2})))
  \end{clojure}
\end{english}

\fi

\index{синтаксис!\texttt{\#} (решётка)}

\verb|With-redefs-fn|~--- это именно функция, поэтому она не может принять
произвольный код, как это делают макросы. Чтобы передать код, его оборачивают в
функцию без аргументов. Если код~--- это одна большая форма (\verb|let| или
\verb|do|), необязательно заключать её в \verb|(fn [])|. Поставьте спереди
знак \verb|#|, чтобы превратить форму в анонимную функцию.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point]
                      {:title "test"})}
  #(let [point {:lat 1 :lon 2}
         place (geo/place-info point)]
     ...))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  #(let [point {:lat 1 :lon 2}
         place (geo/place-info point)]
     ...))
  \end{clojure}
\end{english}

\fi

Функция \verb|with-redefs-fn| выглядит непривычно из-за словаря и~символов
\verb|#'|. Она не похожа на \verb|let|, \verb|binding| и другие формы
связывания в Clojure. Макрос \verb|with-redefs| скрывает эти особенности; по
возможности пользуйтесь им.

\section{Заключение}

Clojure предлагает специальные типы для изменяемых данных. В~отличие от
императивных языков, где изменения встроены в синтаксис, в~Clojure пользуются
особыми формами. Язык устроен так, что данные меняют редко. Это продвинутый
уровень, к которому приходят после азов неизменяемости. Перечислим техники,
которые мы рассмотрели, и случаи, когда они полезны.

\emph{Атом}~--- это обёртка вокруг значения. Чтобы получить содержимое,
применяют оператор \verb|@| или функцию \verb|(deref <atom>)|. Новое
значение сообщают функцией \verb|reset!|. В основном атом изменяют итеративно
с~помощью \verb|swap!|, которая рассчитывает новое значение из текущего.

В атомах хранят состояние проекта. Это счётчики, сессии, локальный кэш
для ускорения расчётов. Атомы подходят на роль переменных в императивном
коде. Иногда в атомах хранят состояние модуля, например текущее подключение к
базе.

Объект \emph{volatile}~--- это облегчённый вариант атома. В отличие от него,
\verb|volatile| не поддерживает валидаторы и вотчеры и не управляет доступом
из разных потоков.

Переходные, или \emph{транзиентные, коллекции} получают из постоянных
аналогов. Когда коллекция транзиентна, меняется её содержимое. С~ними
работают функции \verb|conj!|, \verb|assoc!| и другие с восклицательным
знаком на конце. Функция \verb|persistent!| запечатывает коллекцию
и~возвращает постоянную копию.

Транзиентные коллекции полезны на больших данных, потому что быстрее
неизменяемых. Работайте с ними из одного потока. Другие части кода не должны
знать о том, что коллекция изменяется. Обмен переходными коллекциями~--- это грубая
ошибка.

Функция \emph{alter-var-root} заменяет глобальную переменную. С её помощью можно
вторгнуться в чужое пространство и что-то исправить. К~\verb|alter-var-root|
прибегают, чтобы изменить код, которым не владеют. Другое её применение~---
модули с состоянием, из которых собирается система.

Форма \emph{set!} изменяет системную переменную Clojure. Это особые переменные с
<<ушками>>, которые влияют на поведение системы в целом. \verb|Set!| редко
встречается в коде; лучше указать переменные в настройках проекта.

Макрос \emph{binding} выполняет код в рамках временных изменений. Макрос
связывает динамическую переменную с новым значением. Чтобы переменная была
динамической, ей сообщают флаг \verb|^:dynamic| и выделяют <<ушками>>.

\verb|Binding| действует только в текущем потоке. К нему прибегают, чтобы
участок кода вёл себя по-иному. Например, выводил текст не на экран, а в
файл. Динамические переменные легче спустить по стеку вызовов, как в примере с
локалью.

Макрос \emph{with-local-vars} выполняет тело с произвольными переменными. Они
похожи на атом с двумя действиями: прочитать и записать значение. Форма полезна,
когда имеем дело со сложной императивной логикой. При выходе из макроса
переменные исчезают.

Конструкция \emph{with-redefs} временно изменяет
\verb|def|-определения. В~отличие от \verb|binding|, она действует
глобально. Все фоновые сущности (футуры, агенты) подхватят
изменения. \verb|With-redefs|~--- это обёртка над низкоуровневой функцией
\verb|with-redefs-fn|. В основном ей пользуются в~тестах (<<мокинг>>).
