\chapter{Web development}

\begin{teaser}
Chapter 1 looks at writing Clojure applications. We will talk about data transfer using HTTP. What abstractions are over it and what Clojure offers. We'll see the advantages of a functional approach and why development this way is more convenient.
\end{teaser}

\index{organisations!Cognitect}
\index{organisations!StackOverflow}

Every year Cognitect \footurl{surveys}{https://blog.cognitect.com/blog/2017/1/31/clojure-2018-results}[Cognitect 2018] Clojure developers. One of their questions is ``What field do you work in?'' In 2010, half of the surveyed built web applications. By~2018, this number has grown to 80 percent, which is four-fifths of those people. We can find out similar dynamics in \footurl{StackOverflow surveys}{https://insights.stackoverflow.com/survey/2018}[Stack\-Overflow 2018][10mm].
According to them, more and more engineers are moving toward web development from related fields.

If you get a job related to Clojure, most likely you will work with web applications. We specifically do not say ``a site'' because the term is becoming a thing of the past. Nowadays, a web application is not only a text with pictures. Broadly speaking, this is a complex data exchange over HTTP.

Initially, the protocol was only intended to transmit HTML files, but over time it became suitable for data transfer. Its design proved to be so flexible that it did not have to change the standard.  Before moving on to Clojure, let's refresh in memory what the protocol is:
what parts it consists of and how a server works with it. This is important because programming languages and frameworks are changing, but the protocol is not.

\section{Introduction to HTTP}

\index{HTTP}

HTTP operates over TCP/IP stack.  Protocols in a broad sense are data exchange agreements. There are official documents where protocols are written. HTTP was documented in \footurl{RFC~2616}{https://tools.ietf.org/html/rfc2616}[RFC~2616][-5mm].
Developers of frameworks and browsers check with it to make the code work on different languages and platforms.

HTTP is textual, so it’s convenient. You don't need to parse bytes to understand what is happening. The main parts of the protocol are textual, although it also works with binary data.  There are requests and responses in HTTP. Both of them consist of three parts:
the first line, headers, and a body.

The first (start) line carries the most important information. Request and response lines are different in form. In case of requests, it contains a method, a path, and a version. A response line includes a status, a message, and a version.

\index{HTTP!headers}

Headers are key-value pairs. They are represented with a map in code. The headers carry additional information about a request/response. For example, a \verb|Content-Type| header tells how to read the body. Was it an XML or a JSON document? A program matches the header and reads the body properly.

A body follows headers. A body can contain anything~--- a text, pairs of fields and values, JSON, or an image. Standard allows the \verb|multipart-encoding| mixed type. Such a response body consists of parts. Each part has its content, e.g., a text, an image, another text, an archive.

Let's look at some examples of HTTP traffic. It is transmitted over a network in this form. Below you see a request to the Google homepage for the word Clojure:

\begin{http}
GET /search?q=clojure HTTP/1.1
Host: google.com
Accept-Language: en-us
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
\end{http}

Here is a POST request with JSON:

\begin{http}
POST /api/users/ HTTP/1.1
Host: example.com
Content-Type: application/json

{"username": "John", "city": "NY"}
\end{http}

Pay attention to an empty line above, it separates the body from the headers. The response to that request:

\begin{http}
HTTP/1.1 200 OK
Date: Tue, 19 Mar 2019 15:57:11 GMT
Server: Nginx
Connection: close
Content-Type: application/json

{
  "code": "CREATED",
  "message": "User has been created successfully."
}
\end{http}

You can see how elegantly the protocol is arranged: data goes in descending order of importance. After the first line, a client and a server are ready to decide what to do next.

\index{HTTP!404}

Consider the case when the request method and path are \verb|GET /about|, but such a page does not exist. The server will check the path in the routing table. If it is not found, we will receive a response with a 404 status. In this case, there is no need to read the request body and that will speed up the server. The client will get the 404 status code from the first line. The client's logic may work so that it does not read the body in case of a negative status.

Reading and parsing content is time-consuming. Modern frameworks do not do this without the need. They determine by a \verb|Content-Type| header whether to read a body. If the application works with JSON only then for \verb|text/xml| it return an error. The frameworks do the same with the \verb|Content-Length| header, where the body length in bytes is indicated. If the length exceeds the limit, the server will reject the request before reading.

The main parts of a request are \emph{method} and \emph{path}. A path points to a specific resource on a server. Sometimes it means a file relative to a given folder. For example, \verb|/images/map.jpg| will return the file of the same name from \verb|/var/www/static|. File sharing is just one form of the path, among many others. A path may contain the entity number: \verb|/users/9677/profile|. You can configure the server so that requests with the prefix \verb|/internal| and \verb|/public| go to different machines.

A request method means an action that we intend to perform on a resource. The main methods are \verb|GET|, \verb|POST|, \verb|PUT| and \verb|DELETE|, which read, create, update and delete a resource. A \verb|POST /users/| request  means ``create a user'', and a \verb|GET /users/| one~--- ``get a list of users''.

The main response parameter is the status, which is a positive integer. Statuses are grouped by high-order digit. Values from 200 to 299 are considered positive. Such statuses mean that a server has processed a request without errors. For short, this range is denoted as \verb|2xx|.

Codes from the group \verb|3xx| have to do with URL redirection. The address where a new request must be sent to is specified in the header \verb|Location|. Contemporary browsers and clients do this automatically. At the address \verb|http://yandex.ru| we will get an empty document with the header \verb|Location: https://yandex.ru|. The server requires switching from HTTP to HTTPS to ensure a secure connection. We will not even notice this since a browser itself will change the address.

The \verb|4xx| statuses mean that the error seems to have been caused by the client.  The most common status code is 404 (Not Found). If the client sends invalid data, the server will return code 400 (Bad request). If the user doesn't have access rights, they will get code 403.

Group \verb|5xx| of a status code tells about server errors. Mostly, these are errors in code, for example, database failure or insufficient disk space. If the server is under maintenance, it will return code 503. In rare cases, it is down and does not respond to requests.

It is generally accepted that response with a status beyond the \verb|2xx| group means an error. Many HTTP clients throw an exception on a negative response. This is only true on an abstract level. In terms of the protocol, a 404 response is as correct as a 200 one.

\index{HTTP!HEAD}

To reduce the number of actions with the resource, we use other, rarer methods. For example, the HEAD method is used to get meta-information about the entity. Amazon S3 only returns a status and headers with an empty body to a HEAD request. The headers indicate the file type and size, checksum, and modification date. A HEAD request is preferred over GET. Metadata is stored separately from the file, so it accesses faster than disk.

\index{web development!REST}

The method \& resource approach has grown into what is called today \footurl{REST}{https://restapitutorial.com}[REST]. REST proponents distinguish entities and CRUD operations on them (\textbf{C}reate, \textbf{R}ead, \textbf{U}pdate, \textbf{D}elete). The approach is considered proper when the entity is specified via the path, for example, \verb|/users/1|, and the operation~---  by the method. If it's a change request, the data is read from the body with JSON. We will not dwell on REST any longer,
because this is just a set of guidelines, not the perfect and not the only one.

\index{web development!CRUD}

The protocol does not impose REST and other rules. You can work with HTTP in any way that suits your project. An ideal architecture does not ensure success, and vice versa,
success does not mean that everything is perfect under the hood.

\subsection{Framework}

\index{frameworks}

A framework is an abstraction over HTTP. A developer does not read the request byte by byte; someone else's code takes over the task. Instead, we have classes to describe the logic of an application. A typical Python or Java project consists of the following classes.

\verb|Application| is the main project entity; it groups the classes below the rank. \verb|Router| determines which handler to submit the incoming \verb|Request| to. The handler is the class \verb|Handler| with the \verb|.onGet|, \verb|.onPost|, and other methods. They will return an instance of the \verb|Response| class. This is how high-performance frameworks like Django and Rails work. The names and composition of classes are different, but the meaning is the same: an application, router, handler, request, and a response.

\index{frameworks!Django}

Large projects are divided into layers. A transport layer is responsible for exchanging data, a logic layer executes the code without knowing anything about the data source. With this approach, the logic does not depend on the transport, and the latter can be changed any time. For example, a long request can be sent to the task queue. In practice, this is not always the case, since, for various reasons, including haste, the layers might mix.

Clojure projects rely on frameworks. The above principles are also valid for this language.

\section{HTTP in Clojure}

\index{people!James Reeves}
\index{websites!www.booleanknot.com}

Developer \footurl{James Reeves}{https://www.booleanknot.com}[James\\*Reeves] is known for contributing to the Clojure ecosystem.  All projects use his libraries.  At the advent of Clojure, James created the web development standard for the language. The standard is based on a few simple ideas.

Applications can be extremely complex: they rely on third-party services, machine learning, take into account hundreds of facts about clients. But even the most complex application takes a request and returns a response, and therefore it is a function. Skeptics will say the idea isn't new. In Django, a handler is also sometimes not a class,
but a function. The difference is that the handler is not an application yet. It doesn't have a router, middleware, and other abstractions. A handler function is a local option in other programming languages.

\label{http-all-function}

In Clojure, an application remains a function at all levels. A route is a function that accepts a request, looks for a handler, and transfers control to it. Middleware
is also a function that adds logic to the application. Every heavy abstraction (\verb|Application|, \verb|Router|, \verb|Handler| classes) is replaced with a function in Clojure. Functions, unlike classes, comply with each other, so it's convenient.

Another idea is to keep the request and response structure fixed. There should be documents (in addition to code) that describe the fields and their semantics. This is similar to the HTTP protocol: the specification simplifies the code and makes it transferable. It is convenient when different Clojure projects work with the same structures. If the framework adheres to the standard, the community will be more interested in it. It is in a developer's interest to follow the standard.

\subsection{Ring}

\index{libraries!Ring}
\label{ring-jetty}

These ideas were embodied in the \footurl{Ring}{https://github.com/ring-clojure/ring}[Ring] project.
Presently, it is the standard for Clojure web development. The repository contains a description of the request and response and the basic code for working with them. It comes with basic middleware, a Jetty server wrapper, and documentation.

\index{Ring!compatibility}

Over time, the concept of ``Ring compatible framework'' appeared. All Clojure frameworks are Ring-compatible. Ring apps run on Jetty, Immutant, and others platforms with no code changes.

The Ring library is split into separate parts so you can install only the ones you need. Let's list the components that will be needed throughout the chapter:

\begin{itemize}

\item
\verb|ring-core| is a basic set: parameters, cookies, sessions;

\item
\verb|ring-jetty-adapter| starts the server from a function;

\item
\verb|ring/ring-json| is JSON support.

\end{itemize}

Now we can write the first application even without the library. Here you are:

\index{Ring!application}

\label{first-handler}


\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn app [request]
 (let [{:keys [uri request-method]}
       request]
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (format "You requested %s %s"
           (-> request-method
               name
               .toUpperCase)
           uri)}))
\end{clojure}

\else

\begin{clojure}
(defn app [request]
  (let [{:keys [uri request-method]} request]
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (format "You requested %s %s"
                   (-> request-method name .toUpperCase)
                   uri)}))
\end{clojure}

\fi

Our application reads the path and method of the request and builds the response.  It has status code 200 (OK). We have set the header with type — plain text. The \verb|:body| field contains the string that we get with the \verb|format| function. Since \verb|app| is a function, let's call it using different requests:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(app {:request-method :get
      :uri "/index.html"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested GET /index.html"}

(app {:request-method :post
      :uri "/users"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested POST /users"}
\end{clojure}

\else

\begin{clojure}
(app {:request-method :get :uri "/index.html"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested GET /index.html"}

(app {:request-method :post :uri "/users"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested POST /users"}
\end{clojure}

\fi


Maps are everywhere, and it is not clear what will be in the browser. Let's run the application as the server. It takes the application, parameters and starts a complex process. The server listens to the specified port and reads bytes. It builds the request map from binary data. In a separate thread, the server calls the application with it. Now we can get the response map. The server translates the map into bytes and writes to the client's remote port. The cycle repeats for each request.

\index{Ring!Jetty}
\index{libraries!Jetty}

Let's add dependencies to the project:

\begin{clojure}
[ring/ring-core "1.7.1"]
[ring/ring-jetty-adapter "1.7.1"]
\end{clojure}

Let's start the server:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[ring.adapter.jetty
           :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
\end{clojure}

\else

\begin{clojure}
(require '[ring.adapter.jetty :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
\end{clojure}

\fi

Here's what happened. We have added the \verb|run-jetty| function to the current module. It accepts the application and the option maps. The \verb|join?| key determines whether the current thread will be blocked until the end of server operation. Setting \verb|false| will start the server in the background. You need to put the output of \verb|run-jetty| to a variable and later call the \verb|.stop| method to stop the server:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(def server
  (run-jetty app {:port 8080
                  :join? false}))

;; after a while
(.stop server)
\end{clojure}

\else

\begin{clojure}
(def server
  (run-jetty app {:port 8080 :join? false}))

;; after a while
(.stop server)
\end{clojure}

\fi

If the flag is ``true''{}~--- as it was in the first case~--- the main thread will be running unless we'll stop the server. To do this, you need to press \verb|Ctrl+C|. While the server is running, let's open a browser at \verb|http://localhost:8080|. Now we can see the text ``You requested GET /''.  Let's change the path to \verb|/hello| or
\verb|/path/to/file.txt| then the message will be different.

\section{Requests and Responses}

We have written the application that prints a method and path for all requests. In addition to these fields, a request contains the server port and address, a parameter string, a protocol type, headers, and a body. All of them together are an immutable map with the \verb|keyword| type keys. You can see a full description of the request and response in the repository at \footurl{GitHub}{https://github.com/ring-clojure/ring/blob/master/SPEC}[Ring spec][-9mm].
In other programming languages, a type is called a token or tag.

\index{HTTP!headers}

We must pay attention to request fields \verb|:headers| and \verb|:body|. Headers are an immutable map, but its keys are not keywords but strings. Such a map does not work with splitting by \verb|:keys|. Below we will see that the \verb|host| variable will be equal to \verb|nil|:

\index{syntax!:keys (splitting)}

\begin{clojure}
(defn some-handler
  [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    ...))
\end{clojure}

\index{syntax!:strs (splitting)}

To extract the headers properly, we'll use \verb|:strs|:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host
                user-agent]} headers]
    ...))
\end{clojure}

\else

\begin{clojure}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host user-agent]} headers]
    ...))
\end{clojure}

\fi

\noindent or the \verb|get| function with the string:

\begin{clojure}
(get headers "host") ;; "127.0.0.1"
\end{clojure}

\index{headers!Content-Type}

The header name is always in lowercase. In HTTP, \verb|Content-Type| and \verb|content-type| mean the same thing, but Java (and thus Clojure) are case sensitive. Ring converts headers to lowercase to avoid confusion.

Header values are also strings. The standard defines some types of headers, but Ring keeps them untouched with no type inference. For instance, a \verb|Content-Length| header field indicates the length of a body in bytes. Modern frameworks cast it to an integer and put it in a separate field. By default, Ring does nothing like this, but it's easy to fix.

Newbies sometimes forget that header keys are strings. In this case, an error appears, and instead of the correct value, \verb|nil| is returned:

\begin{clojure}
(get headers :host) ;; nil
\end{clojure}

We can process headers, changing the type of keys. It's ok for one occasion. But if every handler does this, there will be extra work. We should change the application so that the preprocessed headers will come to the function. The technique is called middleware, and we'll look at it below.

\index{classes!InputStream}

A request field \verb|:body| is optional. According to HTTP, there may be no body. We need to pay attention to its type: this is not a string, but the \verb|java.io.InputStream| input stream. A stream is a data source that is read once. Ring does not read a stream by default. It's up to you  whether it should do it or not.

\index{headers!Content-Length}

Reading and parsing a body is a complex operation. An application determines the type and length of document by headers and reads the required number of bytes. Then it unmarshals JSON/XML data from them. It is technically possible to send a JSON document specified as the \verb|text/xml| type. The server must be prepared for such scenarios.

The body is most easily read as a string with the \verb|slurp| function:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn handler [request]
 (let [content (-> request :body slurp)]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body (format "The content was %s"
                 content)}))
\end{clojure}

\else

\begin{clojure}
(defn handler [request]
  (let [content (-> request :body slurp)]
    {:status 200
     :headers {"content-type" "text/plain"}
     :body (format "The content was %s" content)}))
\end{clojure}

\fi

Fresh web applications are increasingly less working with text, replacing it with JSON data. We'll look at how to make Ring work with this format later.

\index{Ring!request body}

Ring request is a map with the \verb|:status|, \verb|:headers|, and \verb|:body| fields:

\begin{itemize}

\item
\verb|:status| is an integer, a sign of success or failure. We discussed the semantics of statuses at the beginning of the chapter;

\item
\verb|:headers| are response headers where keys are string values:

\index{headers!Location}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
{:status 302
 :headers
   {"content-length" 0
    "location" "/new/page.html"}}
\end{clojure}

\else

\begin{clojure}
{:status 302
 :headers {"content-length" 0
           "location" "/new/page.html"}}
\end{clojure}

\fi

\item
\verb|:body| is a response body. Like a request body, this body may also be missing. Usually, it is a string, but it might be a file, resource, or stream.

\end{itemize}

\section{Routes}

\index{Ring!routes}

We ran our app and tested it in the browser. For any request, it returns text with slight differences. In practice, we build an application from handlers, any of which solves a specific task. Each handler receives incoming requests according to the rules. One calls it routing.

There is no routing class in Clojure and Ring. It's a function that plays its role, takes handlers, and returns the application. It accepts a request and selects the required handler, depending on the method and path. The application then calls it with a request and returns a response.

\index{HTTP!404}

Let's imagine that at the address \verb|/| we would like to see the name of the website, and by~\verb|/hello| a greeting. Other addresses should return \verb|404 Page not found|. Now we will write the handlers:

\begin{clojure}
(defn page-index [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defn page-hello [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Hi there! Keep trying!"})

(defn page-404 [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
\end{clojure}

We can run each handler as a server and open it in~a~browser. Now we must form them into a single whole.

\subsection{Naive approach}

Let's do the simplest thing that comes to mind. We will write a handler that finds the route manually. To do this, we'll check the path with the \verb|case| operator:

\begin{clojure}
(defn app [request]
  (let [{:keys [uri]} request]
    (case uri
      "/"      (page-index request)
      "/hello" (page-hello request)
      (page-404 request))))
\end{clojure}

The function's response depends on the \verb|:uri| request field. Now we can run the application in a browser and check for different addresses. This approach is naive, but it works.

The function has its flaws. We ignored the request methods: \verb|GET/users| and \verb|POST/users| ones differ in meaning. We compared the paths without considering parameters. With correct routing, paths \verb|/users/1| and \verb|/users/99| come to one handler with a different \verb|id| parameter. The code turned out to be noisy. Rules must declaratively specify routes.

Libraries solve these and other problems. We'll look at Compojure and Bidi. Both of them build routes, but their approaches are orthogonal.

\subsection{Compojure}

\label{compojure}

\index{libraries!Compojure}

The \footurl{Compojure}{https://github.com/weavejester/compojure}[Compo-\\*jure] library provides macros for describing routes. Macros are like a rules table.
Let's add a dependency to the project:

\begin{clojure}
[compojure "1.6.1"]
\end{clojure}

Here you are: it's our Compojure app. It is cleaner and shorter than what we wrote at the beginning.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[compojure.core
           :refer [GET defroutes]])

(defroutes app
  (GET "/" request
    (page-index request))
  (GET "/hello" request
    (page-hello request))
  page-404)
\end{clojure}

\else

\begin{clojure}
(require '[compojure.core :refer [GET defroutes]])

(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
\end{clojure}

\fi

Let's figure out what we got at the output. The \verb|app| variable is the function that accepts the request. We have defined it not through \verb|def| or \verb|defn| but with
the \verb|defroutes| macro. It builds the router function and binds it to the \verb|app| variable. Using macros reduces the amount of code.

The name of the variable is followed by the rules. The syntax of a rule is \tuple{method, path, request, expression}.
The \verb|GET| macro defines the first two rules. They read like this:
if the method equals \verb|GET| and the path equals \verb|"/"|, then return \verb|(page-index request)| for the\verb|request| request.

\index{macros!defroutes}

The rule is assembled into a function that accepts the request. The function checks if the method and path of the request match the given ones. If they do, the function will calculate the \verb|(page-index request)| expression and return the result.

The \verb|defroutes| macro wraps rules in serial search. At each step, it takes another rule and applies a request to it. The first non-\verb|nil| value will be the answer to the current request.

What happens if no rules fit the request? The \verb|nil| result will cause a server error. To avoid \verb|nil|, let's add another rule that will always work. This is the\verb|page-404| function — its result is independent of the request. This way, we ensure that we receive a 404 response and not a type error, even if the request does not match the first two rules.

This is how routing works in Compojure. An application consists of separate handlers. Using macros \verb|GET| and \verb|POST|, they are wrapped in rules. The rule builds a function that verifies that the method and path match. If this is true, we will receive a call to the request handler.

\subsection{Advanced Features}

We have identified the problem: the rules \verb|GET /users/1| and \verb|GET /users/99| are the handler with a parameter. We'll write it like this:

\index{macros!GET}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(GET "/users/:id" [id :as request]
    (page-user request))
\end{clojure}

\else

\begin{clojure}
(GET "/users/:id" [id :as request] (page-user request))
\end{clojure}

\fi

Let's pay attention to the colon before \verb|id| and square brackets in the middle.
The part of the path with a colon indicates a parameter. At the time of the request, Compojure will place it in the \verb|params| map.

Suppose a \verb|page-user| page will show the first and last name of the user by the number from the path. The \verb|get-user-by-id| conditional function will return the user's map by number. Now let's look up the first and last name in the map and return a string.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn page-user [request]
   (let [user (-> request
                  :params
                  :id
                  get-user-by-id)
         {:keys [fname lname]} user]
     {:status 200
      :body (format "User is %s %s"
                    fname lname)}))
\end{clojure}

\else

\begin{clojure}
(defn page-user [request]
  (let [user (-> request :params :id get-user-by-id)
        {:keys [fname lname]} user]
    {:status 200
     :body (format "User is %s %s" fname lname)}))
\end{clojure}

\fi

Compojure solves the problem of nested paths. Next, we will consider a product accounting application. At \verb|/content/order/1/view| the product card opens. The \verb|/content/order/1/edit| page shows the edit form for this product. To update it, you need to submit the form along the same path, but using the POST method.

The rules overlap. We will use the \verb|context| macro to avoid repetition:

\index{macros!context}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(context "/content/order/:id" [order-id]
  (GET  "/view" request
        (order-view request))
  (context "/edit" []
    (GET  "/" request
          (order-form request))
    (POST "/" request
          (order-save request))))
\end{clojure}

\else

\begin{clojure}
(context "/content/order/:id" [order-id]
  (GET  "/view" request (order-view request))
  (context "/edit" []
    (GET  "/" request (order-form request))
    (POST "/" request (order-save request))))
\end{clojure}

\fi

Rules in \verb|context| inherit parameters from a higher level. So the \verb|order-view|, \verb|order-form| and \verb|order-save| handlers will get the \verb|:order-id| parameter.

By now, as a response, we have written in the rules something like \verb|(some-handler request)|. Sometimes we know the response in advance, so it makes no sense to write it as a function. Let's have a look at this approach using the \verb|healthcheck| handler as an example.

Today's apps are running in containers and cloud services.  A special service polls the application to check if it is working or not. An easy way to do this is to send a \verb|GET| request to the application at \verb|/health| and check the status. The body and headers of the response don't matter.

We will put the response into the rule to avoid creating a new handler \verb|(page-health request)|:

\index{macros!ANY}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(ANY "/health" _
     {:status 200 :body "ok"})
\end{clojure}

\else

\begin{clojure}
(ANY "/health" _ {:status 200 :body "ok"})
\end{clojure}

\fi

We can make it easier: Compojure covers a case where an expression is a string. It becomes the body of a positive response:

\begin{clojure}
(ANY "/health" _ "ok")
\end{clojure}

\subsection{Routing with Bidi}

\index{orgainsations!JUXT}
\index{libraries!Bidi}

The \footurl{Bidi}{https://github.com/juxt/bidi}[Bidi] library builds routes differently. It relies on data: lists and maps. The method consists of several steps.

In the first step, we will declare the route tree. It is a structure of vectors and dictionaries according to special rules. Each of our tags corresponds to a leaf node of the tree. A special function takes the tree and a request. It looks for a branch node of the tree that fits the method and path of the request. If the function finds a branch, it returns the tag and path parameters  of the branch. For example, \verb|{:route :show-user :route-params: {:id 1}}|.

\index{middleware}

In the second step, we will write middleware, i.e., an intermediate request handler. It accepts a request, adds a tag to it, and passes further down a chain.

The third step is to add a request handler. It is not a function but a multi-method.
Its dispatcher function returns a tag. A method with the \verb|:default| tag will return response \verb|404 |, and that with the \verb|:show-user| tag will return a user page and so on.

At first, the scheme may seem complicated. But once set up, it is easy to scale up.  If we want the server to pick up a new path, we'll add a branch node to the tree and extend the multi-method.

\index{libraries!Bidi}

Let's rewrite the example from the beginning of the chapter to the Bidi approach. Now we'll add a dependency:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
;; project.clj
[bidi "2.1.5"]

;; namespace
(:require [bidi.bidi :as bidi])
\end{clojure}

\else

\begin{clojure}
[bidi "2.1.5"]                  ;; project.clj
(:require [bidi.bidi :as bidi]) ;; namespace
\end{clojure}

\fi

Let's start with the route tree. The option with \verb|page-index|, \verb|page-hello| and \verb|page-404| looks like that:

\begin{clojure}
(def routes
  ["/" {""      :page-index
        "hello" :page-hello
        true    :not-found}])
\end{clojure}

\index{functions!match-route}

We need to check the search for a path along this tree. The \verb|match-route| function takes routes, a path, and returns a map with a tag:

\begin{clojure}
(bidi/match-route routes "/hello")
{:handler :page-hello}

(bidi/match-route routes "/test")
{:handler :not-found}
\end{clojure}

\index{functions!match-route}

Let's add the tag to the request. We can do it in one step with the \verb|match-route*| function. This alternative of the \verb|match-route| function accepts an accumulating map, where it is replaced by a request.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route*
    routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
\end{clojure}

\else

\begin{clojure}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route* routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
\end{clojure}

\fi

We can see the \verb|match-route*| function returned the initial request and added the \verb|:handler| field to it. Let's wrap the code in a middleware. After having got the request, a new handler will add the \verb|handler| field to it and call the original handler.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn wrap-handler [handler]
  (fn [req]
    (let [{:keys [uri]} req
           req* (bidi/match-route*
                  routes uri req)]
      (handler req*))))
\end{clojure}

\else

\begin{clojure}
(defn wrap-handler [handler]
  (fn [request]
    (let [{:keys [uri]} request
          request* (bidi/match-route* routes uri request)]
      (handler request*))))
\end{clojure}

\fi

We haven't applied middleware techniques yet, but we have to do it now. Below we will look in detail at how it works and why it is so important.

Let's quickly check \verb|wrap-handler|. For convenience, we'll wrap the \verb|identity| function, which will return the argument passed to it:

\begin{clojure}
(def wrapped (wrap-handler identity))

(wrapped {:request-method :get
          :uri "/hello?foo=42"})

{:request-method :get
 :uri "/hello?foo=42"
 :handler :page-hello}
\end{clojure}

\index{multi-methods!multi-handler}

The request handler is a multi-method. The dispatcher function is just the \verb|:handler| key.

\begin{clojure}
(defmulti multi-handler
  :handler)

(defmethod multi-handler :page-index
  [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defmethod multi-handler :not-found
  [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
\end{clojure}

Now we'll wrap \verb|multi-handler| in middleware to get the final application. You should run your web server and check the result in the browser.

\begin{clojure}
(def app (wrap-handler multi-handler))
\end{clojure}

It was a simple routing scenario with Bidi. Now let's take a look at the products, their views, and changes. The new tree looks like that:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(def routes
  [["/content/order/" :id]
   {"/view" {:get  :page-view}
    "/edit" {:get  :page-form
             :post :page-save}}])
\end{clojure}

\else

\begin{clojure}
(def routes
  [["/content/order/" :id] {"/view" {:get  :page-view}
                            "/edit" {:get  :page-form
                                     :post :page-save}}])
\end{clojure}

\fi

In this version, leaf nodes are not tags, but maps. The key of each map is a method, and the value is a tag. The \verb|GET /content/order/1/edit| request resolves into
the \verb|:page-form| tag, and POST with the same address~--- into the \verb|:page-save| tag.  At the \verb|wrap-handler| step the request will get the \verb|:route-params| field. In our case, this is the \verb|{:id "1"}| map.

\index{languages!HTML}

Let's extend the multi-method with HTML pages. \verb|Page-view| should find an item by a number and build the corresponding HTML page. If the product is missing, response 404 ``Not Found'' should be returned.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (some->
                   request
                   :route-params
                   :id
                   get-order-by-id)]
    {:status 200
     :headers {"content-type"
               "text/html"}
     :body (render-order-page
             {:order order})}
    page-404))
\end{clojure}

\else

\begin{clojure}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (some-> request
                         :route-params
                         :id
                         get-order-by-id)]
    {:status 200
     :headers {"content-type" "text/html"}
     :body (render-order-page {:order order})}
    page-404))
\end{clojure}

\fi

The \verb|:page-form| page builds an edit form. It differs from a view form by the HTML template. It's more difficult to update an item: you need to select request fields and write them to a database. For the sake of shortness, let's omit the validation:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defmethod multi-handler :page-save
  [req]
  (let [{:keys [params route-params]} req
        {order-id :id} route-params
        params (select-keys params
                 [:title :description
                  :price])
        location (str "/content/order/"
                   order-id "/view")]
    (jdbc/update! *db* :orders
      params ["id = ?" order-id])
    {:status 302
     :headers {"Location" location}}))
\end{clojure}

\else

\begin{clojure}
(defmethod multi-handler :page-save
  [request]
  (let [{:keys [params route-params]} request
        {order-id :id} route-params
        fields [:title :description :price]
        params (select-keys params fields)
        location (format "/content/order/%s/view" order-id)]
    (jdbc/update! *db* :orders params ["id = ?" order-id])
    {:status 302
     :headers {"Location" location}}))
\end{clojure}

\fi

\index{HTTP!redirection}

Please note: we respond to data changes not with a page, but with a  \emph{redirection} to that page. If the page came in response to a POST request, then when it updates, the browser will send the form again. As a result, the server may behave unpredictably. The redirection option solves the problem: a browser will load a page with GET, and there will be no side effects when updating.

\subsection{Choosing between Compojure and Bidi}

It's easier for a Clojure newbie to get started with Compojure. The library has decent documentation with examples. Compojure and Ring were written by the same author, so the projects are close and complementary.

Bidi routes are difficult to understand: they are wordy and not intuitive. Vectors and maps can be easily confused in them. On the other hand, multi-methods have their advantages. The code becomes linear and an application is easier to extend.

If your project is small, Compojure is the way to go. When the project is complex and there are increasingly more routes, consider moving to Bidi.

\section{Middleware}

\index{middleware}

Above we mentioned middleware and even floated a trial balloon: we've written \verb|wrap-route|. Now let's have a closer look at the middleware. This is the most important section in the chapter.

In programming, this is the name for the intermediary code. It performs preliminary steps before the main one: casts types, checks access rights and so on.

\label{decorator}

\index{decorators}

The decorator pattern is a type of middleware. A decorator is the \verb|A| function that takes the \verb|B| function and returns the \verb|C| function. One says that \verb|A| decorates \verb|B|. While running, \verb|C| calls \verb|B| and modifies it. For example, it makes additions to input or output of the \verb|B| function.

Let's look at some simple decorators. The \verb|With-echo| one adds a side effect to the function — it prints the arguments and the result.

\begin{clojure}
(defn with-echo [func]
  (fn [& args]
    (apply println "The args are" args)
    (let [result (apply func args)]
      (println "The result is" result)
      result)))
\end{clojure}

Here's how to use it:

\begin{clojure}
(def +echo (with-echo +))
(+echo 1 2 3)
;; The args are 1 2 3
;; The result is 6
6
\end{clojure}

\index{exceptions!try}
\index{exceptions!catch}
\index{macros!with-catch}

The \verb|With-catch| decorator wraps a function in the \verb|try/catch| method. If an exception occurs, the result will be its object.

\begin{clojure}
(defn with-catch [func]
  (fn [& args]
    (try
      (apply func args)
      (catch Throwable e
        e))))
\end{clojure}

\index{languages!Python}
\index{frameworks!Django}

We have already seen a Ring request. It does not have fields that you used to in other languages. For example, Django's \verb|HttpRequest| class contains the \verb|.params| property. It is a parameter map from an address string or request body.

A Ring request carries only base information. Why aren't there such things in it? It's because not every application needs them. Just imagine if Ring parses the address string and body for every request. This is convenient for a developer, but slows down the code. The request might not require these parameters, but the server will spend processing time on them.

The same with body parsing~--- it's expensive. Suppose we have got a large JSON document, read it, and  then found out the user has no write access. We should have checked the rights before reading!

Middleware is vital in Ring. Request parameters, sessions, cookie files, access rights: any of them may be a function that returns a function. You don't have to write all middleware modules from scratch: Ring contains the most essential ones, you just need to connect them. Let's look at the main types of middleware and how they work.

\subsection{Request parameters}

\label{ring-params}

\index{HTTP!parameters}

HTTP provides data in the address string. These are pairs like \verb|"name=John&city=NY"| after the question mark. In the code, they become a map \verb|{:name "John" :city "NY"}|.

In POST requests, parameters are placed in the body. The reason for this is security and a length limit of addresses. The address length may not exceed 2048 bytes, while there are no such restrictions for the request body. Logins and passwords may not be sent in the address, otherwise they remain in the logs and browser history.

\index{modules!ring.middleware.params}
\index{HTTP!parameters}

The \verb|wrap-params| function from the \verb|ring.middleware.params| module changes a handler as follows. A request passed to it gets fields:

\begin{itemize}

\item
the \verb|:query-params| map of address parameters;

\item
the \verb|:form-params| map of the request body;

\item
\verb|:params|~--- their combination.

\end{itemize}

Let's say \verb|app| is your web application. We must pass it to \verb|wrap-params| to get a wrapped version. The output will be the final application.

\index{middleware!wrap-params}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[ring.middleware.params
           :refer [wrap-params]])
(def final-app (wrap-params app))
\end{clojure}

\else

\begin{clojure}
(require '[ring.middleware.params :refer [wrap-params]])
(def final-app (wrap-params app))
\end{clojure}

\fi

To avoid confusion in the names, follow the rules. Name the original application \verb|app-naked| or \verb|app-raw| and the final one just \verb|app|.

\begin{clojure}
(def app (wrap-params app-naked))
\end{clojure}

We can modify the app so that it takes parameters into account. For example, the \verb|who| parameter contains the name of the person to be greeted:
\verb|/hello?who=John|. We can get to it like this:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn page-hello [req]
  (let [who (get-in req [:params "who"])]
    ...))
\end{clojure}

\else

\begin{clojure}
(defn page-hello [request]
  (let [who (get-in request [:params "who"])]
    ...))
\end{clojure}

\fi

\index{classes!Keyword}

Please, note that the keys are strings. The address is a string, and the algorithm cuts it into pieces. Clojure encourages us to use map keys as keywords. Let's make these corrections. Ring comes with middleware that converts \verb|:params| into a convenient form. Thanks to it, the keys will be cast to the keyword type.

\index{middleware!wrap-keyword-params}

\begin{clojure}
(require '[ring.middleware.keyword-params
           :refer [wrap-keyword-params]])

(def app (wrap-keyword-params
           (wrap-params app-naked)))
\end{clojure}

\index{macros!\arr}

Since a keyword is a function, a parameter can be reached with an arrow operator. Some prefer this way instead of the \verb|get-in| one.

\begin{clojure}
(-> request :params :who)
(get-in request [:params :who])
\end{clojure}

\subsection{Stack middleware}

A typical application includes about ten middleware components. If you wrap them all, you'll get a ladder:

\begin{clojure}
(def app
  (wrap-something-else
    (wrap-current-user
      (wrap-session
        (wrap-keyword-params
          (wrap-params app-naked))))))
\end{clojure}

\index{nesting}

If you add one more component in the middle, it cascades down the elements below. To avoid nesting, let's make the structure linear. The arrow operator will help:

\index{clojure.core!\arr (arrow operator)}

\begin{clojure/lines}
(def app
  (-> app-naked
      wrap-params
      wrap-keyword-params
      wrap-session
      wrap-current-user
      wrap-something-else))
\end{clojure/lines}

\index{middleware!stack}

In a compiled application the composition will turn into the first option, so the program logic is left intact. Now we have an easily maintainable list. We'll call it
the middleware \emph{stack}.

An arrow-type entry has a feature. Without looking below, can you guess the order in which middleware elements will be executed? The right answer is the bottom-up direction for a request and top-down for a response. Let's take a closer look.

\index{middleware!order}

First, the request will go to \verb|wrap-something-else|. Its internal code will call the handler from \verb|wrap-current-user|. Its internal handler is the output of \verb|wrap-session|, etc. The peak of the rise will be \verb|app-naked|. The main logic of the application will work here.

Now the response will go down in reverse order. It will first go through \verb|wrap-params| and \verb|wrap-keyword-params|. These two middleware components won't change the response and will just return it. \verb|Wrap-session| and \verb|wrap-current-user| will probably add new headers. \verb|Wrap-something-else| will perform the last step. The cycle is over.

\index{languages!Python}

Think of the stack as of climbing and descending a mountain. The middleware in the Python-based Django framework operates similarly where classes, not functions, play the role of middleware, but the order is the same.

The order of middleware components is sometimes critical. Some of them use data from previous middleware. Let's take a look at the familiar \verb|wrap-params| and
\verb|wrap-keyword-params|. The latter looks for the \verb|params| request field and casts the type of keys. Each has its responsibilities — one middleware component prepares the data, the other improves it. So, we must \verb|wrap-keyword-params| put strictly after \verb|wrap-params|.

\index{middleware!order}

% TODO \clojureinline

Now let's look at the line \verb|(def app ...)| form above. An \textbf{error} has crept into it. The request goes from bottom to top — therefore, \verb|wrap-keyword-params| will be executed first \coderef{4}. It will try to find \verb|:params| in the request, yet with no success. Then \verb|wrap-params| should work \coderef{3}. It will fill out the field with a map from the address string. As a result, the keys of \verb|:params| will become strings. We need to swap \verb|wrap-params| with \verb|wrap-keyword-params|.

Wrong middleware order costs hours of debugging. But there is a trick: if two or more middleware components are dependent on each other, we can join them. The \verb|comp| function takes functions and returns a super function that applies them to an argument. So we will write a smart parameter wrapper:

\index{clojure.core!comp}
\index{functions!composition}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(def wrap-params+
  (comp wrap-params wrap-keyword-params))
\end{clojure}

\else

\begin{clojure}
(def wrap-params+ (comp wrap-params wrap-keyword-params))
\end{clojure}

\fi

Let's see why the arguments of \verb|comp| go in that order. We'll designate them \verb|foo| and \verb|bar| and rewrite the expression several times. Each column contains the same function, written differently.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(comp foo bar)
\end{clojure}

\splitter

\begin{clojure}
(fn [x]
  (foo (bar x)))
\end{clojure}

\splitter

\begin{clojure}
(fn [x] (-> x
            bar
            foo))
\end{clojure}

\else

\noindent
\begin{tabular}{ @{}p{3.2cm} @{}p{3.5cm} @{}p{3.5cm} }

\begin{clojure}
(comp foo bar)
\end{clojure}

&

\begin{clojure}
(fn [x]
  (foo (bar x)))
\end{clojure}

&

\begin{clojure}
(fn [x] (-> x
            bar
            foo))
\end{clojure}

\end{tabular}


\fi

If \verb|x| in the third column is an application, and \verb|foo| and \verb|bar| are middleware elements, then everything becomes clear. During request, they work in reverse order, so \verb|foo| will run before \verb|bar|. Thus, in place of \verb|foo| must be \verb|wrap-params|, and instead of \verb|bar| — \verb|wrap-keyword-params|. If we put them in the first column, we will get what we have written down at the beginning.

A plus at the end of name means it is an improved version of \verb|wrap-params|. In the stack, let's replace \verb|wrap-params| and \verb|wrap-keyword-params| with their
plus versions. The chain has become shorter, and the parameter logic has been defined separately.

Next, we'll talk about other useful middleware components: cookie, sessions, and JSON.

\subsection{Cookie}

\index{HTTP!cookie}

HTTP cookies are small pieces of information. There should be an convention between a server and a browser on how to store and transfer them. If the server sets cookies,
the browser will remember them for this website. Next time the browser will send them to the server automatically. This will continue until they expire or are deleted. Both a server using the header and a user in browser settings can delete cookies.

The simplest case of using cookies is determining if the user has already visited the website. The application first looks for cookies named \verb|visited| in the request. If they are not found, the server will add a header:

\begin{http}
Set-Cookie: visited=true;
\end{http}

After getting cookies, the browser will add them to all requests to the server. A outgoing header looks the same, but without the \verb|Set-| part in the name. The application checks: if the value is true, the client has already been on the website. This affects ad impressions, pop-ups, and so on.

Technically, a cookie is a long header with fields and values separated by semicolons. The \verb|wrap-cookie| middleware makes it easier to work with this header. In the request, we should get the \verb|:cookies| map, in which there are two levels with names and attributes. To send new cookies to the client, add a modified copy of the map to the response. Ring will create the \verb|Set-Cookie| header from it.

The \verb|page-seen| page below checks if we see it for the first time.

\index{modules!ring.middleware.cookies}

\ifx\DEVICETYPE\MOBILE

\begin{clojure/lines}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path ["seen" :value]
        seen? (get-in cookies
                      seen-path)
        cookies* (assoc-in cookies
                   seen-path true)]
    {:status 200
     :cookies cookies*
     :body
     (if seen?
      "Already seen."
      "The first time you see it!")}))

(def app (-> page-seen
             wrap-cookies))
\end{clojure/lines}

\else

\begin{clojure/lines}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path ["seen" :value]
        seen? (get-in cookies seen-path)
        cookies* (assoc-in cookies seen-path true)]
    {:status 200
     :cookies cookies*
     :body (if seen?
             "Already seen."
             "The first time you see it!")}))

(def app (-> page-seen
             wrap-cookies))
\end{clojure/lines}

\fi

Note: a variable with an asterisk at the end means a new version of the original variable \coderef{8}. For example, the same map, but it has a new key. Instead of an asterisk, one sometimes puts a stroke. The \verb|cookies*| variable means new cookies based on old ones.

\index{middleware!wrap-keyword-cookie}

Similar to \verb|:params|, cookie keys are strings. If we replace \verb|"seen"| with \verb|:seen|, we will make an error and get \verb|nil|. Ring has no analog for \verb|wrap-keyword-cookie|, but such a wrapper is easy to write by yourself. Below we will show the way for headers.

Run the application in a browser. After the page is updated, the caption will change to Already seen. It will remain even after the server restart because the browser stores the flag. Only after clearing the cookies, you will see The first time you see it. To complete the experiment, open a private tab or another browser.

\index{security!HTTP}
\index{HTTP!security}

Cookies are closely related to security. Make sure they are secure against theft and do not reveal secret data (passwords, access keys).

The \verb|:http-only| and \verb|:secure| attributes can significantly reduce the risk of theft. The former means that cookies cannot be accessed from JavaScript. This will protect you from malicious scripts that read cookies and send them to someone else's server.  Now open the developer console in your browser and execute the expression:

\begin{js}
document.cookie
"ring-session=<uuid>; seen=true"
\end{js}

\noindent Modify the \verb|cookies*| variable so that \verb|seen| has an attribute:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(let [cookies*
      (assoc cookies "seen"
        {:value true
         :http-only true})]
  ...)
\end{clojure}

\else

\begin{clojure}
(let [cookies* (assoc cookies "seen"
                      {:value true :http-only true})]
  ...)
\end{clojure}

\fi

Now JavaScript will not see the value of \verb|seen|:

\begin{js}
document.cookie
"ring-session=<uuid>"
\end{js}

The \verb|:secure| attribute means that cookies are only transmitted over a secure connection using SSL. You can neglect it during development, but it is a must when your application goes into production. Apps without SSL are insecure, and browsers point this out to users.

We will not dwell on web security any longer: the topic is too broad and deserves a separate book.

\subsection{Sessions}

\index{HTTP!sessions}

HTTP does not imply relationship between two requests. A server doesn't care if they come from neighboring machines or different continents. Time is also not an indicator: someone reads the page for an hour, while others update every minute.

The developers have successfully found a way out. Even if clients are sitting at the same table, the application will give them cookies with a long random string. A browser adds cookies to requests, and a server distinguishes the clients. The technique was called \emph{a session}.

A session refers to the values associated with the current user. For example, what language he chose and products viewed, what is the state of the widgets. Note that users are not necessarily logged in. They may be anonymous, but the server distinguishes their requests from the others.

\index{middleware!wrap-session}

\verb|Wrap-session| is a complicated middleware component that supplements a request with the \verb|:session| map. Its keys are session fields. To update a session, its new version is written in a response, similar to cookies. Middleware distinguishes between \verb|nil| and no session in the response. If the field is \verb|nil|, the session will be deleted. If there is no key, nothing happens.

\index{databases!Redis}
\index{databases!Memcached}

There are different \emph{backends} of a session (i.e., ways to store it physically). It could be memory, a disk, a database, Memcached or Redis system, or even a cookie. When you choose a backend, consider whether it can run on several machines at the same time. What does happen if every request randomly goes to one of ten machines? Each machine will have a different copy of the session when it is stored in memory. In this case, they behave strangely, and we have to deal with debugging. The same with files: machines don't share them among themselves. A database and Redis are centralized repositories. They guarantee session integrity for all clients.

Interestingly, a cookie-based session also works on many machines. For each request, a browser sends the entire session in headers. In this case, the browser stores it. The session will be lost if the user clears the cookies or starts another browser.

Ring offers two out-of-box session backends: memory and cookies. The repository type is set by the \verb|wrap-session| settings. If you specify nothing, Ring will use memory. You should extend the \verb|SessionStore| protocol to make the session work with Redis or another system.

Next, let's look at an example with a hit counter. We will count how many times the user has visited the site. We keep the session in memory.

\index{modules!ring.middleware.session}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[ring.middleware.session
           :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session
                   :counter (fnil inc 0))
        counter (:counter session*)]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)"
                   counter)}))

(def app (-> page-counter
             wrap-session))
\end{clojure}

\else

\begin{clojure}
(require '[ring.middleware.session :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session :counter (fnil inc 0))]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)" (:counter session*))}))

(def app (-> page-counter
             wrap-session))
\end{clojure}

\fi

You should run the app and open your browser. Update the page, and the message counter will increase with each view. Do the same in another browser. It will be the second session that does not depend on the first. Now make sure the view in the first browser doesn't affect the second one. The data is in memory, so it will be lost when the server is restarted.

\emph{Exercise 1.} Above, we counted the number of views of the entire site. Make a counter to track visits to different pages. For example, the main page \verb|/| was
viewed five times, and \verb|/help| three times. Request parameters do not affect the count.

\emph{Exercise 2.} Since the session is in memory, it will be lost when the server is restarted. Explore the Ring documentation, and make sure that sessions are stored in cookies. After that, restarting will not result in data loss, will it?

\subsection{JSON}

\index{formats!JSON}

JSON format is used to transmit data. Its basic data types are number, string, boolean, and collections of any nesting. JSON has an advantage over XML and INI, where all values are strings. JSON is JavaScript compatible: if a string is passed to the \verb|eval| function, the latter will return a combination of lists and maps. The format has become popular for many reasons, including this one. Today, JSON is one of the most common formats for transmitting data across the Web.

Ring offers a few middleware functions for JSON. For convenience, they were placed in the separate library Ring-JSON. Now we'll add a dependency:

\begin{clojure}
[ring/ring-json "0.4.0"]
\end{clojure}

\index{middleware!wrap-json-response}
\index{HTTP!JSON}

The \verb|wrap-json-response| middleware makes it easy to return JSON data. This function checks the response \verb|:body| field. If it is a collection it will be converted as an encoded string. The \verb|Content-Type| header with the \verb|application/json| type will be added to it.

Let's have a look at the API for reading user info. If we find it by number, we will return a field map. If not, the response will contain the error structure.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn page-data [request]
  (let [user-id (-> request :params :id)
        user (get-user-by-id user-id)]
    (if user
      {:status 200 :body user}
      {:status 404
       :body
       {:error_code "MISSING_USER"
        :error_msg "No such user"}})))
\end{clojure}

\else

\begin{clojure}
(defn page-data [request]
  (let [user-id (-> request :params :id)]
    (if-let [user (get-user-by-id user-id)]
      {:status 200 :body user}
      {:status 404
       :body {:error_code "MISSING_USER"
              :error_message "No such user"}})))
\end{clojure}

\fi

\noindent In both cases, the programmer does not need to encode the data manually; \verb|wrap-json-response| does it.

\begin{clojure}
(require '[ring.middleware.json
           :refer [wrap-json-response]])

(def app (-> page-data
             wrap-params+
             wrap-json-response))
\end{clojure}

Now your should run \verb|app| and switch to browser. Open the Network tab in the developer panel. Pay attention to the request to the server, and especially the response headers and body. If it's JSON, the browser will parse the data and display it as a tree.

The \verb|wrap-json-body| and \verb|wrap-json-params| middleware are used for incoming JSON. Both of them check if a \verb|Content-Type| header equals to \verb|application/json|. If the header meets the condition, they parse the body considering possible exceptions. If a parsing error occurs, we get status 400, and the text <<JSON body malformed>>.

The difference between these middleware functions is where they put data. \verb|Wrap-json-body| replaces the request \verb|:body| field with a data structure. You can see below that the \verb|page-body| handler extracts name and city from \verb|:body|. At this point, the request body is no longer an input stream, but a map. Please note: the \verb|wrap-json-body| middleware takes additional parameters. The flag \verb|:keywords? true| means that the map keys will become keywords.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[ring.middleware.json
           :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app
  (->
    page-body
    (wrap-json-body {:keywords? true})))
\end{clojure}

\else

\begin{clojure}
(require '[ring.middleware.json :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-body
             (wrap-json-body {:keywords? true})))
\end{clojure}

\fi

\index{utilities!cURL}
\index{HTTP!POST}

You will need the special program to send the JSON to a server. You can use the \verb|cURL| utility or the \footurl{Postman}{https://www.postman.com}[Post\-man][-8mm] graphic application.  Let's see an example with \verb|cURL|:

\begin{bash}
curl --request POST
     --header "Content-Type:
                 application/json"
     --data '{"username":"John",
                      "city":"NY"}'
     http://localhost:8080/
\end{bash}

\verb|Wrap-json-params| acts a little differently~--- it writes data to the \verb|:json-params| field. If a map is in the data, it supplements the \verb|:params| field. Why?

Well, the \verb|:params| field is the general accumulator of parameters. Other wrappers~--- like \verb|wrap-params|~--- fill it as well. Some APIs are method-independent and take requests via both GET or POST. That is, the data is either in an address string or in a request body, respectively. We get the same \verb|:params| map, regardless of the approach.

The hybrid method works better because it applies GET for read requests~--- to enable HTTP caching.  Update requests~--- they are never cached~--- are executed
via the POST method.

In other APIs, parameters mustn't be mixed with or replaced by each other. Let's say our service works strictly according to the POST method. To read only JSON data, you should use the \verb|:json-params| or \verb|:body| fields. It depends on your case, which wrapper to prefer~--- \verb|wrap-json-body| or \verb|wrap-json-params|.

\index{middleware!wrap-json-params}

It must be noted that the \verb|:params| field is a map with string-keys. To merge properly, the \verb|wrap-json-params| middleware also leaves the keys as strings. You have to cast keys with \verb|wrap-keyword-params| after the merger.

The \verb|:json-params| field is intended for cases when JSON is not a map, but an array that cannot be merged with \verb|:params|. For this reason, such data is stored in a separate field.

\subsection{Your Own Middleware}

\index{custom!middleware}

Until now, we have used developments from Ring and related libraries. But sooner or later, you will develop your custom middleware. Now we can see examples from real projects.

\subsubsection*{Header Keys}

\index{HTTP!headers}

The wrapper updates the request headers, i.e., transforms keys from strings to keywords. This is done using the \verb|keywordize-keys| function from the \verb|clojure.walk| package. We should cast the type of headers if an app uses them frequently.

\index{modules!clojure.walk}
\index{functions!keywordize-keys}

In responses, header keys must also be strings. If a keyword is specified, Jetty will throw an exception because its code is expecting a string. Let's reverse the action: convert the keys from keywords to strings with the \verb|stringify-keys| function.

\index{functions!stringify-keys}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require
 '[clojure.walk :refer [keywordize-keys
                        stringify-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler
        (update :headers
                stringify-keys))))
\end{clojure}

\else

\begin{clojure}
(require '[clojure.walk :refer
           [keywordize-keys stringify-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler
        (update :headers stringify-keys))))
\end{clojure}

\fi

Further down the stack, the application treats headers like keywords. In the example, we find the \verb|host| header with \verb|:keys| — this would not work for strings. There are also keywords in the response headers. Make sure the browser displays the message in bold because the content type is HTML.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn app* [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    {:status 200
     :headers {:content-type "text/html"}
     :body (str "<h1>Host header:" host
                "</h1>")}))

(def app (wrap-headers-kw app*))
\end{clojure}

\else

\begin{clojure}
(defn app* [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    {:status 200
     :headers {:content-type "text/html"}
     :body (format "<h1>Host header: %s</h1>" host)}))

(def app (wrap-headers-kw app*))
\end{clojure}

\fi

Similarly, you can change the type of keys for the \verb|:cookie| map.

\subsubsection*{Request Identifier}

\index{classes!UUID}
\index{identifier!HTTP}
\index{identifier!UUID}
\index{HTTP!identifier}
\index{headers!X-Request-Id}

By default, a request and response are not related to each other. Sometimes it is difficult to understand which request this response refers to and vice versa. Let's say we saw a response with code 500 in the logs, but which request caused the error? A system must be able to match them.

For this, the \verb|X-Request-Id| header is used. Most often, this is a random UUID — a string of 36 characters. It is called ID for short. If the client did not pass ID with the request, it will be assigned a random one. The same ID will be returned in the response. It is written to the log to build a chain of events.

\index{middleware!wrap-request-id}

Let's write a wrapper for ID. Headers are keywords since \verb|wrap-headers-kw| is higher up the stack.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or
                (get-in request
                        [:headers
                         :x-request-id])
                (str
                  (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers
                     :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc :request-id uuid)
          (assoc-in [:headers
                     :x-request-id]
                    uuid)))))
\end{clojure}

\else

\begin{clojure}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or (get-in request [:headers :x-request-id])
                   (str (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc :request-id uuid)
          (assoc-in [:headers :x-request-id] uuid)))))
\end{clojure}

\fi

\index{clojure.core!get-in}
\index{clojure.core!assoc}
\index{clojure.core!dissoc}

IDs are stored in headers, but duplicated in the request and response \verb|:request-id| field. ID often is used in logs so it is convenient to move it into a variable at the beginning of the function:

\index{logging!HTTP}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn some-handler [req]
  (let [{:keys [params request-id]} req]
    (log/info "Request id: %s"
              request-id)))
\end{clojure}

\else

\begin{clojure}
(defn some-handler [request]
  (let [{:keys [params request-id]} request]
    (log/info "Request id: %s" request-id)))
\end{clojure}

\fi

\subsubsection*{Current user}

\index{HTTP!user}
\index{user}

This wrapper adds the current user into the header. In this case, we are looking for their session number. If the number is found, we read the user ID from the database and add it to the request. The \verb|get-user-by-id| function should return a map or \verb|nil|. The function is wrapped into \verb|(when user-id...)| so as not to access to the database with an empty number.

\index{middleware!wrap-current-user}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request
                      :session
                      :user-id)
          user (when user-id
                 (get-user-by-id
                   user-id))]
      (-> request
          (assoc :user user)
          handler))))
\end{clojure}

\else

\begin{clojure}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request :session :user-id)
          user (when user-id
                 (get-user-by-id user-id))]
      (-> request
          (assoc :user user)
          handler))))
\end{clojure}

\fi

\index{security!session}
\index{HTTP!security}

Middleware functions — which are below in the stack — read the user from the \verb|:user| field of the request (see an example in the next section).

We \emph{might} store a user number in a session~--- this meets the security requirements. It is signed with a private key, so only the server knows how to change it. The user ID does not contain private data. But you must not store passwords and access keys in a session.

\subsection{Stack Interruption}

\index{middleware!interruption}

By now, we have worked with the chain of middleware where each link transfers control to the next one. Sometimes we need to break this chain. For example, we realized that the user has no rights. It makes no sense to continue work — on the contrary, we will break the stack as soon as possible.

\index{HTTP!400}

Middleware often contains conditions. For instance, \verb|wrap-json-params| reads a body only if the \verb|Content-Type| header has a proper type. If the type is wrong, the wrapper will do nothing. If the document gets corrupted due to a network outage, JSON parser will throw an exception. In that case, \verb|wrap-json-params| will not continue the chain. It will return response 400 ``JSON body malformed'', and any middleware below it on the stack won't be called.

Let our application be available only by authorization. With \verb|wrap-current-user| we'll get the current user. The middleware only finds a user but doesn't restrict access. Now we'll add another one:

\index{middleware!wrap-current-user}
\index{middleware!wrap-auth-user-only}
\index{HTTP!authorization}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers
       {"content-type" "text/plain"}
       :body "Sign in to get access."})))
\end{clojure}

\else

\begin{clojure}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers {"content-type" "text/plain"}
       :body "Please sign in to access this page."})))
\end{clojure}

\fi

Moving to the next middleware is conditional. If the user is not logged in, the chain links under \verb|wrap-auth-user-only| will be discarded.

We have already said that a middleware chain is like going up and down a mountain. If a link fails, it’s like we are cutting off the top: we got to the middle, ran into a problem, and turned back. \emph{The rule of thumb} is that the sooner we discover a problem, the less resources we will spend. Therefore, more general checks are placed higher on the stack (or lower in the \arr operator).

\index{errors!HTTP}

Another option for a fork is to catch errors. It is a necessary handler, but it does not come with Ring. Error reactions depend on many factors: it is difficult to take into account all options in one universal handler. Therefore, the wrapper is copied from a project to a project with some changes.

What does happen if an exception is arising while processing a request? There are no hard-and-fast rules on this: each framework behaves differently. One of them can show the stack trace in a browser, and another one returns HTML with debug information. The developers of the third framework decided that it was unsafe to show that data. So an exception is written to the log and a neutral error phrase is returned to a client.

It's up to you to decide what to do with the exception. Below we show a middleware function that catches an error, writes it to the log and returns a stub response:

\index{middleware!wrap-exception}

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn wrap-exception [handler]
  (fn [{:keys [uri request-method]
        :as request}]
    (try
      (handler request)
      (catch Throwable e
        (log/errorf e
          "Error, method %s, path %s"
          request-method uri)
          {:status 500
           :headers
           {"content-type" "text/plain"}
           :body "Sorry, try later."}))))
\end{clojure}

\else

\begin{clojure}
(defn wrap-exception [handler]
  (fn [request]
    (try
      (handler request)
      (catch Throwable e
        (let [{:keys [uri request-method]} request]
          (log/errorf e "Error, method %s, path %s"
                      request-method uri)
          {:status 500
           :headers {"content-type" "text/plain"}
           :body "Sorry, please try later."})))))
\end{clojure}

\fi

\index{logging!HTTP}

The \verb|log/errorf| expression is a macro for writing an error. It takes an exception, a message template, and parameters. It's important to know what the request method and path were, so we'll write them down too. It will be easier for us to analyze logs later.

The higher \verb|wrap-exception| is on the stack, the less likely the exception reaches a user. Ideally, it stands at the top of the chain to catch all exceptions.

Sometimes double catching is used. Errors in different parts of the system require different approaches. It is necessary to know everything about errors in business logic. If a user was unable to buy an item, we should write the entire context that was at the time of purchase. But if a corrupted JSON arrives, this is a technical issue, not related to the business. In this case, the exception is the norm~--- so we won't write it in the log.

To separate business and technical issues, we will place different \verb|wrap-exception| wrappers at the boundaries of the stack. The lowest one wraps \verb|app-naked| and catches exceptions in business logic. Such an error is logged in as much detail as possible. At the top of the stack is another, lighter version of \verb|wrap-exception|.
It suppresses technical problems in the preliminary stages. Its task is to return an adequate response and not to hoard garbage in the log.

\subsection{Middleware out of Stack}

\index{middleware!out of stack}

An interesting scenario is when middleware affects requests along a specific path. What's the drawback of \verb|wrap-auth-user-only|? If we add it to the stack, an anonymous user won't see anything: each request will return code 403. Home page, contact information, login form~--- everything will be unavailable. Who needs such an application?

We should check only a part of the requests. For example, those that start with the word ``account'': \verb|/account/cart|, \verb|/account/orders|, and so on. We should put the wrapper down — at the route level, not on the general stack.

The implementation depends on how we build the routes. Compojure offers a middleware called \verb|wrap-routes|. This middleware takes a rule and \emph{another} middleware. The latter will be called if the rule matches the request. This complicated logic ensures that the middleware is not called until the request matches the rule.

Let's build separate routes with personal information:

\begin{clojure}
(defroutes app-account
  (GET "/cart"    _ "cart")
  (GET "/orders"  _ "orders")
  (GET "/profile" _ "profile"))
\end{clojure}

\noindent Let's mount it to the \verb|/account| prefix and wrap it in an access check.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defroutes app
  (GET "/"     _ "index")
  (GET "/help" _ "help")
  (context "/account" []
    (wrap-routes app-account
                 wrap-auth-user-only)))
\end{clojure}

\else

\begin{clojure}
(defroutes app
  (GET "/"     _ "index")
  (GET "/help" _ "help")
  (context "/account" []
    (wrap-routes app-account wrap-auth-user-only)))
\end{clojure}

\fi

\index{functions!wrap-routes}

Now \verb|wrap-auth-user-only| should only work for paths that start with \verb|/account|. There will be no access check on the home and help pages.

A middleware that takes another middleware is a pretty cool abstraction. If you understand how it works, congratulations: this is a serious milestone.

\section{Files and Resources}

\label{http-files}

Until now, we have returned strings or collections in the response. Now we'll have a look at the case when the data is in a file. Suppose a mobile app requests ATMs and branches addresses. The bank stores this data on the internal network, and the web application does not have access to it. Besides, new branches and ATMs rarely appear, so it is wasteful to access the database for every request. Once a week, the script uploads data to a file and copies it to the server where
the web application is running.

\index{files!upload}
\index{clojure.core!slurp}

The naive solution is to read the file with the \verb|slurp| function and return its contents:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn page-terminals [request]
  {:status 200
   :headers
   {"content-type" "application/json"}
   :body (slurp "terminals.json")})
\end{clojure}

\else

\begin{clojure}
(defn page-terminals [request]
  {:status 200
   :headers {"content-type" "application/json"}
   :body (slurp "terminals.json")})
\end{clojure}

\fi

The disadvantage of this solution is that we are reading the entire file into memory. The larger the file, the more resources we consume. If a client reads data slowly, the data will hang in memory for nothing. We won't start the response until the entire file is in memory. This method is not suitable for large files due to memory consumption. Also, \verb|slurp| reads a string from a file that is not suitable for binaries (images, PDF). In the example below, the browser will receive corrupted content.

\begin{clojure}
(defn app [request]
  {:status 200
   :headers {"content-type" "image/png"}
   :body (slurp "/path/to/image.png")})
\end{clojure}

\index{formats!PDF}
\index{modules!clojure.java.io}

RING allows that the response body is a file, an instance of the \verb|java.io.File| class. For getting a file object, we pass the path to it to a class constructor or the \verb|file| function from the \verb|clojure.java.io| module:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[clojure.java.io :as io])

(defn page-terminals
  [request]
  {:status 200
   :headers
   {"content-type" "application/json"}
   :body (io/file "terminals.json")})
\end{clojure}

\else

\begin{clojure}
(require '[clojure.java.io :as io])

(defn page-terminals
  [request]
  {:status 200
   :headers {"content-type" "application/json"}
   :body (io/file "terminals.json")})
\end{clojure}

\fi

\index{headers!Content-Length}

If the body is a file, the server will serve the content in small chunks as the client reads it. The server automatically adds the \verb|Content-Length| header with file size.

When there are several files, it is tedious to produce a rule for each of them:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defroutes app
  (GET "/terminals.json"
       req (page-terminals req))
  (GET "/departments.json"
       req (page-departments req)))
\end{clojure}

\else

\begin{clojure}
(defroutes app
  (GET "/terminals.json"   request (page-terminals request))
  (GET "/departments.json" request (page-departments request)))
\end{clojure}

\fi

\index{middleware!wrap-file}

You can match the path to a file and its folder. The \verb|wrap-file| middleware is used for this. If the request does not match the main application, this middleware will search for a file in the specified folder.

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[ring.middleware.file
           :refer [wrap-file]])

(def app
  (-> app-naked
      (wrap-file "/var/www/public")))
\end{clojure}

\else

\begin{clojure}
(require '[ring.middleware.file :refer [wrap-file]])

(def app (-> app-naked
             (wrap-file "/var/www/public")))
\end{clojure}

\fi

The \verb|/terminals.json| request will bypass the app, but will be resolved into \verb|/var/www/public/terminals.json| pathname. Over time, you can add other files to this folder and link to them by name: \verb|/manual.pdf|, \verb|/price_2020.xlsx|.

Links to static resources are identified by the \verb|/static| prefix. Besides, files of similar type are grouped in child directories: \verb|/static/img|, \verb|/static/js| and so on. According to the rule, the physical path to the image will be \verb|/var/www/public/static/img/logo.png|.

Besides files, Ring works with JVM resources. They are similar to files, but after building the application, they become part of uberjar. In this case, the application reads resources from itself and not from disk.

The advantage of such resources is that the application does not depend on third-party files. It becomes autonomous and easier to deploy because there is no need to copy static files to the server. On the other hand, there is no way to update resources on demand. If you need to fix a logo or CSS that is included in the resources, you will have to rebuild the project. The similar \verb|wrap-resource| middleware is used for resources:

\index{middleware!wrap-resource}

\begin{clojure}
(require '[ring.middleware.resource
           :refer [wrap-resource]])

(def app (-> app-naked
             (wrap-resource "public")))
\end{clojure}

By analogy with \verb|wrap-files|, it takes a path, relative to which we need to search for resources. Everything we said about prefixes is also valid for resources. For the \verb|/static/img/logo.png| link to lead to the required resource, it must be at \verb|resources/public/static/img/logo.png|. We'll go into more detail about resources in the following chapters \page{resources}.

If you open a browser and enter the path with a static file, the browser opens a window asking you to save the file to disk. A bit unexpected, sometimes. Today's browsers can display almost all known formats:
images, music, PDF, JSON, XML, and others. And we would like to see the file immediately in the browser.

The save window appears because the \verb|Content-Type| header for files and resources is equal to the \verb|application/octet-stream| binary stream by default. To determine the type by file extension, add another middleware — \verb|wrap-content-type|:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[ring.middleware.content-type
           :refer [wrap-content-type]])

(def mime-types
      {"json" "application/json"
       "png" "image/png"
       "xls" "application/vnd.ms-excel"})

(def app
  (-> app-naked
      (wrap-content-type
        {:mime-types mime-types})))
\end{clojure}

\else

\begin{clojure}
(require '[ring.middleware.content-type
           :refer [wrap-content-type]])

(def app
  (-> app-naked
      (wrap-content-type
       {:mime-types
         {"json" "application/json"
          "png" "image/png"
          "xls" "application/vnd.ms-excel"}})))
\end{clojure}

\fi

The \verb|:mime-types| parameter takes a map of \footurl{MIME-types}{https://en.wikipedia.org/wiki/MIME}[MIME types][-5mm] and extensions. Add the required types and check if the browser displays the files correctly.

\index{HTTP!streaming}

\section{Streaming and Proxying}

The response body also might be an output stream, an instance of the \verb|InputStream| class. The stream specific by being read once. Streams are widely used in Java, and some libraries return them directly. For example, when creating a PDF, we will get a stream with the binary content of the file. In order not to read the file into temporary storage, we will send a stream in the HTTP response. A consumer is reading it along with loading in a browser.

Streaming means the return of the stream. The stream can be huge, even endless. For example, the video stream from a camera potentially never ends.

Streams are even better suited for proxying. This word means data transfer through an intermediary. Suppose the company internal server gives important information upon request. We have to provide them to clients. However, we must not give them direct access to the internal resource. So we write middleware that checks access rights. If everything is ok, we send an HTTP request to the internal service and receive a stream. It becomes the body of our response to the client. We do not change the content, but only connect the stream to the required consumer.

Let's write a proxy application that will return the Yandex home page. In the request, we refer to it using GET. In the options, we pass the \verb|stream?| flag, which means not to read the response. In this case, the body will be a stream, not an HTML string. The Yandex response fields — \verb|status| and \verb|body| — go into our response. The above also applies to headers, but we will return not all of them, but their subset only (in our case, \verb|Content-Type|).

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(require '[clj-http.client :as client])

(defn app-proxy [req]
  (let [resp (client/get "https://ya.ru"
                         {:stream? true})
        {status :status
         headers :headers
         body :body} resp]
    {:status status
     :headers (select-keys
                headers ["Content-Type"])
     :body body}))
\end{clojure}

\else

\begin{clojure}
(require '[clj-http.client :as client])

(defn app-proxy [request]
  (let [response (client/get "https://ya.ru" {:stream? true})
        {:keys [status headers body]} response
        headers* (select-keys headers ["Content-Type"])]
    {:status status
     :headers headers*
     :body body}))
\end{clojure}

\fi

Run \verb|app-proxy| in the browser. You should see the Yandex home page, although the address is still \verb|localhost|. We can write the shorter \verb|app-proxy| code by using the arrow operator:

\ifx\DEVICETYPE\MOBILE

\begin{clojure}
(defn app-proxy [request]
  (-> "https://ya.ru"
      (client/get {:stream? true})
      (select-keys [:status
                    :body :headers])
      (update :headers
        select-keys ["Content-Type"])))
\end{clojure}

\else

\begin{clojure}
(defn app-proxy [request]
  (-> "https://ya.ru"
      (client/get {:stream? true})
      (select-keys [:status :body :headers])
      (update :headers select-keys ["Content-Type"])))
\end{clojure}

\fi

Modify the proxy by yourself so that it works with different sites. Add form support with the POST method, try out file uploads. What other headers do you need in addition to \verb|Content-Type|?

\emph{A challenge for true hackers.} You are writing a program for a mobile operator. If a client accessed the HTML page over an insecure connection, you have to add an advertising script after the \verb|<head>| tag. How can you do this on the fly without saving the page to memory or disk?

\section{Other Libraries}

In addition to the above, other frameworks and libraries have been written for Clojure web development. If Ring's capabilities aren't enough for you, refer to the projects below.

\begin{itemize}

\index{libraries!Compojure API}
\index{organisations!Metosin}
\index{web development!Swagger}

\item
\footurl{Compojure API}{https://github.com/metosin/compojure-api}[Compo-\\*jure API][-37mm] is a uber-superstructure over regular Compojure. It is a set of macros to describe a REST API. The library is closely related to JSON Schema and Swagger.

\index{libraries!Luminus}
\index{websites!luminusweb.com}

\item
\footurl{Luminus}{https://luminusweb.com}[Luminus][-28mm] is a template for a web application. It includes \verb|Compojure API| for routes, a database module, migrations, and many other out-of-box things. The project has good documentation and the community to turn to for help.

\index{libraries!Pedestal}
\index{organisations!Cognitect}

\item
\footurl{Pedestal}{https://github.com/pedestal/pedestal}[Pedestal][-23mm] is a framework from Cognitect. It features a flexible interceptor system that helps to linearly describe nested logic.

\index{libraries!Vase}
\index{organisations!Cognitect}
\index{databases!Datomic}
\index{formats!EDN}

\item
\footurl{Vase}{https://github.com/cognitect-labs/vase}[Vase][-15mm] is an experimental wrapper on top of Pedestal. It defines the logic in the EDN file. Closely related to Datomic, the Cognitect database.

\index{libraries!Duct}

\item
\footurl{Duct}{https://github.com/duct-framework/duct}[Duct][-4mm] is a new framework from the Ring creator. The project is at its early stage, so there is little documentation. It focuses on modularity and a component system \page{chapter-systems}.

\index{libraries!Liberator}
\index{languages!Erlang}
\index{multi-methods}

\item
\footurl{Liberator}{https://clojure-liberator.github.io/liberator}[Liberator][2mm] is an analog of the Webmachine project for Erlang. Request and response go through
stages, for each of which you can set a reaction. It offers a rule system based on multi-methods.

\end{itemize}

\section{Summary}

The contemporary Web runs over HTTP, which is a textual protocol based on TCP/IP. HTTP exchange takes place in two phases: a request and a response. Both consist of the first line, headers, and a body (optional).

For the request, its method and path are important, and for the response, its status. As the Web evolved, conventions emerged on how to build HTTP APIs. Among them, REST is the most popular. According to it, a path defines a resource, and a method defines the action on it. Data is transmitted in JSON format.

To write web applications in Clojure, install Ring. It is a set of libraries that have the essentials: basic abstractions, middleware, and a web server. A request handler is a function that takes a request and returns a response. Both of these entities are maps.

Ring does not come with routes — they require third-party libraries. Compojure offers macros to define routes using rules. Bidi builds a tag tree that works in tandem with a multi-method.

A middleware is a function that wraps another function. Their chain is called a stack. It is described using the arrow operator: this reduces the number of parentheses and makes the code more readable. Middleware preprocesses the request: read JSON from a body or check permissions. Some middleware break the stack if an exception is thrown or the request cannot be processed.

Besides Ring, there are other frameworks for Clojure. They define the structure of a project, introduce rules and conventions. Some of them repeat analogs in other languages. Each framework has its advantages, so choose based on the task at hand.
