\chapter{Исключения}

\index{исключения}

\begin{teaser}
В этой главе мы рассмотрим исключения в Clojure: как они устроены и чем
отличаются от аналогов Java. Когда лучше бросать, а~когда перехватывать
исключения. Что и как писать в лог, чтобы расследовать инцидент было легко.
\end{teaser}

Возможно, читателю покажется странным, что исключениям отдана целая глава. Тему
считают простой: исключения можно кинуть, поймать и записать в лог. В теории
этого хватит, чтобы работать в~проекте.

Исключения просты с технической стороны, но несут обширную
\emph{семантику}. Когда именно кидать исключения, а когда перехватывать?  Какую
полезную информацию они несут? Куда записывать исключения? Можно ли ловить их
предикатами? На практике мы тонем во множестве частных случаев.

Новички следуют только положительному пути, поэтому в их коде тяжело
расследовать ошибки. Почему сервер ответил с кодом 500? Возможны сотни причин,
по которым запрос не удался. Но запись в~логе слишком скудна, чтобы понять, что
произошло.

Хороший программист внимателен к ошибкам. С опытом становится ясно: экономия на
исключениях не даёт выигрыша. Да, мы быстрее закроем задачу, и кода
получится меньше. Однако позже возникнут задачи на устранение ошибок и их
детализацию.

Исключения в коде столь же равноправны, как и нормальное поведение. Избегайте
мысли, что это недоразумение, которое не случится с~вами. Если в проекте много
задач на не пойманные ошибки, это значит, пора изучить тему.

\section{Основы исключений}

\index{классы!Exception}

Прежде чем углубляться в детали, вспомним, что такое исключения и~как они себя
ведут.

Исключение это объект, чаще всего экземпляр класса \verb|Exception|. От других
классов он отличается тем, что его можно \emph{бросить}. В разных языках для
этого служат операторы \verb|throw|, \verb|raise| и другие.

Брошенный объект прерывает исполнение и всплывает по стеку вызовов. Возможны два
исхода: либо его поймали оператором \verb|catch| на одном из уровней, либо
перехват не состоялся.

В первом случае мы получим \emph{объект} исключения. К нему обращаются как
обычно: читают поля, вызывают методы, передают в~функции. Дальнейшее поведение
зависит от логики программы. Иногда исключение пишут в лог и завершают
программу, в других случаях продолжают работу.

Когда исключение не поймали, программа завершится с кодом, отличным от
нуля. Если не предусмотрено иное, перед выходом программа запишет исключение в
\verb|stderr| (канал ошибок). Мы увидим его класс, текст и то, что называют
<<стектрейс>>. Это цепочка вызовов, которые прошло исключение.

\index{исключения!стектрейс}
\index{каналы!stderr}

Отдельные платформы позволяют задать реакцию на не пойманное
исключение. Например, записать его в файл или завершить программу особым
способом.

\begin{figure}[ht!]
  \small
  \chart{chart-ex-tree}
  \caption{Базовые классы исключений}
  \label{fig:exceptions}
\end{figure}

Clojure это гостевой язык (анг. hosted language). Он опирается на возможности,
которые предлагает домашняя платформа, \emph{хост}. Исключения~--- одна из
областей, в которую Clojure не вмешивается. По умолчанию Clojure использует
формы \verb|try| и \verb|catch|, аналогичные Java.

\index{классы!Throwable}

Рассмотрим исключения в Java \fig{fig:exceptions}. Платформа содержит
базовый класс \verb|Throwable|, предок всех исключений. Другие классы наследуют
его и расширяют семантику. Наследники первого уровня это классы \verb|Error| и
\verb|Exception|. Класс \verb|RuntimeException| унаследован от \verb|Exception|
и так далее.

\index{классы!IOException}

Пакеты Java несут дополнительные исключения, унаследованные от описанных
выше. Например, \verb|java.io.IOException| для ошибок ввода-вывода,
\verb|java.net.ConnectException| для сетевых проблем другие. Бросать
\verb|Throwable| считается дурным тоном. Этот класс несёт слишком мало
информации о том, что случилось.

В дереве исключений каждый класс дополняет семантику предка. Рассмотрим
исключение \verb|FileNotFoundException|. Оно возникает, когда файла не
оказалось на диске. Родословная класса выглядит так:

\linegap

\dirtree{%
 .1 java.lang.Object.
 .2 java.lang.Throwable.
 .3 java.lang.Exception.
 .4 java.io.IOException.
 .5 java.io.FileNotFoundException.
}

\linegap

Схему читают <<объект \arr выбрасываемое \arr исключение \arr ошибка
ввода-вывода \arr файл не найден>>. По имени \verb|FileNotFoundException|
легко догадаться, с чем связана проблема. Если же разработчик бросил
\verb|Throwable|, это усложнит поиск причины.

Различают \emph{checked} и \emph{unchecked} исключения, проверяемые и
нет. Разница между ними в семантике. Разработчик должен предвидеть checked
исключения и обработать их в коде. При чтении файла справедливо ожидать, что его
не окажется на диске, поэтому класс \verb|FileNotFoundException| относится к
категории checked.

\index{классы!FileNotFoundException}

\label{exc-hierarchy}

Предсказать нехватку памяти трудно, поэтому \verb|OutOfMemoryError|
не проверяемое исключение (unchecked). Когда ресурсы ограничены, любое действие
может исчерпать память. Перехватывать это исключение нет смысла, поскольку при
нехватке памяти система нестабильна.

\index{исключения!checked}
\index{исключения!unchecked}

Классы, унаследованные от \verb|Error| и \verb|RuntimeException| это
не проверяемые исключения (unchecked). Унаследованные от \verb|Exception|~---
проверяемые (checked).

\index{исключения!throw}
\index{исключения!catch}

Чтобы бросить исключение, его экземпляр передают в оператор
\verb|throw|. Оператор \verb|catch| перехватывает исключения. В Java и
других языках он устроен на иерархии классов. Если искомый тип
\verb|IOException|, мы поймаем все исключения, унаследованные от этого класса.

Чем выше класс в дереве наследования, тем больше исключений охватит
\verb|catch|. В Java считается плохим тоном ловить ошибки классами
\verb|Throwable| или \verb|Exception|. Современные IDE выдают предупреждение
<<too wide catch expression>>, слишком широкий охват. Класс \verb|Exception|
заменяют на несколько более точных исключений. Например, отдельно ошибки
ввода-вывода, сети и другие.

Одного класса недостаточно, чтобы понять причину
исключения. У~\verb|FileNotFoundException| нет поля \verb|file|, чтобы
отследить, какой именно файл не удалось найти. Большинство исключений принимают
строку с сообщением об ошибке. Сообщение должно быть понятно человеку. Из строки
<<File С:/work/test.txt not found>> станет ясно, какому файлу мы обращались.

\index{сообщения}

Иногда текста не хватает, чтобы объяснить причину ошибки. Предположим, данные не
прошли валидацию, и нам хотелось бы исследовать их позже. Если записать данные в
сообщение, текст получится слишком большим. Это небезопасно: в данных могут быть
личные данные или ключи доступа. Такое сообщение нельзя писать в лог или
показывать пользователю. Даже путь к файлу может выдать важную информацию.

Если нужно сохранить данные для расследования, создают новый класс исключения. У
него отдельное поле для данных, из-за которых произошла ошибка. Поле заполняют в
конструкторе исключения. Сообщение формируют так, чтобы оно не выдало приватную
информацию.

\section{Цепочки и контекст}

\index{исключения!цепочки}

Исключения строятся в цепочку. Каждый экземпляр принимает необязательный
аргумент \verb|cause| (анг. причина). Он хранит либо \verb|Null|, либо
ссылку на другое исключение.

\index{null!в Java}

\index{контекст}

Цепочки образуются, когда код перехватил исключение, но не знает, как с ним
поступить.  Это нормально, потому что на низком уровне код не видит полной
картины. Предположим, метод пишет данные в файл. У него нет полномочий решить
что делать, если файла нет, поэтому метод бросит исключение. Его перехватит
метод, который тоже не принимает решений. Остаётся бросить новое исключение
со ссылкой на первое. Это и есть цепочка.

В конце управление перейдет к методу, который знает, что делать. Логика зависит
от типа исключения и бизнес-правил. Если файла нет, программа создаст его или
выполнит поиск в другом месте. Если в~HTTP-запросе произошел сбой, выждать
секунду и повторить его, а~после третьей попытки завершить программу.

В системе должен быть последний рубеж, где перехватывают все исключения. Если
ошибка дошла до этого уровня, значит, её не поймали правила ниже. Это говорит о
нештатном поведении системы. Клиенту вернут текст о том, что запрос не
прошёл. Чтобы расследовать причину, исключение пишут в лог и передают сборщику
ошибок.

На верхнем уровне кода лежит бизнес-логика. Это шаги, которые диктует
руководство, чтобы развивать компанию. При спуске вниз начинается техническая
часть. Представим, что функция \verb|get-user| находит пользователя по
номеру. Снаружи это чёрный ящик: мы не знаем, откуда приходят
данные. Предположим, функция обращается в~сеть. Выразим это на псевдокоде:

\index{языки!Python}

\begin{english}
  \begin{python}
def get-user(id):
  url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
  \end{python}
\end{english}

Если вызвать функцию с номером, которого нет в системе, получим исключение
\verb|HTTP Error: status 404|. Текст ничего не говорит о пользователе. Если
встретить эту запись в журнале, мы даже не поймем, к~какому сервису обращались.

Чем больше мы углубляемся в технические детали, тем меньше знаем о бизнесе. В
HTTP нет понятия пользователя. Известны лишь метод, адрес и другие поля
запроса. Разделим ошибку на две половины. Верхняя часть называет бизнес-причину:
не найден пользователь с номером~42. Почему? Из-за технического сбоя: запрос GET
к адресу \verb|http://api.company.com/user/42| вернул статус 404.

Расставим в коде \verb|try/catch|. Если исключение пришло из технических недр,
дополним его контекстом и отправим наверх. Паттерн называется \verb|re-throw|,
повторный выброс. Новый псевдокод:

\begin{english}
  \begin{js}
def get-user(id):
  try {
    url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  } catch error {
    throw Error("Cannot fetch user " + str(id), cause=error)
  }
  \end{js}
\end{english}

\index{HTTP!ошибки}

Новое исключение описывает бизнес-проблему и при этом ссылается на
техническую. У ошибки HTTP тоже может быть причина: устаревший сертификат,
проблемы соединения. Образуется цепочка исключений. В проектах они достигают
пять и более звеньев.

Спуск по цепочке напоминает допрос. На каждое <<почему>> мы получаем новую пищу
для размышлений, пока не доберемся до сути. Это не значит, что самое нижнее
исключение важнее других: одно лишь \verb|HTTPError| не отвечает на все
вопросы. Важно то, как к нему пришли.

Так работают исключения в промышленных языках: Java, Python и других. У каждой
платформы особенности, но в целом картина не меняется. Теперь рассмотрим, что
предлагает Clojure.

\section{Переходим к Clojure}

Чтобы познакомиться с исключением, спровоцируем его. Подойдёт старый
приём~--- поделить число на ноль. Включите REPL и выполните
\verb|(/ 1 0)|. Появится текст:

\index{деление на ноль}

\begin{english}
  \begin{text}
Execution error (ArithmeticException)...
Divide by zero
  \end{text}
\end{english}

Это отчёт об ошибке. В зависимости от редактора и настроек оно выглядит
по-разному. Emacs с модулем CIDER откроет буфер \verb|*cider-error*|
с подробной информацией.

\index{Emacs!*cider-error*}
\index{REPL}
\index{исключения!в REPL}

Заметим, что исключение в REPL не завершает его: от нас по-прежнему ждут
команды. REPL перехватывает ошибки и только выводит их на экран. В боевом
запуске программы на Clojure ведут себя как обычно. Если в главном потоке не
поймано исключение, программа остановится.

Чтобы поймать исключение, код помещают в форму \verb|try|. За ним следует одна
и более \verb|catch|. В них указывают, какие классы перехватывать и что делать
с исключением. Вот как безопасно разделить число:

\index{арифметика}

\begin{english}
  \begin{clojure}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
  \end{clojure}
\end{english}

Форма \verb|catch| принимает класс и произвольный символ. С ним будет связано
исключение, если управление перейдет в эту ветку. Далее идёт произвольный код. В
нём исключение доступно как локальная переменная \verb|e|.

\index{исключения!ex-message}

Мы вывели на экран текст, что вычисления прошли неудачно. Это слишком
поверхностное объяснение. Метод \verb|.getMessage| вернёт сообщение, которое
назначили исключению при создании. С версии 1.10 Clojure предлагает функцию
\verb|ex-message|, которая делает то же самое:

\begin{english}
  \begin{clojure}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println (ex-message e))))
;; Divide by zero
  \end{clojure}
\end{english}

Класс \verb|ArithmeticException| ловит не все ошибки вычислений. Что случится,
если сложить 1 и \verb|nil|? Даже если поместить расчёты в~\verb|try/catch|,
мы не поймаем исключение:

\begin{english}
  \begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

\index{NPE}

\noindent
Дело в том, что классы \verb|ArithmeticException| и
\verb|NullPointerException| не пересекаются. У них разные пути в дереве
наследования, поэтому перехват одного не влияет на другое. Это правильно, потому
что у~классов разная семантика. Ошибка в арифметике это не то же самое, что
\verb|Null| вместо значения.

\index{исключения!ветки}

Форма \verb|try| принимает несколько \verb|catch|. Перехватим оба случая:

\begin{english}
  \begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics"))
  (catch NullPointerException e
    (println "You've got a null value")))
  \end{clojure}
\end{english}

Макрос перебирает классы из каждого \verb|catch| и остановится на первом
подходящем варианте. Результатом \verb|try| станет последнее выражение из
блока \verb|catch|, который подошёл. В примере выше результат будет
\verb|nil|, потому что его вернёт \verb|println|. Если ни одна ветка не
подошла, исключение продолжит путь вверх по стеку вызовов.

\index{наследование}

Чем выше класс исключения в дереве, тем больше случаев он покрывает. Если
заменить \verb|ArithmeticException| на \verb|Throwable|, ветка захватит
любое исключение, будь то деление на ноль или \verb|NPE|:

\begin{english}
  \begin{clojure}
(try
  (/ 1 0)
  (+ 1 nil)
  (catch Throwable e
    (println "I catch everything!")))
  \end{clojure}
\end{english}

В отличие от Java, в Clojure нет строгих правил о том, какие исключения
перехватывать. Это остаётся на ваше усмотрение. Здравый смысл подсказывает, что
перехват \verb|Throwable| опасен: возникает ложное ощущение, что код работает
без ошибок.

В случае с \verb|ArithmeticException| проблема в расчетах, но для \verb|NPE|
это не так. \verb|Nil| вместо числа говорит о том, что проблема в источнике,
который сообщил \verb|nil|, а не в арифметике. Вот почему перехват
\verb|NPE| вреден. Мы подробно изучим эту проблему в главе про
тесты \page{illegal-arg}.

Форму \verb|try/catch| с широким охватом ставят на верхний уровень кода. Это
нужно, чтобы программа не остановилась никогда. Так работают веб-серверы,
очереди сообщений, сетевое ПО.

\index{исключения!выброс}

Иногда исключение бросают намеренно, чтобы сообщить о~нештатной
ситуации. Оператор \verb|new| создаёт новый Java-объект. Ему передают класс и
параметры конструктора. Форма \verb|throw| принимает исключение и запускает
механизм выброса.

\begin{english}
  \begin{clojure}
(let [e (new Exception "Something is wrong!")]
  (throw e))
  \end{clojure}
\end{english}

Сообщение выше не информативно. Даже если мы указали, что проблема в арифметике
или базе данных, хотелось бы знать, какие именно значения вызвали ошибку. Для
этого сообщение строят функцией \verb|format|. Она принимает шаблон и
параметры подстановки:

\index{clojure.core!format}

\begin{english}
  \begin{clojure}
(defn add [a b]
  (if (and a b)
    (+ a b)
    (let [message (format "Value error, a: %s, b: %s" a b)]
      (throw (new Exception message)))))
  \end{clojure}
\end{english}

\noindent
Если вызвать \verb|add| с \verb|nil|, сообщение станет понятнее:

\begin{english}
  \begin{clojure}
Execution error at book.exceptions/add (exceptions.clj:86).
Value error, a: 1, b: null
  \end{clojure}
\end{english}

Функция \verb|format| полезна тем, что отображает \verb|nil| как
\verb|null|. Это преимущество перед \verb|str|, которая приводит
\verb|nil| к пустой строке. Вариант со \verb|str| выглядит так:

\begin{english}
  \begin{clojure}
(str "Value error, a:" 1 ", b: " nil)
;; Value error, a:1, b:
  \end{clojure}
\end{english}

\noindent
Текст вводит в заблуждение: \verb|b| это \verb|nil| или пустая строка? В~случае
с~\verb|format| ошибки быть не может.

\section{Подробнее о контексте}

\index{контекст!в исключениях}
\index{классы!ExceptionInfo}

Данные в тексте приводят к риску. Сообщение может оказаться слишком большим или
выдать лишние сведения. Проблему решает класс \verb|ExceptionInfo|~---
исключение из поставки Clojure. Оно устроено так, чтобы хранить данные. Clojure
предлагает ряд функций для работы с~ним.

Ключевая функция \verb|ex-info| создаёт экземпляр \verb|ExceptionInfo|. Она
принимает сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если HTTP-запрос не удался, в словарь помещают метод,
адрес и код ответа.

\verb|Ex-info| только создаёт исключение, но не бросает его. Результат
передают в \verb|throw|:

\begin{english}
  \begin{clojure}
(throw (ex-info
        "Cannot fetch user."
        {:user-id 42
         :http-status 404
         :http-method "GET"
         :http-url "https://host.com/users/42"}))
  \end{clojure}
\end{english}

Мы разделили сообщение и данные. Текст не выдаёт номер пользователя и адрес
сервиса. Его запишут в лог или отправят пользователю, а контекст обработают
отдельно.

При работе с контекстом помните несколько правил. Словарь не может быть
\verb|nil|. Это редкий случай, когда Clojure отличает \verb|nil| от
коллекции. Не храните в словаре значения, которые нельзя записать в файл,
например поток или сетевое подключение. В идеале контекст передают по сети в
формате JSON. Позже мы рассмотрим, что делать с контекстом.

Функция \verb|ex-data| вернёт данные исключения. Если это <<родное>>
\verb|ExceptionInfo|, получим словарь. Для других классов результат функции
будет \verb|nil|.

\index{исключения!ex-data}

Поймаем исключение: в форме \verb|catch| укажем класс
\verb|ExceptionInfo|. Функция \verb|ex-data| извлекает словарь, который передали
в \verb|ex-info|. Разделим его на поля и построим сообщение.

\begin{english}
  \begin{clojure}
(try
  (get-user 42)
  (catch clojure.lang.ExceptionInfo e
    (let [{:keys [http-method http-url]} (ex-data e)]
      (format "HTTP error: %s %s" http-method http-url))))
;; HTTP error: GET https://host.com/users/42
  \end{clojure}
\end{english}

\section{Когда бросать исключения}

До сих пор не ясно, когда бросать исключения, а когда ограничиться
проверкой. Рассмотрим типичные ситуации и решения.

При обходе коллекций нет смысла бросать исключения. \verb|Nil| ведёт себя как
пустая коллекция того типа, который имеет в виду функция. Выражения:

\begin{english}
  \begin{clojure}
(assoc nil :test 42)
(update nil :test (fnil inc 0))
(into nil [1 2 3])
(merge nil {:test 42})
  \end{clojure}
\end{english}

\noindent
вернут списки и словари. Ключ от \verb|nil| вернёт \verb|nil|. Разбор
словаря или вектора сообщит переменным \verb|nil|, если поля не совпали. Оба
\verb|let| ниже произведут вектор из трёх \verb|nil|.

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
(let [{:keys [a b c]} nil]
  [a b c])
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(let [[a b c] nil]
  [a b c])
  \end{clojure}
\end{english}

\end{tabular}

\index{nil!punning}

\noindent
Термин <<nil punning>> означает лояльность к \verb|nil|. С таким подходом
пустые значения не вызывают ошибок. Нельзя утверждать, что Clojure полностью
<<nil punning>>. \verb|Nil| дружит с коллекциями, но не работает с~арифметикой
и регулярными выражениями.

\index{spec!valid?}
\index{spec!conform}

Если вы сомневаетесь в коллекции, используйте спеку. Функции \verb|s/valid?| и
\verb|s/conform| из прошлой главы \page{spec-conform} помогут убедиться, что
коллекция верна. Этим вы отделите проверку от работы с данными. Если валидация
не прошла, бросайте исключение. Передайте в контекст данные \verb|explain|,
чтобы разобрать их позже.

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::data (s/coll-of int?))

(when-let [explain (s/explain-data ::data [1 2 nil])]
  (throw (ex-info "Some item is not an integer"
                  {:explain explain})))
  \end{clojure}
\end{english}

\index{spec}
\index{spec!assert}

Для краткости используйте макрос \verb|assert| из поставки Spec. Он делает то
же самое: проверяет данные и либо возвращает их, либо бросает исключение с
данными \verb|explain|. Поведение макроса определяет глобальный флаг
\verb|check-asserts|. Если его выключить, эффект \verb|assert| пропадает, и
исключений не будет.

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::ne-string (s/and string? not-empty))

(s/check-asserts true)
(s/assert ::ne-string "test") ;; ok

(s/assert ::ne-string nil)
;; Execution error - invalid arguments
;; nil - failed: string?

(s/check-asserts false)
(s/assert ::ne-string nil) ;; nil
  \end{clojure}
\end{english}

Другой случай, когда прибегают к исключению~--- отказ ресурса. Если не удалось
прочитать файл, недостаточно просто сказать об этом. Возможны десятки причин:
файла нет, он занят другим процессом, кончилось место на диске, ошибка в
кодировке. От ошибки зависит, кто ей займётся и как не допустить её
снова.

\index{HTTP!404}

В индустрии нет единого мнения о том, бросать ли исключение на негативный
HTTP-ответ. Согласно протоколу, ответ со статусом 404 такой же верный, как и
200. Продвинутые библиотеки предлагают флаг, чтобы управлять этим поведением.

Предположим, наш HTTP-клиент не бросает исключение. Сделаем это вручную:
проверим статус и запустим \verb|ex-info| с подробностями:

\index{HTTP!авторизация}

\begin{english}
  \begin{clojure}
(defn authenticate-user [user-id]
  (let [url (str "http://auth.company.com/" user-id)
        {:keys [status body]} (client/get url)]
    (if (= status 200)
      body
      (throw (ex-info "Authentication error"
                      {:http-url url
                       :http-status status
                       :http-body body})))))
  \end{clojure}
\end{english}

Исключения полезны в библиотеках. Код условно делится на два типа: исполнение и
координация. Библиотеки относятся с исполнительному коду. На уровне библиотеки
мы не знаем, в какой семантике работает код. Если бросить исключение,
бизнес-логика перехватит его и продолжит работу. Но если молча подавлять ошибки,
потребители будут недовольны. Это касается и паттерна <<вернуть \verb|nil| и
записать в~лог>>, что значит проигнорировать проблему.

\section{Подробнее о цепочках}

\index{исключения!цепочки}

Рассмотрим цепочки исключений на практике. Функция \verb|ex-info|
принимает третий необязательный параметр \verb|cause|. Это либо \verb|nil|,
либо другое исключение, которое станет частью нового. Ниже функция
\verb|divide| ловит ошибку арифметики и бросает новое исключение с контекстом.

\index{исключения!cause}

\label{re-throw-example}

\begin{english}
  \begin{clojure}
(defn divide [a b]
  (try
    (/ a b)
    (catch ArithmeticException e
      (throw (ex-info
              "Calculation error"
              {:a a :b b}
              e)))))
  \end{clojure}
\end{english}

Функция \verb|ex-cause| возвращает причину исключения. Если её не было,
получим \verb|nil|.

\begin{english}
  \begin{clojure}
(try
  (divide 1 0)
  (catch Exception e
    (println (ex-message e))
    (println (ex-message (ex-cause e)))))
  \end{clojure}
\end{english}

\noindent
Код выведет:

\begin{english}
  \begin{text}
Calculation error
Divide by zero
  \end{text}
\end{english}

Напишем функцию, которая вернёт список исключений по убыванию
старшинства. На первом месте исходное исключение, на втором его причина, далее
причина причины и так далее. Проще всего сделать это формой \verb|loop|:

\index{итерация}
\index{clojure.core!loop}
\index{функции!ex-chain}

\begin{english}
  \begin{clojure}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e) (conj result e)))))
  \end{clojure}
\end{english}

Для экспериментов объявим переменную \verb|e|. Это цепь исключений из трёх
звеньев. На первом уровне ошибка бизнес-логики: не удалось извлечь
пользователя. На втором уровне проблема с авторизацией: не хватило прав
доступа. На третьем ошибка транспорта: HTTP-запрос вернул статус 403.

\label{e-sample}

\begin{english}
  \begin{clojure}
(def e
  (ex-info
   "Get user info error"
   {:user-id 42}
   (ex-info "Auth error"
            {:token "........."}
            (ex-info "HTTP error"
                     {:method "POST"
                      :url "http://api.site.com"}))))
  \end{clojure}
\end{english}

\index{коллекции!обход}

Получилось дерево исключений, но не всегда удобно работать с~деревом. Плоская
структура лучше поддается обходу. Пригодится функция \verb|ex-chain|, которую
мы написали. Вот как получить сообщения всех исключений:

\begin{english}
  \begin{clojure}
(map ex-message (ex-chain e))
("Get user info error" "Auth error" "HTTP error")
  \end{clojure}
\end{english}

\noindent
А так~--- напечатать построчно (получим столбик тех же строк):

\index{печать!исключений}

\begin{english}
  \begin{clojure}
(doseq [e (ex-chain e)]
  (-> e ex-message println))
  \end{clojure}
\end{english}

Выразим \verb|ex-chain| короче через \verb|iterate|. Это функция, которая
шаг за шагом применяет другую функцию к аргументу. Ограничение
\verb|take-while| нужно, чтобы остановиться на первом пустом элементе.

\begin{english}
  \begin{clojure}
(defn ex-chain [^Exception e]
  (take-while some? (iterate ex-cause e)))
  \end{clojure}
\end{english}

\section{Печать исключений}

Что-то пошло не так, и мы оказались в ветке \verb|catch|. На исключение
указывает локальная переменная. Как с ней поступить?

Самое простое, что можно сделать с исключением~--- напечатать в~консоль. Функция
\verb|println| достаточно умна: перед выводом она переводит исключение в
словарь. Это удобно для редакторов и IDE, потому что словарь легко разобрать на
части. Например, показать только ту часть стек-трейса, что касается Clojure.

Последнее исключение в цепочке называют корнем, \emph{root}. Для удобства
\verb|println| дублирует корень в начале, чтобы сразу было видно
первопричину. Вот что выведет \verb|(println e)|:

\index{печать!исключений}

\begin{english}
  \begin{clojure}
#error {
 :cause HTTP error
 :data {:method POST, :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 42}}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:token .........}}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST, :url http://api.site.com}}]
 :trace
 [[clojure.lang.AFn applyToHelper AFn.java 156]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler$InvokeExpr eval Compiler.java 3701]
  ..........]}
  \end{clojure}
\end{english}

\index{языки!Java}
\index{стектрейс}

Вектор \verb|:trace| называют стек-трейсом. Это методы Java, по которым прошло
исключение с момента выброса до перехвата. Элемент трейса это вектор с именем
класса, метода, файла и номера строки.

Мы сократили трейс, чтобы не тратить на него бумагу. В реальности трейсы
занимают несколько экранов. Они показывают Java-код, который получился из
Clojure, и это сбивает с толку. Шумные трейсы~--- справедливый упрёк в адрес
Clojure. С другой стороны, ими страдают многие JVM-языки.

\index{модули!clojure.stacktrace}

В пакете \verb|clojure.stacktrace| несколько функций для печати
исключений. \verb|Print-throwable| выводит сообщение и контекст:

\begin{english}
  \begin{clojure}
(clojure.stacktrace/print-throwable e)
clojure.lang.ExceptionInfo: Get user info error
{:user-id 42}
  \end{clojure}
\end{english}

Макрос \verb|with-out-str| перехватывает вывод в консоль. Код ниже ничего не
печатает, но вернёт строку:

\begin{english}
  \begin{clojure}
(with-out-str
  (clojure.stacktrace/print-stack-trace e))
  \end{clojure}
\end{english}

Функции \verb|print-stack-trace| и \verb|print-cause-trace| печатают трейс с
небольшими отличиями. Они принимают параметр \verb|n|, чтобы задать глубину
трейса.

\section{Логирование}

\index{логирование}

Вывод в консоль помогает в отладке, не не подходит для боевого
запуска. Перечислим, что ожидают от кода, который ловит исключения.

Для любого сообщения важны его вспомогательные данные: время, модуль, номер
процесса. Сообщения различают по уровню важности: информационное,
предупреждение, тревога и другие. Печать не несёт этих сведений, а их ручной
сбор увеличит код.

Если программа работает на многих серверах, сбор сообщений
централизован. Представьте, что сотрудник переключается между сотней машин,
чтобы читать логи~--- это никуда не годится. Если сообщение пришло по сети,
нужно запомнить адрес источника.

Не все сообщения одинаково важны. Иногда библиотеки порождают сотни отладочных
сообщений в минуту. Нужен механизм, чтобы отбрасывать их по некоторым признакам.

Наконец, консоль и файл~--- не единственные каналы данных. Особо важные
сообщения пишут в журнал операционной системы, шлют на почту, ботам в чате или в
смс ответственным лицам.

Указанные проблемы решает логирование. Это система, которая принимает сообщения
и пересылает в нужные каналы. Библиотека \verb|clojure.tools.logging|
предлагает функции и макросы, чтобы логировать сообщения. Это сторонний проект,
поэтому добавьте зависимость:

\index{библиотеки!clojure.tools.logging}

\begin{english}
  \begin{clojure}
[org.clojure/tools.logging "0.4.1"]
  \end{clojure}
\end{english}

\noindent
Запишем простое сообщение:

\begin{english}
  \begin{clojure}
(require '[clojure.tools.logging :as log])
(log/info "A message from my module")
  \end{clojure}
\end{english}

\noindent
В REPL появится строка. По умолчанию лог добавляет уровень важности. В нашем
случае это информационное сообщение, \verb|INFO|.

\begin{english}
  \begin{text}
INFO: A message from my module
  \end{text}
\end{english}

В Clojure логирование устроено из двух уровней. Первый это входная точка,
макросы \verb|log/info|, \verb|log/error| и другие. Второй уровень называют
бекендом. Под ним понимают Java-библиотеку, которая выполняет основную работу:
пишет сообщения в файлы, отправляет их по сети и так далее.

Такое устройство несёт преимущества. Исторически сложилось так, что для Java
написано много библиотек логирования. Каждая из них предлагает свои классы и
методы. Если проект использует конкретный Java-бекенд, не получится сменить его
без правок в коде.

\index{логирование!бекенды}
\index{библиотеки!Logback}
\index{библиотеки!Log4j}

В Clojure эту проблему решили дизайном. При старте модуль \verb|logging| ищет
библиотеки \verb|Logback|, \verb|Log4j| и другие. Если ничего не найдено, он
использует стандартный пакет \verb|java.util.logging|. Вызов \verb|log/info|
сводится к вызову класса из найденной библиотеки.

Чтобы нужный бекенд <<подхватился>>, добавьте его в зависимости. Особенно
популярен проект \verb|Logback|. От аналогов его отличает большой выбор
\emph{аппендеров} (анг. appenders). Так называют пункт назначения, куда писать
сообщения. Это может быть файл, удаленный syslog, почтовый сервер.

Добавьте Logback к проекту:

\begin{english}
  \begin{clojure}
[ch.qos.logback/logback-classic "1.2.3"]
  \end{clojure}
\end{english}

\index{форматы!XML}

Библиотеки логирования ищут настройки в стандартных местах. Если в папку
\verb|resources| положить XML-файл для бекенда, он прочтёт его на
старте. Запишите туда следующий файл \verb|logback.xml|:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="...ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>%date %-5level %logger{36} - %msg %n</pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
  \end{xml}
\end{english}

\index{даты!в логах}

Мы задали appender для вывода в консоль. В теге \verb|pattern| указан шаблон
сообщения. Параметры шаблона начинаются со знака процента. Подстановка
\verb|\%msg| означает сообщение, \verb|\%date|~--- текущую дату. Её
формат задают в фигурных скобках, например \verb|%date{ISO8601}|. Залогируйте
что-нибудь в новыми настройками. Вывод изменится:

\begin{english}
  \begin{clojure}
(log/info "Hello Logback!")
;; 2019-05-03 17:36:04,001 INFO book.exceptions - Hello Logback!
  \end{clojure}
\end{english}

\label{log-ex-param}

Макросы \verb|log/info|, \verb|log/error| и другие допускают, что первым
аргументом может быть не текст, а исключение. Выше мы объявили переменную
\verb|e| для экспериментов. Запишем её в лог:

\begin{english}
  \begin{clojure}
(log/error e "HTTP Error")

2019-05-03 17:41:03,913 ERROR book.exceptions - HTTP Error
clojure.lang.ExceptionInfo: Get user info error
    at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 31 common frames omitted
  \end{clojure}
\end{english}

Для экономии мы удалили часть трейса. Из примера видно, что цепочка состоит из
трёх звеньев~--- как и задали \verb|e|. Проблема в том, что у каждого звена
пропали данные. Logback не подозревает о том, что поле \verb|data| класса
\verb|ExceptionInfo| так важно для нас.

\index{логирование!исключений}

Библиотека предлагает несколько шаблонов для исключения: \verb|%xEx|,
\verb|%xException| и другие. Они влияют на длину и детализацию трейса, но
игнорируют данные. Похоже ведут себя Log4j и другие проекты.

В Java проблему решают новым классом. Как правило, бекенд логирования предлагает
класс, который переводит исключение в строку. Его наследуют и заменяют нужный
метод. В настройках логирования указывают путь к новому классу.

Способ работает и в Clojure, но с неудобствами. Чтобы наследовать класс в
Clojure, нужен отдельный модуль с директивой \verb|:gen-class|. Придётся
читать документацию к библиотеке, исследовать классы и~интерфейсы. Решение будет
завязано на конкретный бекенд. Если проект переедет на Log4j, мы вынуждены
наследовать другой класс. Это не тот способ, которому следуют в Clojure.

Напишем функцию для логирования ошибок. Это обёртка над \verb|log/error| с
небольшой разницей: перед записью в лог исключение переходит в текст, как удобно
нам. Чтобы собрать данные об ошибке, построим цепочку исключений с помощью
\verb|ex-chain|. Функция \verb|ex-print| пробегает по ней и печатает данные в
консоль.

\index{печать!исключений}
\index{функции!ex-print}

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

Результат выглядит приятнее, чем пирамида трейсов. Чётко видны данные,
которые привели к ошибке:

\begin{english}
  \begin{clojure}
clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 42}
clojure.lang.ExceptionInfo
  Auth error
  {:token "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
  \end{clojure}
\end{english}

\index{печать!перехват}
\index{clojure.core!with-out-str}

Чтобы перехватить печать на экран, вызов \verb|ex-print| оборачивают в
\verb|with-out-str|:

\begin{english}
  \begin{clojure}
(defn log-error
  [^Throwable e & [^String message]]
  (log/error
   (with-out-str
     (println (or message "Error"))
     (ex-print e))))
  \end{clojure}
\end{english}

Вторым аргументом в \verb|log-error| передают сообщение. Если его нет, запишем
нейтральное <<Error>>. Чтобы сообщение и тело не слиплись, используем
\verb|println| для переноса строки. Примеры:

\begin{english}
  \begin{clojure}
(log-error e)
(log-error e "HTTP Error 500")
  \end{clojure}
\end{english}

\noindent
Второй вызов запишет в лог следующее:

\begin{english}
  \begin{text}
2019-05-03 19:00:05,590 ERROR book.exceptions - HTTP Error 500
clojure.lang.ExceptionInfo
  Get user info error
  ...
  \end{text}
\end{english}

Доработайте \verb|log-error| так, чтобы сообщение было шаблоном, а~функция
принимала параметры подстановки:

\begin{english}
  \begin{clojure}
(log-error e "Cannot find user %s, status %s" 42 404)
  \end{clojure}
\end{english}

Сообщения об ошибках отделяют от прочих записей. Для этого заводят минимум два
аппендера: консоль и файл. В консоль выводят все сообщения, чтобы программист
был в курсе событий. Ошибки требуют реакции, поэтому их пишут в файл или
пересылают по сети. Позже их анализируют вручную или специальными программами.

В главе про изменяемость мы расскажем, как сделать так, чтобы макрос
\verb|log/error| сводился к вызову \verb|log-error| \page{install-logger}.
Так мы избавимся от импорта \verb|log-error| в каждый модуль, где логируют ошибку.
Однако сейчас об этом говорить преждевременно.

\section{Сбор исключений}

\index{исключения!сбор}

Мы придумали, как выразить исключение текстом. Теперь можно записать его в файл,
отправить письмом или даже распечатать. Недостаток в том, что у текста нет
структуры. С точки зрения кода это поток символов, и неясно, где что. При сборе
ошибок важно выделить ключевые данные: тип, подсистему, модуль. Это нужно по
следующим причинам.

\textbf{Предотвратить дублирование.} Во время наплыва клиентов может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать её в файл, получим
тысячи одинаковых сообщений. Это расточительно в плане ресурсов и затрудняет
поиск.

Сборщик определяет схожесть ошибок по особым правилам. Сообщения <<user 1 not
found>> и <<user 2 not found>> отличаются, но сборщик свернёт их в одну
запись и по запросу покажет остальные.

\textbf{Поиск.} Нельзя построить эффективный поиск без структуры. Когда ошибки в
виде текста, можно искать только по вхождению слова или регулярному
выражению. Такой поиск не релевантен, то есть не учитывает, насколько точно
элемент подходит запросу. Ещё он не отсекает дубли: не хотелось бы видеть тысячу
одинаковых сообщений в выдаче.

\textbf{Статистика.} Когда ошибки разобрали на части, можно строить по ним
отчёты. Например, сколько ошибок случилось за прошлый месяц или
год. Группировать данные по проектам или командам. Выявить проекты, где ошибки
случаются чаще всего.

\textbf{База знаний.} В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты и записи с экрана. На ошибку можно
сослаться в задаче или ревью. Если исключения хранят в логах, это невозможно.

\index{базы данных!Sentry}

Среди прочих систем достойно выглядит \footurl{Sentry}{https://sentry.io}[Sentry][-0mm],
веб-приложение на Django. В нём заводят проекты, которые накапливают ошибки
от клиентов. Чтобы отправить ошибку в Sentry, к нему обращаются по~HTTP методом
POST. В теле передают JSON с различными полями. Sentry предлагает десятки полей,
чтобы описать ошибку. Сюда входят параметры машины, операционной системы, детали
HTTP-запроса, стек-трейс и другие.

\index{библиотеки!Sentry-clj}

Как правило, приложение не собирает эти данные вручную, а~пользуется
библиотеками. Часто они называются Raven или похожим образом. Семантика в том,
что \emph{сторожевой ворон} (анг. raven) несёт вести \emph{дозорному}
(анг. sentry).

Для Clojure написаны библиотеки \footurl{Sentry-clj}{https://github.com/getsentry/sentry-clj}[Sentry-clj][-22mm] и
\footurl{Exoscale Raven}{https://github.com/exoscale/raven}[Exoscale Raven]. Первая опирается на
официальную Java-библиотеку. Добавьте её в~проект:

\begin{english}
  \begin{clojure}
[io.sentry/sentry-clj "0.7.2"]
  \end{clojure}
\end{english}

\index{DSN}

Задайте библиотеке нужный DSN. Под DSN понимают адрес проекта в Sentry. Проект
объединяет сообщения по глобальному признаку: ошибки бекенда в одном проекте,
фронтенда~--- во втором, мобильного приложения~--- в третьем. DSN находится в
настройках проекта в~разделе <<интеграция>>.

\begin{english}
  \begin{clojure}
(require '[sentry-clj.core :as sentry])

(def DSN "https://user:pass@sentry.io/project-id")
(sentry/init! DSN)
  \end{clojure}
\end{english}

Когда библиотека знает DSN, отправим сообщение с помощью функции
\verb|send-event|. Среди прочих параметров нас интересует \verb|:throwable|, в
который передают исключение.

\begin{english}
  \begin{clojure}
(sentry/send-event {:throwable e})
  \end{clojure}
\end{english}

В ответ получим номер события, а в проекте появится новая запись. Предположим,
мы передали экземпляр \verb|e|, цепочку из трёх исключений, которую задали
выше \page{e-sample}. В интерфейсе Sentry мы увидим информацию о каждом звене. В
поле \verb|:extra| окажутся данные верхнего исключения, словарь
\verb|{:user-id 42}|.

Недостаток \verb|sentry-clj| в том, что она передаёт не весь
контекст. Хотелось бы видеть данные всех уровней, а не только верхнего. Иначе мы
не узнаем, какой был токен, по какому адресу мы обратились в сеть и другие
детали. Можно собрать данные вручную и передать в ключ \verb|:extra|, но это
увеличит код.

\index{библиотеки!Raven}

Библиотека Exoscale Raven написана на Clojure и потому учитывает тонкости
языка. С недавней версии она передаёт полные данные об
исключении. Подключите её в проект и отправьте исключение \verb|e|:

\begin{english}
  \begin{clojure}
[exoscale/raven "0.4.13"] ;; project.clj

(require '[raven.client :as raven])
(raven/capture! DSN e)
  \end{clojure}
\end{english}

\begin{listing}[ht!]
  \small

\begin{english}
  \begin{json}
[ {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Get user info error",
  "data": {
    "user-id": 42
  },
  "at": ["clojure.lang.AFn", "applyToHelper", "AFn.java", 160]
}, {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Auth error",
  "data": {
    "token": "........."
  },
  "at": ["clojure.lang.AFn", "applyToHelper", "AFn.java", 160]
} ]
  \end{json}
\end{english}

  \caption{Пример JSON-данных исключения}
  \label{fig:ex-json-data}
\end{listing}

Откройте событие в Sentry и промотайте вниз. В секции \verb|extra| появится ключ
\verb|:via| с детальной информацией. Привёдем её фрагмент \lis{fig:ex-json-data}.
Каждый словарь состоит из класса исключения, сообщения и данных. В поле \verb|:at|
вектор четырёх элементов: класс, метод, имя файла и строка, на которой возникло
исключение. С таким отчётом найти причину будет проще.

\index{clojure.core!Throwable\arr{}map}

Структуру выше получили функцией \verb|Throwable->map|. Она принимает
исключение и отдаёт словарь с ключами \verb|:via|, \verb|:cause| и
другими. Элементы словарей это строки и символы, поэтому результат легко
записать в JSON или EDN.

\section{Sentry и Ring}

\index{Ring!Sentry}

Теперь когда вы знакомы с Sentry, напишем защитный декоратор для
Ring-приложения. Он ловит ошибки, отправляет их в Sentry и~возвращает
нейтральный ответ о том, что запрос не удался. Декоратор ставят на вершину стека
middleware.

\begin{english}
  \begin{clojure/lines}
(require '[raven.client :as r])

(defn wrap-exception
  [handler]
  (fn [request]
    (try
      (handler request)
  \end{clojure/lines}
\end{english}

\wavebottom

Обратите внимание, что запрос к Sentry тоже обёрнут в \verb|try/catch|. Sentry
это отдельный сервис, который может быть недоступен. В этом случае в лог пишут
оба исключения: и первичное, и связанное с Sentry. Если вы забыли, как работают
декораторы и middleware, вернитесь к~главе про веб-разработку \page{decorator}.

\wavetop

\begin{english}
  \begin{minted}[linenos, firstnumber=8]{clojure}
      (catch Exception e
        (let [event (-> nil
                        (r/add-exception! e)
                        (r/add-ring-request! request)
                        (r/add-extra! {:something "else"}))]
          (try
            @(r/capture! DSN event)
  \end{minted}
\end{english}

\wavebottom

Для полной картины мы передаём в Sentry не просто исключение, а событие
\coderef{9}. Мы наращиваем его исключением, запросом Ring и произвольными
данными. Функции \verb|(r/add-<something>)| дополняют событие различными
полями. Raven предлагает функции, чтобы добавить теги, пользователя и другие
сущности.

\wavetop

\begin{english}
  \begin{minted}[linenos, firstnumber=15]{clojure}
            (catch Exception e-sentry
              (log/errorf e-sentry "Sentry error: %s" DSN)
              (log/error e "Request failed"))
            (finally
              {:status 500
               :body "Internal error, please try later"})))))))
  \end{minted}
\end{english}

\index{библиотеки!Manifold}
\index{асинхронность}
\index{синтаксис!@ (дереф)}

Объясним оператор \verb|@| перед вызовом \verb|r/capture!| \coderef{14}. Функция
работает асинхронно за счёт библиотеки \verb|manifold|. Результат это особый
объект \verb|deferred|, похожий на футуру. Даже если в нём случилась ошибка, мы
не узнаем этого, пока не <<дерефнем>> его. Оператор~\verb|@| ещё встретится нам
в будущих главах.

В боевых системах объекты \verb|deferred| обычно не дерефят, а оборачивают в
макросы \verb|d/catch| и \verb|d/chain|, асинхронные аналоги \verb|catch|
и~стрелочного оператора \arr{}. Программирование на \verb|manifold| это
отдельная тема, которой мы не касаемся в этой книге.

\section{Переходы по коду}

\index{исключения!переходы}
\index{GOTO}

До сих пор мы рассматривали исключение как сигнал об ошибке. Вспомним ключевое
свойство: исключение прерывает программу и всплывает, пока его не
поймают. Иногда этим пользуются, чтобы перейти вверх по стеку. Если бросить
условное \verb|MyGOTOException|, а сверху поставить \verb|catch| с этим
классом, получим оператор \verb|GOTO|:

\begin{english}
  \begin{clojure}
(try
  (do-first-step)
  (do-second-step)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-third-step)
  (catch MyGOTOException e
    (println "The third step has been skipped")))
  \end{clojure}
\end{english}

Если \verb|(condition)| вернёт истину, мы пропустим третий шаг. В~литературе
трюк называют <<исключение как способ управления исполнением>>. Это
противоречивая практика; применяйте её осторожно. Код становится не очевидным и
трудным в поддержке.

\index{императивный стиль}

Всё же бывают моменты, когда нужно прервать исполнение. Например, мы
выяснили, что у пользователя нет прав к ресурсу. Усложним задачу: пусть проверок
несколько, и на каждой нужно пресечь запрос. В императивных языках это решается
просто. Код на Python выглядел бы так:

\index{языки!Python}

\begin{english}
  \begin{python}
class AccountHandler(RequestHandler):
  def on_get(self, request):
    if not self.check_params(request):
      return BadRequest("Wrong input data")
    if not self.check_account(request):
      return NotFound("No such an account")
    if not self.check_quotas(request):
      return QuotasReached("Request rate is limited")
    return JSONResponse(self.get_data_from_db())
  \end{python}
\end{english}

В Clojure нет оператора \verb|return|. Результат нескольких форм это результат
последней. Мы не можем расположить несколько \verb|when| на одном уровне друг
под другом. Даже если одна из них вернёт ложь, исполнение перейдет к следующей
форме.

\index{Pyramid of Doom}

Вариант с каскадом \verb|if/else| работает, но выглядит громоздко. По-другому
его называют <<Pyramid of Doom>>. Чем ниже вложенность, тем больше проблем у
разработчика. Ради интереса добавьте условие в~середину кода на Clojure
\lis{fig:clj-pyramid}.

\begin{listing}[ht!]
  \small

\begin{english}
  \begin{clojure}
(defn account-handler [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
  \end{clojure}
\end{english}

\caption{Пример пирамиды на Clojure}
\label{fig:clj-pyramid}

\end{listing}

\index{библиотеки!Ring HTTP Response}
\index{организации!Metosin}

Пирамиду решают разными способами, в том числе исключениями. Библиотека <<Ring
HTTP Response>> предлагает функции, чтобы кидать исключения с HTTP-ответом. В
middleware добавляют декоратор, который ловит такие исключения и возвращает из
них ответ. Добавьте библиотеку в проект:

\begin{english}
  \begin{clojure}
[metosin/ring-http-response "0.9.1"]
  \end{clojure}
\end{english}

\noindent
Напишем \verb|account-handler| по-другому:

\index{модули!ring.util.http-response}

\begin{english}
  \begin{clojure}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]
  (when-not (check-params request)
    (bad-request! "Wrong input data"))
  (when-not (check-account request)
    (not-found! "No such an account"))
  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))
  {:status 200
   :body (get-data-from-db)})
  \end{clojure}
\end{english}

Новый код похож на императивный. Некоторых уязвляет факт, что в Clojure
пользуются императивным подходом. Всё в порядке: наша задача сделать так, чтобы
код был удобным в поддержке. Вопрос парадигмы при этом не важен.

Функции из модуля \verb|ring.util.http-response| бывают с восклицательным
знаком и без него. Это сигнал о том, что функция бросает исключение. Например,
\verb|not-found!| породит \verb|ex-info|, в теле которого HTTP-ответ со
статусом 404.

\index{HTTP!404}

Чтобы схема работала, добавим декоратор \verb|wrap-http-response|. Он ловит
ошибки от функций с восклицательным знаком, достаёт из них ответ и
возвращает клиенту.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.http-response
           :refer [wrap-http-response]])

(def app
  (-> app-naked
      wrap-params
      wrap-session
      wrap-cookies
      wrap-http-response))
  \end{clojure}
\end{english}

Избегайте исключений для прыжков по коду. Убедитесь, что это крайняя мера. Вы
должны что-то выиграть: сократить код или оперативно решить проблему. Если
пришлось идти на этот шаг, возьмите библиотеку, чтобы сослаться на примеры и
документацию.

\index{finally}
\index{контекстный менеджер}

\section{Finally и контекстный менеджер}

Иногда код выполняют в рамках ресурса. Это может быть файл, сокет или транзакция
базы данных. В начале работы ресурс <<открывают>>, а в конце
<<закрывают>>. Открытый ресурс считается занятым. Когда ресурс занят, другие
клиенты не могут пользоваться им в полной мере. Открытый кем-то файл можно
читать, но не менять.

Закрывайте ресурс сразу же, как только в нём отпала нужда. Этому может
помешать ошибка. Если код, который работает с ресурсом, не поймал исключение,
файл или порт останутся открытыми до конца работы. Чтобы закрыть ресурс даже в
случае ошибки, прибегают к~форме \verb|finally|.

Форму ставят последней в \verb|try|. Если ошибки не было, \verb|finally|
выполняется после основного кода из \verb|try|. Когда возникло исключение,
\verb|finally| сработает в промежутке между его появлением и выбросом.

Рассмотрим ручной доступ к файлу: запишем в него несколько
байт. \verb|Finally| гарантирует, что файл закроется, даже если в процессе
возникло исключение \lis{fig:write-file}.

\begin{listing}[ht!]
  \small

\begin{english}
  \begin{clojure}
(import '[java.io File FileWriter])

(let [out (new FileWriter (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
  \end{clojure}
\end{english}

\caption{Ручная работа с файлом}
\label{fig:write-file}

\end{listing}

Чтобы вы не забыли закрыть файл, современные языки предлагают контекстные
менеджеры. Это может быть класс, оператор или макрос. Менеджер исполняет блок
кода с дополнительными эффектами. Перед блоком сработает логика входа, а после
него~--- логика выхода. Последний получит управление даже если блок бросил
исключение. Платформа удержит его, выполнит код выхода и снова бросит.

\index{языки!Python}

Особо изящно менеджер устроен в Python. Это оператор \verb|with|, который
ожидает объект. У объекта должны быть методы \verb|__enter__|
и~\verb|__exit__|, которые сработают при входе и выходе. \verb|With|
применяют для файлов, транзакций базы данных, фикстур в тестах. Пример с~файлом:

\index{файлы}

\begin{english}
  \begin{python}
with open("/path/to/file.txt", "w") as f:
    f.write("test")
  \end{python}
\end{english}

Напишем похожий менеджер для Clojure. Это макрос, который принимает символ и
путь к файлу. Внутри макроса файл связан с~символом. \verb|Finally|
гарантирует, что файл закроется при выходе из блока.

\index{классы!FileWriter}

\begin{english}
  \begin{clojure}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
  \end{clojure}
\end{english}

\noindent
Выполните код и проверьте файл \verb|test.txt|:

\begin{english}
  \begin{clojure}
(with-file-writer [out "test.txt"]
  (.write out "Hello macro!")
  (\ 0 0))
  \end{clojure}
\end{english}

Контекстные менеджеры именуют с префиксом \verb|with-|. Так делают акцент на
том, что код работает в рамках ресурса.

\index{clojure.core!with-open}

В Clojure предусмотрен макрос \verb|with-open|. Это улучшенная версия кода,
что мы написали. В отличии от нашего примера, \verb|with-open| работает с
более абстрактным источником, в том числе и файлом. Выход из макроса, даже с
ошибкой, закрывает источник.

В \verb|finally| нет смысла при работе с коллекциями или чистыми
функциями. Пользуйтесь им только если ресурс занят и должен быть освобожден.

\section{Исключения на предикатах}

\index{исключения!на предикатах}
\index{предикаты!в исключениях}

Система \verb|try/catch| работает на классах и наследовании. Если нужно
поймать особый случай, пишут класс и бросают его экземпляр. Типичный проект на
Java или Python несёт на борту модуль с исключениями. Среди них базовый класс
\verb|ProjectException| и унаследованные от него \verb|UserNotFound|,
\verb|AccessDenied| и другие. Это однообразный код, написанный вручную.

\index{библиотеки!Slingshot}

В главе про Spec мы говорили, что предикаты мощнее типов
\page{type-and-pred}. Это верно и для исключений: если можно поймать их
функцией, не понадобится класс. Подход с предикатами предлагает библиотека
\footurl{Slingshot}{https://github.com/scgilardi/slingshot}[Slingshot][-6mm] (анг. <<рогатка>>). В
ней находятся улучшенные версии \verb|try|, \verb|catch| и~\verb|throw|.

\index{фундаментальность}

Это удивит тех, кто не знаком с Clojure: с помощью макросов в~ней меняют даже
такие фундаментальные вещи как перехват исключений. В других языках подобные
изменения ждут годами, а в Clojure подключают библиотеку.

\index{макросы!try\Plus}
\index{макросы!throw\Plus}

Slingshot содержит макросы \verb|throw+| и \verb|try+|. Они совместимы
с~обычными \verb|throw| и \verb|try|: если заменить старые формы на версии с
плюсом, ничего не изменится. Однако новые формы несут преимущества.

Макрос \verb|throw+| принимает не только исключение, но и любой объект. Лучше
всего на эту роль подходит словарь: он объединяет несколько значений в
ключах. Пример ниже бросит \verb|ex-info| с заданным словарём:

\begin{english}
  \begin{clojure}
(require '[slingshot.slingshot :refer [try+ throw+]])

(throw+ {:user-id 42 :action :create})
  \end{clojure}
\end{english}

Кроме объекта, \verb|throw+| принимает исключение-причину, шаблон сообщения и
параметры подстановки. Обратите внимание, что порядок аргументов отличается от
\verb|ex-info|.

\begin{english}
  \begin{clojure}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e "File error: %s" path))))
  \end{clojure}
\end{english}

\index{предикаты!в исключениях}

Форма \verb|catch| внутри \verb|try+| ловит исключения не только
классами. Slingshot предлагает для этого селекторы и предикаты. Под селектором
понимают вектор, где нечётный элемент это ключ словаря, а чётный~---
значение. Селектор проверяет, что ключи и значения входят в контекст. Если да,
управление переходит в ветку с этим селектором.

\begin{english}
  \begin{clojure/lines}
(try+
 (throw+ {:type ::user-error
          :user 42
          :action :update
          :data {:name "Ivan"}})
 (catch [:type ::user-error] e
   (clojure.pprint/pprint e)))
  \end{clojure/lines}
\end{english}

Когда бросают словарь, добавляют поле \verb|:type| \coderef{2}. В~нём указывают
ключ с текущим пространством, в нашем случае \verb|::user-error|. При отлове
исключений в другом модуле селектор принимает вид
\verb|[:type :book.exceptions/user-error]|. Пространство обещает, что мы не
перехватим другой \verb|:user-error| из чужой библиотеки.

Пример выше напечатает брошенный словарь. Внутри \verb|catch| переменная
\verb|e| ссылается не на исключение, а данные, которые передали
в~\verb|throw+|.

Вместо селектора может быть предикат, функция одного аргумента. Если класс
ошибки \verb|ExceptionInfo|, предикат получит словарь данных, а иначе объект
исключения. Функция должна учесть, что тип аргумента может быть разным. Когда
предикат вернул истину, управление переходит в его ветку \verb|catch|.

\index{сервисы!Amazon S3}

Предикатами пользуются, когда нужно тонкое условие перехвата. Рассмотрим
загрузку файла в Amazon S3. В особых случаях Java SDK бросает исключение уже
после того, как файл загружен. Это случается из-за разницы в контрольных
суммах. Загрузка считается неудачной, и мы должны удалить файл, чтобы он не
занимал место.

К сожалению, в SDK нет класса \verb|ChecksumError| или аналога. Вместо него
приходит обычный \verb|AmazonS3Exception| с длинным текстом. Чтобы выделить
наш случай, сравним сообщение с шаблоном. Вынесем проверку в функцию:

\begin{english}
  \begin{clojure}
(defn aws-checksum-error? [e]
  (and (instance? AmazonS3Exception e)
       (some?
        (re-find
         #"(?i)The Content-Md5 you specified did not match"
         (ex-message e)))))
  \end{clojure}
\end{english}

\noindent
Поместим её в \verb|try+|, чтобы поймать случай с контрольной суммой:

\begin{english}
  \begin{clojure}
(try+
  (s3/put-object ...)
  (catch aws-checksum-error? e
    (s3/delete-object ...)))
  \end{clojure}
\end{english}

Slingshot используют в \footurl{Clj-http}{https://github.com/dakrone/clj-http}[Clj-http],
популярном HTTP-клиенте для Clojure. В случае ошибки он бросает ответ через
\verb|throw+|. Если обернуть запрос в \verb|try+|, получим более тонкий
разбор ошибок. Например, отдельные ветки для статуса 500 и негативного ответа в
целом.

\begin{english}
  \begin{clojure}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 500] e
   (println "The service is unavailable"))
 (catch [:type :client/unexceptional-status] e
   (println "Negative response")))
  \end{clojure}
\end{english}

Slingshot делает ставку на данные, а не классы, что поощряется
в~Clojure. Начинающим не всегда очевидны плюсы этого подхода. Советуем читателю
сперва разобраться с обычными \verb|try/catch|. Подключайте Slingshot только
если чувствуете потребность.

\index{библиотеки!Ex}
\index{организации!Exoscale}

Slingshot не единственный пример <<кложурных>> исключений. Обратите внимание на
\footurl{Ex}{https://github.com/exoscale/ex}[Ex][-3mm]~--- аналог, которым пользуются в
Exoscale. Библиотека учитывает семантику ключей (\verb|:fault|,
\verb|:conflict|), их наследование, поддерживает \verb|manifold| и многое
другое.

\section{Приёмы и функции}

Рассмотрим несколько техник для исключений. Они просты и потому не стоят того,
чтобы выносить их в отдельную библиотеку. Чаще всего их копируют из проекта в
проект с небольшими изменениями.

\index{языки!Lua}

\label{pcall}

\textbf{Безопасный вызов функции.} В языке Lua нет операторов \verb|try| и
\verb|catch|. Чтобы обезопасить вызов от ошибки, используют
\footurl{\verb|pcall|}{https://www.lua.org/pil/8.4.html}[Lua pcall][-3mm]. Это сокращение от
<<protected call>>, защищённый вызов. Иногда приём полезен и в Clojure.

\verb|Pcall| принимает функцию, аргументы и возвращает пару значений. Первое
означает успех выполнения. Если это истина, на втором месте результат
вычислений, а иначе экземпляр ошибки. Версия на Clojure:

\index{функции!pcall}

\begin{english}
  \begin{clojure}
(defn pcall [f & args]
  (try
    [true (apply f args)]
    (catch Exception e [false e])))
  \end{clojure}
\end{english}

\noindent
Для краткости разбейте результат в \verb|let|:

\begin{english}
  \begin{clojure}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println (str "The result is " result-error))
    (println "Failure")))
  \end{clojure}
\end{english}

\index{языки!JavaScript}

В JavaScript популярна другая семантика: функции-колбеки принимают аргументы
\verb|error| и \verb|result|. Функция \verb|pcall-js| это изменённый
вариант \verb|pcall|, который вернёт пару \tuple{ошибка, результат}.

\begin{english}
  \begin{clojure}
(defn pcall-js [f & args]
  (try
    [nil (apply f args)]
    (catch Exception e [e nil])))
  \end{clojure}
\end{english}

\noindent
Разбиение выглядит по-другому:

\begin{english}
  \begin{clojure}
(let [[e user] (pcall-js get-user-by-id 42)]
  (if e
    (println (ex-message e))
    (println user)))
  \end{clojure}
\end{english}

\index{функции!с повтором}

\textbf{Попытки с задержкой.} Иногда сторонний сервис нестабилен, и~к~нему
обращаются несколько раз. Чтобы не копировать код, обернём повтор в
функцию. \verb|Pcall-retry| пытается выполнить целевую функцию за несколько
подходов. Первый удачный вызов станет результатом. Если была ошибка, но попытки
ещё не кончились, функция ждёт и повторяет вызов. Когда попытки
исчерпаны, функция бросит исключение. Внутри используется \verb|pcall|,
который мы задали выше.

\index{функции!pcall-retry}
\index{итерация!loop}

\begin{english}
  \begin{clojure}
(defn pcall-retry [n f & args]
  (loop [attempt n]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do (Thread/sleep (* attempt 1000))
            (recur (inc n)))

        :else (throw res)))))
  \end{clojure}
\end{english}

Это наивная версия, и в реальности её улучшают: меняют стратегию ожидания,
добавляют логи. Однако принцип остаётся прежним.

Любопытно, что функции стыкуются между собой. Построим комбинацию из
\verb|pcall| и \verb|pcall-retry|. Даже если сервис недоступен и мы
стучались в него много раз, получим пару \verb|[ok? result]|.

\begin{english}
  \begin{clojure}
(pcall pcall-retry get-user-by-id 42)
  \end{clojure}
\end{english}

\textbf{Исключения в Loop.} Форма \verb|loop| устроена особо: её часть
\verb|recur| не может быть внутри \verb|try|. Предположим, мы хотим написать
функцию повтора без \verb|pcall|. Фрагмент кода:

\index{итерация}
\index{clojure.core!loop}

\begin{english}
  \begin{clojure}
(defn pcall-retry [n f & args]
  (loop [attempt n]
    ...
    (try
      (apply f args)
      (catch Exception e
        (recur (inc n))))))
  \end{clojure}
\end{english}

Компилятор не примет код с сообщением <<Can only recur from tail
position>>. Чтобы исправить ошибку, нужно вынести \verb|recur| из
\verb|try|. Проще всего это сделать с помощью \verb|pcall| как в примере с
\verb|pcall-retry|.

\textbf{Throw in place.} До сих пор мы кидали исключения с помощью
\verb|ex-info| и \verb|throw|. Первая строит исключение, а вторая
бросает. Совместим их в функцию \verb|error!| и упростим аргументы:

\index{функции!error"!}

\begin{english}
  \begin{clojure}
(defn error! [message & [data e]]
  (throw (ex-info message (or data {}) e)))
  \end{clojure}
\end{english}

\noindent
Чтобы вызвать исключение, нужна только строка, а остальное по желанию:

\begin{english}
  \begin{clojure}
(error! "Error")
(error! "Error" {:type ::error})
(error! "Error" {:type ::error} e)
  \end{clojure}
\end{english}

\textbf{Сообщение с параметрами.} Иногда ошибке достаточно подробной строки. В
этом случае \verb|ex-info| избыточен, потому что требует словарь. Напишем
функцию, которая бросает \verb|Exception| с форматированным сообщением. В
неё передают шаблон и значения подстановки. Частичка \verb|f| на конце
имени означает форматирование.

\index{функции!errorf"!}

\begin{english}
  \begin{clojure}
(defn errorf! [template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(errorf! "Error, user: %s, action: %s" 42 :delete)
  \end{clojure}
\end{english}

\textbf{Безопасный макрос.} Перехват исключений работает и в макросах. Код с
макросами обычно короче и выразительней, чем обычная функция. Следующий пример
показывает, как выполнить код в безопасном режиме, игнорируя ошибку:

\index{макросы!with-safe}

\begin{english}
  \begin{clojure}
(defmacro with-safe [& body]
  `(try
     ~@body
     (catch Exception e#)))
  \end{clojure}
\end{english}

\noindent
Пустая форма \verb|catch| вернёт \verb|nil|. Мы получим его, если случится
ошибка:

\begin{english}
  \begin{clojure}
(with-safe (/ 0 0))
nil
  \end{clojure}
\end{english}

На практике \verb|nil| не всегда означает ошибку, поэтому возвращают ключи
\verb|:error| или \verb|:invalid|. Так работает Spec, которую мы разобрали в
прошлой главе \page{spec-invalid}. Иногда в \verb|catch| добавляют запись в
лог или обращение к Sentry. Подавляйте ошибку только если результат
действительно неважен.

\section{Заключение}

Исключения в Clojure устроены как в Java. Формы \verb|try| и \verb|catch| похожи
на одноимённые операторы. Перехват работает на классах и~наследовании. Чем выше
класс в иерархии, тем больше ошибок он охватывает.

Класс \verb|ExceptionInfo| создан специально для Clojure. Его поле
\verb|data| принимает любой словарь. Тип исключения определяют по полю
\verb|:type| словаря. Функция \verb|ex-info| это конструктор исключения.

У ошибки может быть причина, \verb|cause|. Если вы поймали исключение, но не
знаете, что с ним делать, бросьте новое с контекстом и~ссылкой на исходное. Так
собираются цепочки исключений. Чтобы выяснить причину, пригодятся данные со всей
цепочки, а не только верхнего звена.

Код на вершине приложения решает, что делать с исключением. Лучше всего
отправить его в систему сбора ошибок. На эту роль подходит Sentry и
аналоги. Убедитесь, что клиент для Sentry передаёт всю информацию об ошибке, а не
только стек-трейс.

В ветке \verb|finally| обычно закрывают ресурс, чтобы он не остался занятым
при ошибке. Доступ к ресурсу упрощает контекстный менеджер. Это макрос вида
\verb|with-<something>|, который оборачивает блок кода
в~\verb|try/finally|. Для файлов Clojure предлагает макрос \verb|with-open|.

Иногда исключением пользуются, чтобы перейти в другое место в~коде. Это
противоречивый подход, и на него должны быть причины. Если переходов не
избежать, подключите специальную библиотеку.

Slingshot предлагает улучшенные макросы \verb|try+| и \verb|throw+|. С ними
ошибки ловят не классами, а селекторами и предикатами. Вместо исключений
используют словари.

Ряд функций упрощает контроль за исключениями. Возьмите их на заметку, чтобы
сократить код.
