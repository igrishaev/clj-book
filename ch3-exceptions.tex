\chapter{Исключения}

\index{исключения}

\begin{teaser}
В этой главе мы рассмотрим исключения в Clojure: как они устроены и чем
отличаются от аналогов Java. Когда лучше бросать, а~когда перехватывать
исключения. Что и как писать в лог, чтобы расследовать инцидент было легко.
\end{teaser}

Возможно, читателю покажется странным, что исключениям отдана целая глава. Тему
считают простой: исключения можно кинуть, поймать и записать в лог. В теории
этого хватит, чтобы работать в~проекте.

Исключения просты с технической стороны, но несут обширную семантику. Когда
именно кидать исключения, а когда перехватывать?  Какую полезную информацию они
несут? Куда записывать исключения? Можно ли ловить их предикатами? На практике
мы тонем во множестве частных случаев.

В своих программах новички следуют только положительному пути: пишут код так,
словно исключений не может быть в принципе. Из-за этого в их коде тяжело
расследовать ошибки. Почему сервер ответил с кодом 500? Возможны сотни причин,
по которым запрос не удался. Но запись в~логе слишком скудна, чтобы понять, что
произошло.

Хороший программист внимателен к ошибкам. С опытом становится ясно: экономия на
исключениях не даёт выигрыша. Да, мы быстрее закроем задачу, и кода
получится меньше. Однако позже возникнут задачи на устранение ошибок и их
детализацию.

Исключения в коде столь же равноправны, как и нормальное поведение. Избегайте
мысли, что это недоразумение, которое не случится с~вами. Если в проекте много
задач на непойманные ошибки, это значит, что пора изучить тему.

\section{Основы исключений}

\index{классы!Exception}

Прежде чем углубляться в детали, вспомним, что такое исключения и~как они себя
ведут.

Исключение~--- это объект, чаще всего экземпляр класса \code{Ex\-cep\-ti\-on}. От других
классов он отличается тем, что его можно бросить. В разных языках для
этого служат операторы \code{throw}, \code{raise} и другие.

Брошенный объект прерывает исполнение кода и всплывает по стеку
вызовов. Возможны два исхода: либо его поймали оператором \code{catch} на одном
из уровней, либо перехват не состоялся.

В первом случае мы получим \emph{объект} исключения. С ним обращаются как
обычно: читают поля, вызывают методы, передают в~функции. Дальнейшее поведение
зависит от логики программы. Иногда исключение пишут в лог и завершают
программу, в других случаях продолжают работу.

Когда исключение не поймали, программа завершится с кодом, отличным от
нуля. Если не предусмотрено иное, перед выходом программа запишет исключение в
\code{stderr} (стандартный канал ошибок). Мы увидим его класс, текст и то, что
называют <<стектрейс>>. Это цепочка вызовов, которые прошло исключение с момента
выброса до завершения программы.

\index{исключения!стектрейс}
\index{каналы!stderr}

Отдельные платформы позволяют задать реакцию на непойманное
исключение. Например, записать его в файл или завершить программу особым
способом.

\begin{figure}[ht!]
  \chart{chart-ex-tree}
  \caption{Базовые классы исключений}
  \label{fig:exceptions}
\end{figure}

Clojure~--- это гостевой язык (англ.~hosted language). Он опирается на возможности,
которые предлагает домашняя платформа, \emph{хост}. Исключения~--- одна из
областей, в которую Clojure не вмешивается. По умолчанию Clojure использует
формы \code{try} и \code{catch}, аналогичные Java.

\index{классы!Throwable}

Рассмотрим исключения в Java \fig{fig:exceptions}. Платформа содержит
базовый класс \texttt{Throwable}~--- предок всех исключений. Другие классы наследуют
его и расширяют семантику. Наследники первого уровня~--- это классы \code{Error} и
\code{Exception}. Класс \code{RuntimeException} унаследован от \code{Exception}
и так далее.

\index{классы!IOException}

Пакеты Java несут дополнительные исключения, унаследованные от описанных
выше. Например, \code{java.io.IOException} для ошибок ввода-вывода,
\code{java.net.ConnectException} для сетевых проблем и многие другие. Бросать
\code{Throwable} считается дурным тоном: в этом классе слишком мало информации о
том, что случилось.

В дереве исключений каждый класс дополняет семантику предка. Рассмотрим
исключение \code{FileNotFoundException}. Оно возникает, когда файла не
оказалось на диске. Родословная класса выглядит так:

\ifafive\vspace{3mm}\fi

\linegap

\ifnarrow

\dirtree{%
 .1 Object.
 .2 Throwable.
 .3 Exception.
 .4 IOException.
 .5 FileNotFoundException.
}

\else

\dirtree{%
 .1 java.lang.Object.
 .2 java.lang.Throwable.
 .3 java.lang.Exception.
 .4 java.io.IOException.
 .5 java.io.FileNotFoundException.
}

\fi

\linegap

Схему читают <<объект \arr выбрасываемое \arr исключение \arr ошибка
ввода-вывода \arr файл не найден>>. По имени \texttt{File\-Not\-Found\-Excep\-tion}
легко догадаться, с чем связана проблема. Если же разработчик бросил
\code{Throwable}, это усложнит поиск причины.

Различают checked- и unchecked-исключения, проверяемые и нет. Разница между ними
в семантике. Разработчик должен предвидеть checked-исключения и обработать их в
коде. При чтении файла справедливо ожидать, что его не окажется на диске,
поэтому класс \code{FileNotFoundException} относится к категории checked.

\label{exc-hierarchy}

Предсказать нехватку памяти трудно, поэтому \texttt{Out\-Of\-Memory\-Error}~---
непроверяемое исключение (unchecked). Как и любой ресурс, память ограничена, и
неаккуратный код может её исчерпать. Перехватывать это исключение нет смысла,
поскольку при нехватке памяти система ведёт себя нестабильно.

\index{исключения!checked}
\index{исключения!unchecked}

Классы, унаследованные от \code{Error} и \texttt{Runtime\-Exception},~--- это
непроверяемые исключения (unchecked). Унаследованные от \code{Exception}~---
проверяемые (checked).

\index{исключения!throw}
\index{исключения!catch}

Чтобы бросить исключение, его экземпляр передают в оператор
\code{throw}. Оператор \code{catch} перехватывает исключения. В Java и других
языках он устроен на иерархии классов. Если искомый тип задан как
\code{IOException}, мы поймаем все исключения, унаследованные от этого класса.

Чем выше класс в дереве наследования, тем больше исключений охватит
\code{catch}. Однако в Java считается плохим тоном ловить ошибки классами
\code{Throwable} или \code{Exception}. Современные IDE выдают предупреждение too
wide catch expression, слишком широкий охват. Класс \code{Exception} заменяют на
несколько более точных исключений. Например, отдельно ошибки ввода-вывода, сети
и другие.

Одного класса недостаточно, чтобы понять причину исключения. У
\texttt{FileNotFoundException} нет поля \code{file}, чтобы определить, какой
именно файл не найден. Большинство исключений принимают строку с сообщением об
ошибке. Сообщение должно быть понятно человеку. Из строки <<File
С:/work/test.txt not found>> станет ясно, к~какому файлу мы обращались.

\index{сообщения}

Иногда текста не хватает, чтобы объяснить причину ошибки. Предположим, данные не
прошли валидацию и нам хотелось бы исследовать их позже. Если записать данные в
сообщение, текст получится слишком большим. Это небезопасно: в данных могут быть
личные данные или пароль. Такое сообщение нельзя писать в лог или показывать
пользователю. Даже путь к файлу может выдать важную информацию.

Если нужно сохранить данные для расследования, создают новый класс исключения. У
него отдельное поле для данных, из-за которых произошла ошибка. Поле заполняют в
конструкторе исключения. Сообщение формируют так, чтобы оно не выдало приватную
информацию.

\section{Цепочки и контекст}

\index{исключения!цепочки}

Исключения строятся в цепочку. Каждый экземпляр принимает необязательный
аргумент \code{cause} (англ.~<<причина>>). Он хранит либо \code{Null}, либо
ссылку на другое исключение.

\index{null!в Java}

\index{контекст}

Цепочки образуются, когда код перехватил исключение, но не знает, как с ним
поступить.  Это нормально, потому что на низком уровне код не видит полной
картины. Предположим, метод пишет данные в файл. У него нет полномочий решить,
что делать, если файла нет, поэтому метод бросит исключение. Его перехватит
метод, который тоже не принимает решений. Остаётся бросить новое исключение
со ссылкой на первое. Это и есть цепочка.

В конце управление перейдёт к методу, который знает, что делать. Логика зависит
от типа исключения и бизнес-правил. Если файла нет, программа создаст его или
выполнит поиск в другом месте. Если в~HTTP-запросе произошёл сбой, подождём
секунду и повторим его, а~после третьей попытки завершим программу.

В системе должен быть последний рубеж, где перехватывают все исключения. Если
ошибка дошла до этого уровня, значит, её не поймали правила ниже. Это говорит о
нештатном поведении системы. Клиенту вернут текст о том, что запрос не
прошёл. Чтобы расследовать причину, исключение пишут в лог и передают сборщику
ошибок.

На верхнем уровне кода лежит бизнес-логика. Это шаги, которые диктует
руководство, чтобы развивать компанию. При спуске вниз начинается техническая
часть. Представим, что функция \code{get\_user} находит пользователя по
номеру. Снаружи это чёрный ящик: мы не знаем, откуда приходят
данные. Предположим, функция обращается в~сеть. Выразим это на Python:

\index{языки!Python}

\ifnarrow

\begin{python}
def get_user(id):
  url = "http://api.company.com/" + \
        "user/" + str(id)
  return http.GET(url).body.json()
\end{python}

\else

\begin{python}
def get_user(id):
  url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
\end{python}

\fi

Если вызвать функцию с номером, которого нет в системе, получим исключение
\code{HTTP Error: status 404}. Текст ничего не говорит о пользователе. Если
встретить эту запись в журнале, мы даже не поймём, к~какому сервису обращались.

Чем больше мы углубляемся в технические детали, тем меньше знаем о бизнесе. В
мире HTTP нет понятия пользователя. Известны лишь метод, адрес и другие поля
запроса. Разделим ошибку на две половины. Верхняя часть описывает
бизнес-причину: не найден пользователь с номером~5. Почему? Из-за технического
сбоя: запрос GET к адресу \code{http://api.company.com/user/5} вернул статус
404.

Расставим в коде \code{try} и \code{catch}. Если исключение пришло из
технических недр, дополним его контекстом и отправим наверх. Паттерн называется
\code{re-throw}, повторный выброс. Новый код на Python:

\ifnarrow

\begin{python}
def get_user(id):
  try:
    url = "http://api.company.com/" + \
          "user/" + str(id)
    return http.GET(url).body.json()
  except Exception as e:
    raise Exception ("Cannot fetch " + \
          "user " + str(id)) from e
\end{python}

\else

\begin{python}
def get_user(id):
  try:
    url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  except Exception as e:
    raise Exception("Cannot fetch user " + str(id)) \
      from e
\end{python}

\fi

\index{HTTP!ошибки}

Новое исключение описывает бизнес-проб\-ле\-му и при этом ссылается на
техническую. У ошибки HTTP тоже может быть причина: устаревший сертификат,
проблемы соединения. Так образуется цепочка исключений. В проектах они достигают
пяти и более звеньев.

Спуск по цепочке напоминает допрос. На каждое <<почему>> мы получаем новую пищу
для размышлений, пока не доберёмся до сути. Это не значит, что самое нижнее
исключение важнее других: одно лишь \code{HTTPError} не отвечает на все
вопросы. Важно то, как к нему пришли.

Так работают исключения в промышленных языках: Java, Python и других. У каждой
платформы свои особенности, но в целом картина не меняется. Теперь рассмотрим,
что предлагает Clojure.

\section{Переходим к Clojure}

Чтобы познакомиться с исключением, спровоцируем его. Подойдёт старый
приём~--- поделить число на ноль. Включите REPL и выполните
\code{(/ 1 0)}. Появится текст:

\index{деление на ноль}

\begin{text}
Execution error (ArithmeticException)...
Divide by zero
\end{text}

Это отчёт об ошибке. В зависимости от редактора и настроек оно выглядит
по-разному. Emacs с модулем CIDER откроет буфер \texttt{*cider\-/error*}
с подробной информацией.

\index{Emacs!*cider-error*}
\index{REPL}
\index{исключения!в REPL}

Заметим, что исключение в REPL не завершает его: от нас по-прежнему ждут
команды. REPL перехватывает ошибки и только выводит их на экран. В боевом
запуске программы на Clojure ведут себя как обычно: если в главном потоке не
поймано исключение, программа остановится.

Чтобы поймать исключение, код помещают в форму \code{try}. За ним следует одна и
более \code{catch}. В них указывают, какие классы перехватывать и что делать с
исключением. Вот как безопасно поделить число:

\index{арифметика}

\begin{clojure}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
\end{clojure}

Форма \code{catch} принимает класс и произвольный символ. С ним будет связано
исключение, если управление перейдёт в эту ветку. Далее идёт произвольный код. В
нём исключение доступно как локальная переменная, в нашем случае~\code{e}.

\index{исключения!ex-message}

Мы вывели на экран текст, что вычисления прошли неудачно без объяснения
причин. Внесём ясность: метод \code{.getMessage} вернёт сообщение, которое
получило исключение при создании. С версии 1.10 Clojure предлагает функцию
\code{ex-message}, которая делает то же самое. Для деления на ноль получим более
точную фразу:

\begin{clojure}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println (ex-message e))))
;; Divide by zero
\end{clojure}

Новичков удивит тот факт, что класс \texttt{Arith\-metic\-Excep\-tion} ловит не все
ошибки вычислений. Что случится, если сложить 1 и \code{nil}? Даже если
поместить расчёты в~\code{try/catch}, мы не поймаем исключение:

\ifnarrow

\begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
;; Execution error (NullPointerException)
\end{clojure}

\else

\begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
;; Execution error (NullPointerException)...
\end{clojure}

\fi

\index{NPE}

Дело в том, что классы \texttt{ArithmeticException} и
\texttt{Null\-Pointer\-Exception} не пересекаются. У них разные пути в дереве
наследования, поэтому перехват одного не влияет на другое. Это правильно, потому
что у~классов разная семантика. Ошибка в арифметике~--- не то же самое, что
\code{Null} вместо значения.

\index{исключения!ветки}

Форма \code{try} принимает несколько \code{catch}. Перехватим оба случая:

\pagebreakafive

\begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics"))
  (catch NullPointerException e
    (println "You've got a null value")))
\end{clojure}

Макрос перебирает классы из каждого \code{catch} и остановится на первом
подходящем варианте. Результатом \code{try} станет последнее выражение из блока
\code{catch}, который подошёл. В примере выше результат будет \code{nil}, потому
что его вернёт функция \code{println}. Если ни одна ветка не подошла, исключение
продолжит путь вверх по стеку вызовов.

\index{наследование}

Чем выше класс исключения в дереве, тем больше случаев он покрывает. Если
заменить \code{ArithmeticException} на \code{Throwable}, ветка захватит
любое исключение, будь то деление на ноль или \code{NPE}:

\begin{clojure}
(try
  (/ 1 0)
  (+ 1 nil)
  (catch Throwable e
    (println "I catch everything!")))
\end{clojure}

В отличие от Java, в Clojure нет строгих правил о том, какие исключения
перехватывать. Это остаётся на ваше усмотрение. Здравый смысл подсказывает, что
перехват \code{Throwable} опасен: возникает ложное ощущение, что код работает
без ошибок.

В случае с \code{ArithmeticException} проблема в расчётах, но для \code{NPE} это
не так. \code{Nil} вместо числа говорит о том, что причина в источнике, который
сообщил \code{nil}, а не в арифметике. Вот почему перехват \code{NPE} вреден: он
может пустить вас по ложному следу. Мы подробно изучим эту проблему в главе про
тесты \page{illegal-arg}.

Форму \code{try/catch} с широким охватом ставят на верхний уровень кода. Это
нужно, чтобы программа не остановилась никогда. Так работают веб-серверы,
очереди сообщений, сетевое ПО.

\index{исключения!выброс}

Иногда исключение бросают намеренно, чтобы сообщить о нештатной
ситуации. Оператор \code{new} создаёт новый Java-объект. Ему передают класс и
параметры конструктора. Форма \code{throw} принимает исключение и запускает
механизм выброса.

\ifnarrow

\begin{clojure}
(let [e (new Exception
          "Something is wrong!")]
  (throw e))
\end{clojure}

\else

\begin{clojure}
(let [e (new Exception "Something is wrong!")]
  (throw e))
\end{clojure}

\fi

Сообщение выше неинформативно. Даже если мы указали, что проблема в арифметике
или базе данных, хотелось бы знать, какие именно значения вызвали ошибку. Для
этого сообщение строят функцией \code{format}. Она принимает шаблон и
параметры подстановки:

\index{clojure.core!format}

\ifnarrow

\begin{clojure}
(defn add [a b]
  (if (and a b)
    (+ a b)
    (throw
      (new Exception
        (format
          "Value error, a: %s, b: %s"
          a b)))))
\end{clojure}

\else

\begin{clojure}
(defn add [a b]
  (if (and a b)
    (+ a b)
    (let [message
          (format "Value error, a: %s, b: %s" a b)]
      (throw (new Exception message)))))
\end{clojure}

\fi

\noindent
Если вызвать \code{add} с \code{nil}, сообщение станет понятнее:

\ifnarrow

\begin{clojure}
(add 1 2) ;; 3

(add 1 nil)
;; Execution error at book.exceptions/add
;; Value error, a: 1, b: null
\end{clojure}

\else

\begin{clojure}
(add 1 2) ;; 3

(add 1 nil)
;; Execution error at book.exceptions/add
;; Value error, a: 1, b: null
\end{clojure}

\fi

Функция \code{format} полезна тем, что отображает \code{nil} как
\code{null}. Это преимущество перед \code{str}, которая приводит
\code{nil} к пустой строке. Вариант со \code{str} выглядит так:

\begin{clojure}
(str "Value error, a:" 1 ", b: " nil)
;; Value error, a:1, b:
\end{clojure}

\noindent
Текст вводит в заблуждение: \code{b}~--- это \code{nil} или пустая строка?
В~случае с~\code{format} ошибки быть не может: получим \code{b: null} на конце.

\section{Подробнее о контексте}

\index{контекст!в исключениях}
\index{классы!ExceptionInfo}

Данные в тексте приводят к риску. Сообщение может оказаться слишком большим или
выдать лишние сведения. Проблему решает класс \code{ExceptionInfo}~---
исключение из поставки Clojure. Оно устроено так, чтобы хранить дополнительные
данные. Clojure предлагает ряд функций для работы с этим классом.

Ключевая функция \code{ex-info} создаёт экземпляр \code{ExceptionInfo}. Она
принимает сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если HTTP-запрос не удался, в словарь помещают метод,
адрес и код ответа.

\code{Ex-info} только создаёт исключение, но не бросает его. Результат
передают в \code{throw}:

\ifnarrow

\begin{clojure}
(throw (ex-info
        "Cannot fetch user."
        {:user-id 5
         :http-status 404
         :http-method "GET"
         :http-url
         "https://host.com/users/5"}))
\end{clojure}

\else

\begin{clojure}
(throw (ex-info
        "Cannot fetch user."
        {:user-id 5
         :http-status 404
         :http-method "GET"
         :http-url "https://host.com/users/5"}))
\end{clojure}

\fi

Мы разделили сообщение и данные. Текст не выдаёт номер пользователя и адрес
сервиса. Его запишут в лог или отправят пользователю, а контекст обработают
отдельно.

При работе с контекстом помните несколько правил. Словарь не может быть
\code{nil}. Это редкий случай, когда Clojure отличает \code{nil} от
коллекции. Не храните в словаре значения, которые нельзя записать в файл,
например поток или сетевое подключение. В идеале контекст передают по сети в
формате JSON. Позже мы рассмотрим, что делать с контекстом.

Функция \code{ex-data} вернёт словарь данных, который передали в \code{ex-info}
или конструктор класса \code{ExceptionInfo}. Для других классов результат
функции будет \code{nil}.

\index{исключения!ex-data}

Поймаем исключение: в форме \code{catch} укажем класс
\texttt{Exception\-Info}. Функция \code{ex-data} извлекает словарь, который передали
в \code{ex-info}. Разделим его на поля и построим сообщение.

\ifnarrow

\begin{clojure}
(try
  (get-user 5)
  (catch clojure.lang.ExceptionInfo e
    (let [{:keys [http-method http-url]}
          (ex-data e)]
      (format "HTTP error: %s %s"
        http-method http-url))))
;; HTTP error: GET https://host.com...
\end{clojure}

\else

\begin{clojure}
(try
  (get-user 5)
  (catch clojure.lang.ExceptionInfo e
    (let [{:keys [http-method http-url]} (ex-data e)]
      (format "HTTP error: %s %s" http-method http-url))))
;; HTTP error: GET https://host.com/users/5
\end{clojure}

\fi

\section{Когда бросать исключения}

До сих пор не ясно, когда бросать исключения, а когда ограничиться
проверкой. Рассмотрим типичные ситуации и решения.

При обходе коллекций нет смысла бросать исключения. \code{Nil} ведёт себя как
пустая коллекция того типа, который имеет в виду функция. Выражения:

\begin{clojure}
(assoc nil :test 5)
(update nil :test (fnil inc 0))
(into nil [1 2 3])
(merge nil {:test 5})
\end{clojure}

\noindent
вернут списки и словари. Ключ от \code{nil} вернёт \code{nil}. Разбиение словаря
или вектора сообщит переменным \code{nil}, если поля не совпали. Оба \code{let}
ниже произведут вектор из трёх \code{nil}.

\ifnarrow

\begin{clojure}
(let [{:keys [a b c]} nil]
  [a b c])
\end{clojure}

\splitter

\begin{clojure}
(let [[a b c] nil]
  [a b c])
\end{clojure}

\else

\noindent
\begin{tabular}{ @{}p{5.5cm} @{}p{4cm} }

\begin{clojure}
(let [{:keys [a b c]} nil]
  [a b c])
\end{clojure}

&

\begin{clojure}
(let [[a b c] nil]
  [a b c])
\end{clojure}

\end{tabular}

\fi

\index{nil!punning}

Термин nil punning означает лояльность к \code{nil}. С таким подходом
пустые значения не вызывают ошибок. Нельзя утверждать, что Clojure полностью
nil punning. \code{Nil} дружит с коллекциями, но не работает с~арифметикой
и регулярными выражениями.

\index{spec!valid?}
\index{spec!conform}

Если вы сомневаетесь в коллекции, используйте спеку. Функции \code{s/va\-lid?} и
\code{s/con\-form} из прошлой главы \page{spec-conform} помогут убедиться, что
коллекция верна. Этим вы отделите проверку от работы с данными. Если валидация
не прошла, бросайте исключение. Передайте в контекст данные \code{explain},
чтобы разобрать их позже.

\ifnarrow

\begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::data (s/coll-of int?))

(when-let [explain (s/explain-data
                     ::data
                     [1 2 nil])]
  (throw (ex-info
           "Some item is not an integer"
           {:explain explain})))
\end{clojure}

\else

\begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::data (s/coll-of int?))

(when-let [explain (s/explain-data ::data [1 2 nil])]
  (throw (ex-info "Some item is not an integer"
                  {:explain explain})))
\end{clojure}

\fi

\index{spec}
\index{spec!assert}

Для краткости используйте макрос \code{s/assert} из поставки Spec (не путайте с
обычным \code{assert} из \code{clojure.core}). Он делает то же самое: проверяет
данные и либо возвращает их, либо бросает исключение с данными
\code{explain}. Поведение макроса определяет глобальный флаг
\code{s/check-asserts}. Если его выключить, эффект \code{s/assert} пропадает и
исключений не будет.

\ifnarrow

\begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::ne-string
  (s/and string? not-empty))

(s/check-asserts true)
(s/assert ::ne-string "test") ;; ok

(s/assert ::ne-string nil)
;; Execution error - invalid arguments
;; nil - failed: string?

(s/check-asserts false)
(s/assert ::ne-string nil) ;; nil
\end{clojure}

\else

\begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::ne-string (s/and string? not-empty))

(s/check-asserts true)
(s/assert ::ne-string "test") ;; ok

(s/assert ::ne-string nil)
;; Execution error - invalid arguments
;; nil - failed: string?

(s/check-asserts false)
(s/assert ::ne-string nil) ;; nil
\end{clojure}

\fi

Другой случай, когда прибегают к исключению,~--- отказ ресурса. Если не удалось
прочитать файл, недостаточно просто сказать об этом. Возможны десятки причин:
файла нет, он занят другим процессом, кончилось место на диске, ошибка в
кодировке. От ошибки зависит, кто ей займётся и как не допустить её
снова.

\index{HTTP!404}

В индустрии нет единого мнения о том, бросать ли исключение на негативный
HTTP-ответ. Согласно протоколу, ответ со статусом 404 такой же верный, как и
200. Продвинутые библиотеки предлагают флаг, чтобы управлять этим поведением.

Предположим, наш HTTP-клиент не бросает исключение. Сделаем это вручную:
проверим статус и запустим \code{ex-info} с подробностями:

\index{HTTP!авторизация}

\ifnarrow

\begin{clojure}
(defn authenticate-user [user-id]
  (let [url (str
              "http://auth.company.com/"
              user-id)
        {:keys [status body]}
        (client/get url)]
    (if (= status 200)
      body
      (throw (ex-info
               "Authentication error"
               {:http-url url
                :http-status status
                :http-body body})))))
\end{clojure}

\else

\begin{clojure}
(defn authenticate-user [user-id]
  (let [url (str "http://auth.company.com/" user-id)
        {:keys [status body]} (client/get url)]
    (if (= status 200)
      body
      (throw (ex-info "Authentication error"
                      {:http-url url
                       :http-status status
                       :http-body body})))))
\end{clojure}

\fi

Исключения полезны в библиотеках. На их уровне мы не принимаем бизнес-решений,
потому что не видим всего контекста. Предположим, если библиотека для
изображений не нашла файл, она бросит исключение. Код выше перехватит его и
выполнит запасной сценарий: может быть, скачает изображение из сети, откроет
другой файл или завершится с ошибкой. Но библиотеке неизвестно, что именно
произойдёт, поэтому исключение~--- единственный вариант сообщить о нештатном
поведении.

Представим теперь, что если файла нет, библиотека молча пропустит запись в
файл. Пользователи будут недовольны этим поведением: как убедиться, что всё
прошло без ошибок? Это касается и паттерна <<вернуть \code{nil} и записать
в~лог>>, что значит проигнорировать проблему.

\section{Подробнее о цепочках}

\index{исключения!цепочки}

Рассмотрим цепочки исключений на практике. Функция \code{ex-info}
принимает третий необязательный параметр \code{cause}. Это либо \code{nil},
либо другое исключение, которое станет частью нового. Ниже функция
\code{divide} ловит ошибку арифметики и бросает новое исключение с контекстом.

\pagebreakafive

\index{исключения!cause}

\label{re-throw-example}

\begin{clojure}
(defn divide [a b]
  (try
    (/ a b)
    (catch ArithmeticException e
      (throw (ex-info
               "Calculation error"
               {:a a :b b}
               e)))))
\end{clojure}

Функция \code{ex-cause} возвращает причину исключения. Если её не было,
получим \code{nil}.

\ifnarrow

\begin{clojure}
(try
  (divide 1 0)
  (catch Exception e
    (println (ex-message e))
    (println (ex-message
               (ex-cause e)))))
\end{clojure}

\else

\begin{clojure}
(try
  (divide 1 0)
  (catch Exception e
    (println (ex-message e))
    (println (ex-message (ex-cause e)))))
\end{clojure}

\fi

\noindent
Код выведет:

\begin{text}
Calculation error
Divide by zero
\end{text}

Напишем функцию, которая вернёт список исключений по убыванию
старшинства. На первом месте исходное исключение, на втором~--- его причина, затем
причина причины и так далее. Проще всего это сделать формой \code{loop}:

\index{итерация}
\index{clojure.core!loop}
\index{функции!ex-chain}

\ifnarrow

\begin{clojure}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e)
        (conj result e)))))
\end{clojure}

\else

\begin{clojure}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e) (conj result e)))))
\end{clojure}

\fi

Для экспериментов объявим переменную \code{e}. Это цепь исключений из трёх
звеньев. На первом уровне ошибка бизнес-логики: не удалось извлечь
пользователя. На втором уровне проблема с авторизацией: не хватило прав
доступа. На третьем~--- ошибка транспорта: HTTP-запрос вернул статус 403.

\label{e-sample}

\ifnarrow

\begin{clojure}
(def e
  (ex-info
   "Get user info error"
   {:user-id 5}
   (ex-info
     "Auth error"
     {:token "........."}
     (ex-info
       "HTTP error"
       {:method "POST"
        :url "http://api.site.com"}))))
\end{clojure}

\else

\begin{clojure}
(def e
  (ex-info
   "Get user info error"
   {:user-id 5}
   (ex-info "Auth error"
            {:token "........."}
            (ex-info "HTTP error"
                     {:method "POST"
                      :url "http://api.site.com"}))))
\end{clojure}

\fi

\index{коллекции!обход}

Получилось дерево исключений, но не всегда удобно работать с~деревом: плоская
структура лучше поддаётся обходу. Пригодится функция \code{ex-chain}, которую мы
написали. Вот как получить сообщения всех исключений:

\ifnarrow

\begin{clojure}
(map ex-message (ex-chain e))
;; ("Get user info error"
;;  "Auth error" "HTTP error")
\end{clojure}

\else

\begin{clojure}
(map ex-message (ex-chain e))
;; ("Get user info error" "Auth error" "HTTP error")
\end{clojure}

\fi

\noindent
А так~--- напечатать построчно (получим столбик тех же строк):

\index{печать!исключений}

\begin{clojure}
(doseq [e (ex-chain e)]
  (-> e ex-message println))
\end{clojure}

Выразим \code{ex-chain} короче через \code{iterate}. Это функция, которая на
первом шаге применяет функцию к аргументу, а на последующих~--- к предыдущему
результату. Ограничение \code{take-while} нужно, чтобы остановиться перед первым
пустым элементом.

\ifnarrow

\begin{clojure}
(defn ex-chain [e]
  (take-while some?
    (iterate ex-cause e)))
\end{clojure}

\else

\begin{clojure}
(defn ex-chain [e]
  (take-while some? (iterate ex-cause e)))
\end{clojure}

\fi

\section{Печать исключений}

Что-то пошло не так, и мы оказались в ветке \code{catch}. На исключение
указывает локальная переменная. Как с ней поступить?

Самое простое, что можно сделать с исключением,~--- напечатать в~консоль. Функция
\code{println} достаточно умна: перед выводом она переводит исключение в
словарь. Это удобно для редакторов и IDE, потому что словарь легко разобрать на
части. Например, показать только ту часть стек-трейса, что касается Clojure.

Последнее исключение в цепочке называют корнем, root. Для удобства
\code{println} дублирует корень в начале, чтобы сразу было видно
первопричину. Вот что выведет \code{(println e)}:

\index{печать!исключений}

\ifnarrow

\begin{clojure}
#error {
 :cause HTTP error
 :data {:method POST,
        :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 5}}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:token .........}}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST,
          :url http://api.site.com}}]
 :trace
 [[clojure.lang.AFn applyToHelper ......]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler......]
  ..........]}
\end{clojure}

\else

\begin{clojure}
#error {
 :cause HTTP error
 :data {:method POST, :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 5}}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:token .........}}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST, :url http://api.site.com}}]
 :trace
 [[clojure.lang.AFn applyToHelper AFn.java 156]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler$InvokeExpr eval 3701]
  ..........]}
\end{clojure}

\fi

\index{языки!Java}
\index{стектрейс}

Вектор \code{:trace} называют стек-трейсом. Это методы Java, по которым прошло
исключение с момента выброса до перехвата. Каждый элемент трейса~--- вектор с
именем класса, метода, файла и номера строки.

Мы сократили трейс, чтобы не тратить на него место. В реальности трейсы занимают
несколько экранов. Важно понимать, что они показывают не Clojure-, а Java-код,
который получился в результате компиляции. Исследуя трейс, вы должны мысленно
проделать обратное: сопоставить методы и классы с вашим кодом на Clojure. Это не
всегда просто и сбивает с толку новичков. Шумные трейсы~--- справедливый упрёк
в адрес Clojure. С другой стороны, ими страдают многие JVM-языки.

\index{модули!clojure.stacktrace}

В пакете \code{clojure.stacktrace} несколько функций для печати
исключений. \code{Print-throwable} выводит сообщение и контекст:

\ifnarrow

\begin{clojure}
(require '[clojure.stacktrace :as trace])

(trace/print-throwable e)
;; clojure.lang.ExceptionInfo:
;; Get user info error
;; {:user-id 5}
\end{clojure}

\else

\begin{clojure}
(require '[clojure.stacktrace :as trace])

(trace/print-throwable e)
;; clojure.lang.ExceptionInfo: Get user info error
;; {:user-id 5}
\end{clojure}

\fi

Макрос \code{with-out-str} перехватывает вывод в консоль. Код ниже ничего не
печатает, но вернёт строку:

\ifnarrow

\begin{clojure}
(with-out-str
  (trace/print-stack-trace
    e))
\end{clojure}

\else

\begin{clojure}
(with-out-str
  (trace/print-stack-trace e))
\end{clojure}

\fi

Функции \texttt{print\-/stack\-/trace} и~\texttt{print\-/cause\-/trace} печатают
трейс с~небольшими отличиями. В числе прочего они принимают параметр \code{n},
чтобы задать глубину трейса.

\section{Логирование}

\index{логирование}

Вывод в консоль помогает в отладке, но не подходит для боевого
запуска. Перечислим, чего ожидают от кода, который ловит исключения.

Для любого сообщения важны его вспомогательные данные: время, модуль, имя
окружения (test, prod). Сообщения различают по уровню важности: информационное,
предупреждение, тревога и другие. Функция печати не даёт этих сведений, а их
ручной сбор увеличит код.

Если программа работает на многих серверах, сбор сообщений должен быть
централизован. Представьте, что сотрудник переключается между сотней машин,
чтобы читать логи,~--- это никуда не годится. Если сообщение пришло по сети,
нужно запомнить адрес источника.

Не все сообщения одинаково важны. Иногда библиотеки порождают сотни отладочных
сообщений в минуту. Нужен механизм, чтобы отбрасывать их по некоторым признакам.

Наконец, консоль и файл~--- не единственные каналы данных. Особо важные
сообщения пишут в журнал операционной системы, шлют на почту, в чат или в СМС
ответственным лицам.

Указанные проблемы решает логирование~--- система, которая принимает сообщения и
пересылает в нужные каналы. Библиотека \texttt{clojure.\-tools.\-logging} предлагает
функции и макросы, чтобы логировать сообщения. Это сторонний проект, поэтому
добавьте зависимость:

\index{библиотеки!clojure.tools.logging}

\begin{clojure}
[org.clojure/tools.logging "0.4.1"]
\end{clojure}

\noindent
Запишем простое сообщение:

\ifnarrow

\begin{clojure}
(require
  '[clojure.tools.logging :as log])
(log/info "A message from my module")
\end{clojure}

\else

\begin{clojure}
(require '[clojure.tools.logging :as log])
(log/info "A message from my module")
\end{clojure}

\fi

\noindent
В REPL появится строка с этим сообщением. По умолчанию лог добавляет к нему
уровень важности. В нашем случае это информационное сообщение, \code{INFO}.

\begin{text}
INFO: A message from my module
\end{text}

В Clojure логирование устроено из двух уровней. Первый~--- входная точка,
макросы \code{log/info}, \code{log/error} и другие. Второй уровень называют
бэкендом. Под ним понимают Java-библиотеку, которая выполняет основную работу:
пишет сообщения в файлы, отправляет их по сети и так далее.

Такое устройство несёт преимущества. Исторически сложилось так, что для Java
написано много библиотек логирования. Каждая из них предлагает свои классы и
методы. Если проект использует конкретный Java-бэкенд, не получится сменить его
без правок в коде.

\index{логирование!бекэнды}
\index{библиотеки!Logback}
\index{библиотеки!Log4j}

В Clojure эту проблему решили дизайном. На старте модуль \code{logging} ищет
библиотеки \code{Logback}, \code{Log4j} и другие. Если ничего не найдено, он
использует стандартный пакет \code{java.util.logging}. Внутри вызов
\code{log/info} сводится к вызову класса из найденной библиотеки.

Чтобы нужный бэкенд <<подхватился>>, добавьте его в зависимости. Среди библиотек
для логирования особенно популярен проект \code{Logback}. От аналогов его
отличает большой выбор \emph{аппендеров} (англ.~appenders). Так называют пункт
назначения, куда писать сообщения. Это может быть файл, удалённый syslog,
почтовый сервер.

\pagebreaklarge

Добавьте Logback к проекту:

\begin{clojure}
[ch.qos.logback/logback-classic "1.2.3"]
\end{clojure}

\index{форматы!XML}

Библиотеки логирования ищут настройки в стандартных местах. Если в папку
\code{resources} положить XML-файл для бэкенда, он прочтёт его на
старте. Запишите туда следующий файл \code{logback.xml}:

\ifnarrow

\begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT"
    class="...ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>
  %date %-5level %logger{36} - %msg %n
      </pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
\end{xml}

\else

\begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="...ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>
        %date %-5level %logger{36} - %msg %n
      </pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
\end{xml}

\fi

\index{даты!в логах}

Мы задали appender для вывода в консоль. В теге \code{pattern} указан шаблон
сообщения. Параметры шаблона начинаются со знака процента. Подстановка
\code{\%msg} означает сообщение, \code{\%date}~--- текущую дату. Её формат
задают в фигурных скобках, например \code{\%date\{ISO8601\}}. Залогируйте
что-нибудь с новыми настройками (чтобы изменения вступили в силу, перезапустите
REPL). Вывод изменится:

\ifnarrow

\begin{clojure}
(log/info "Hello Logback!")
;; 2019-05-03 17:36:04,001
;; INFO book.exceptions - Hello Logback!
\end{clojure}

\else

\begin{clojure}
(log/info "Hello Logback!")
;; 2019-05-03 ... INFO book.exceptions - Hello Logback!
\end{clojure}

\fi

\label{log-ex-param}

\section{Контекст исключений}

Макросы \code{log/info}, \code{log/error} и другие допускают, что первым
аргументом может быть не текст, а исключение. Выше мы объявили переменную
\code{e} для экспериментов. Запишем её в лог:

\ifnarrow

\begin{clojure}
(log/error e "HTTP Error")

;; 2019-05-03 17:41:03,913
;; ERROR book.exceptions - HTTP Error
;; clojure.lang.ExceptionInfo:
;; Get user info error
;; at java.lang.Thread.run .........
\end{clojure}

\else

\begin{clojure}
(log/error e "HTTP Error")

2019-05-03 ... ERROR book.exceptions - HTTP Error
clojure.lang.ExceptionInfo: Get user info error
    at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
    at ...$InvokeExpr.eval(Compiler.java:3701)
    ... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
    at ...$InvokeExpr.eval(Compiler.java:3701)
    ... 31 common frames omitted
\end{clojure}

\fi

Для экономии мы удалили часть трейса. Из примера видно, что цепочка состоит из
трёх звеньев~--- как и задано в \code{e} \page{e-sample}. Проблема в том, что у
каждого звена пропали данные. Logback не подозревает, что поле \code{data}
класса \texttt{ExceptionInfo} так важно для нас.

\index{логирование!исключений}

Библиотека предлагает несколько шаблонов для исключения: \code{\%xEx},
\code{\%xException} и другие. Они влияют на длину и детализацию трейса, но
игнорируют данные. Похоже ведут себя Log4j и другие проекты.

В Java проблему решают новым классом. Как правило, бэкенд логирования предлагает
класс, который переводит исключение в строку. Его наследуют и заменяют нужный
метод. В настройках логирования указывают путь к новому классу.

Способ работает и в Clojure, но с неудобствами. Чтобы наследовать класс в
Clojure, нужен отдельный модуль с директивой \code{:gen-class}. Придётся читать
документацию к библиотеке, исследовать её классы и~интерфейсы. Решение будет
завязано на конкретный бэкенд. Если проект переедет на Log4j, придётся
наследовать другой класс. Это не тот способ, которому следуют в Clojure.

Для начала напишем функцию \code{ex-print}, которая печатает исключение так, как
это удобно нам. С помощью \code{ex-chain} мы обходим звенья и для каждого
выводим его класс, сообщение и контекст. Чтобы визуально отделить части,
используем отступы и функцию красивой печати с форматированием.

\iflarge\vspace{15mm}\pagebreak[4]\fi

\index{печать!исключений}
\index{функции!ex-print}

\ifnarrow

\begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e
                   class
                   .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
\end{clojure}

\else

\begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
\end{clojure}

\fi

Результат выглядит приятнее, чем пирамида трейсов. Чётко видны данные,
которые привели к ошибке:

\ifnarrow

\begin{clojure}
(ex-print e)

clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 5}
clojure.lang.ExceptionInfo
  Auth error
  {:token "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST",
   :url "http://api.site.com"}
\end{clojure}

\else

\begin{clojure}
(ex-print e)

clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 5}
clojure.lang.ExceptionInfo
  Auth error
  {:token "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
\end{clojure}

\fi

\index{печать!перехват}
\index{clojure.core!with-out-str}

Добавим функцию \code{log-error} для логирования ошибок. Это обёртка над
макросом \code{log/error} с небольшой разницей: в него попадает не экземпляр
исключения, а готовый текст, полученный из \code{ex-print}. Чтобы перехватить
вывод на печать в строку, вызов оборачивают в макрос \code{with-out-str}.

\pagebreakafive

\begin{clojure}
(defn log-error
  [^Throwable e & [^String message]]
  (log/error
   (with-out-str
     (println (or message "Error"))
     (ex-print e))))
\end{clojure}

Вторым аргументом в \code{log-error} передают сообщение. Если его нет, запишем
нейтральное Error. Примеры:

\begin{clojure}
(log-error e)
(log-error e "HTTP Error 500")
\end{clojure}

Второй вызов запишет в лог следующее:

\ifnarrow

\begin{text}
2019-05-03 19:00:05,590 ERROR
book.exceptions - HTTP Error 500
clojure.lang.ExceptionInfo
  Get user info error
  ...
\end{text}

\else

\begin{text}
2019-05-03 ... ERROR book.exceptions - HTTP Error 500
clojure.lang.ExceptionInfo
  Get user info error
  ...
\end{text}

\fi

Доработайте \code{log-error} так, чтобы сообщение было шаблоном, а~функция
принимала параметры подстановки по аналогии с \code{format}:

\ifnarrow

\begin{clojure}
(log-error e
  "Cannot find user %s, status %s"
  5 404)
\end{clojure}

\else

\begin{clojure}
(log-error e "Cannot find user %s, status %s" 5 404)
\end{clojure}

\fi

В главе про изменяемость мы расскажем, как сделать так, чтобы макрос
\code{log/error} сводился к вызову \code{log-error} \page{install-logger}.  Так
мы избавимся от импорта \code{log-error} в каждый модуль, где логируют ошибки.
Однако сейчас об этом говорить преждевременно.

\section{Сбор исключений}

\index{исключения!сбор}

Сообщения об ошибках отделяют от прочих записей. Для этого заводят минимум два
аппендера: консоль и файл. В консоль выводят все сообщения, чтобы программист
был в курсе событий. Ошибки требуют реакции, поэтому их пишут в файл или
пересылают по сети. Позже их анализируют вручную или специальными программами.

Выше мы разобрали, как привести исключение в текст со всеми
подробностями. Теперь можно записать его в файл, отправить письмом или даже
распечатать. Недостаток в том, что у текста нет структуры. С точки зрения кода
это поток символов, и неясно, где что. При сборе ошибок важно выделить ключевые
данные: тип, подсистему, модуль. Это нужно по следующим причинам.

\textbf{Предотвратить дублирование.} Во время наплыва клиентов может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать её в файл, получим
тысячи одинаковых сообщений. Это расточительно в плане ресурсов и затрудняет
поиск.

Сборщик определяет схожесть ошибок по особым правилам. Сообщения <<user~1 not
found>> и <<user~2 not found>> отличаются, но сборщик свернёт их в одну запись и
по запросу покажет остальные.

\textbf{Поиск.} Нельзя построить эффективный поиск без структуры. Когда ошибки
хранятся в виде текста, можно искать только по вхождению слова или регулярному
выражению. Такой поиск нерелевантен, то есть не учитывает, насколько точно
элемент подходит запросу. Ещё он не отсекает дубли: не хотелось бы видеть тысячу
одинаковых сообщений в выдаче.

\textbf{Статистика.} Когда ошибки разобрали на части, можно строить по ним
отчёты. Например, сколько ошибок случилось за прошлый месяц или
год. Группировать данные по проектам или командам. Выявить проекты, где ошибки
случаются чаще всего.

\textbf{База знаний.} В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты и записи с экрана. На ошибку можно
сослаться в задаче или ревью. Если исключения хранят в логах, это невозможно.

\index{базы данных!Sentry}

Среди прочих систем достойно выглядит \footurl{Sentry}{https://sentry.io}[Sentry],
веб-при\-ло\-же\-ние на Django. В нём заводят проекты, которые накапливают ошибки
от клиентов. Чтобы отправить ошибку в Sentry, к нему обращаются по~HTTP методом
POST. В теле передают JSON с различными полями. Sentry предлагает десятки полей,
чтобы описать инцидент. Сюда входят параметры машины, операционной системы, детали
HTTP-запроса, стек-трейс и другие.

\index{библиотеки!Sentry-clj}

Как правило, приложение не собирает эти данные вручную, а~пользуется
библиотеками. Часто они называются Raven или похожим образом. Семантика в том,
что сторожевой ворон (англ.~raven) несёт вести дозорному (англ.~sentry).

Для Clojure написаны библиотеки
\footurl{Sentry-clj}{https://github.com/getsentry/sentry-clj}[Sentry-clj] и
\footurl{Exoscale Raven}{https://github.com/exoscale/raven}[Exoscale Raven].
Первая опирается на официальную Java-библиотеку. Добавьте её в~проект:

\begin{clojure}
[io.sentry/sentry-clj "0.7.2"]
\end{clojure}

\index{DSN}

Задайте библиотеке нужный DSN. Под DSN понимают адрес проекта в Sentry. Проект
объединяет сообщения по глобальному признаку: ошибки бэкенда в одном проекте,
фронтенда~--- во втором, мобильного приложения~--- в третьем. DSN находится в
настройках проекта в~разделе <<интеграция>>.

\ifnarrow

\begin{clojure}
(require '[sentry-clj.core :as sentry])

(def DSN
 "https://user:pass@sentry.io/projectid")
(sentry/init! DSN)
\end{clojure}

\else

\begin{clojure}
(require '[sentry-clj.core :as sentry])

(def DSN "https://user:pass@sentry.io/project-id")
(sentry/init! DSN)
\end{clojure}

\fi

Когда DSN установлен, отправим сообщение при помощью функции
\texttt{send\-/event}. Среди прочих параметров нас интересует \code{:message} с
текстом и \code{:throwable}, в который передают исключение.

\begin{clojure}
(sentry/send-event {:message "some error"
                    :throwable e})
\end{clojure}

В ответ получим номер события, а в проекте появится новая запись. Предположим,
мы передали экземпляр \code{e}, цепочку из трёх исключений, которую задали
выше \page{e-sample}. В интерфейсе Sentry мы увидим информацию о каждом звене. В
поле \code{:extra} окажутся данные верхнего исключения, словарь
\code{{:user-id 5}}.

Недостаток \code{sentry-clj} в том, что она передаёт не весь
контекст. Хотелось бы видеть данные всех уровней, а не только верхнего. Иначе мы
не узнаем, какой был токен, по какому адресу мы обратились в сеть и другие
детали. Можно собрать данные вручную и передать их в ключ \code{:extra}, но это
увеличит код.

\index{библиотеки!Raven}

Библиотека Exoscale Raven написана на Clojure и потому учитывает тонкости
языка. С недавней версии она передаёт полные данные об
исключении. Подключите её в проект и отправьте исключение \code{e}:

\begin{clojure}
[exoscale/raven "0.4.13"] ;; project.clj

(require '[raven.client :as raven])
(raven/capture! DSN e)
\end{clojure}

%% \ifafive{}\else\lis{fig:ex-json-data}\fi

Откройте событие в Sentry и промотайте вниз. В секции \code{extra} появится ключ
\code{:via} с детальной информацией. Привёдем её фрагмент ниже. Каждый словарь
состоит из класса исключения, сообщения и данных. В поле \code{:at} вектор
четырёх элементов: класс, метод, имя файла и строка, на которой возникло
исключение. С таким отчётом найти причину будет проще.

%% \ifafive\else
%% \begin{listing}[ht!]
%% \fi

\ifnarrow

\begin{json}
[ {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Get user info error",
  "data": {
    "user-id": 5
  },
  "at": ["clojure.lang.AFn",
         "applyToHelper", "AFn.java"...]
}, {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Auth error",
  "data": {
    "token": "........."
  },
  "at": ["clojure.lang.AFn",
         "applyToHelper", "AFn.java"...]
} ]
\end{json}

\else

\iflarge

\begin{json}
[ {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Get user info error",
  "data": {"user-id": 5},
  "at": ["clojure.lang.AFn", "...", "AFn.java", 160]
}, {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Auth error",
  "data": {"token": "........."},
  "at": ["clojure.lang.AFn", "...", "AFn.java", 160]
} ]
\end{json}

\else

\begin{json}
[ {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Get user info error",
  "data": {
    "user-id": 5
  },
  "at": ["clojure.lang.AFn", "...", "AFn.java", 160]
}, {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Auth error",
  "data": {
    "token": "........."
  },
  "at": ["clojure.lang.AFn", "...", "AFn.java", 160]
} ]
\end{json}

\fi

\fi

%% \ifafive\else
%% \caption{Пример JSON-данных исключения}
%% \label{fig:ex-json-data}
%% \end{listing}
%% \fi

\index{clojure.core!Throwable\arr{}map}

Структуру выше получили функцией \texttt{Throw\-able->map}. Она принимает
исключение и отдаёт словарь с ключами \code{:via}, \code{:cause} и
другими. Элементы словарей~--- строки и символы, поэтому результат легко
записать в JSON или EDN.

\section{Sentry и Ring}

\index{Ring!Sentry}

Теперь, когда вы знакомы с Sentry, напишем защитный декоратор для
Ring-приложения. Он ловит ошибки, отправляет их в Sentry и~возвращает
нейтральный ответ о том, что запрос не удался. Декоратор ставят на вершину стека
middleware.

\begin{clojure/lines}
(require '[raven.client :as r])

(defn wrap-exception
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        (report-exception request e)
        {:status 500
         :body "Internal error"}))))
\end{clojure/lines}

Главное место декоратора приходится на девятую строку. Именно здесь мы решаем,
что делать с исключением в HTTP-запросе. Чтобы не усложнять код, вынесем эту
часть в отдельную функцию. Вместе с исключением она принимает запрос, чтобы
зафиксировать его метод и путь. Функция довольная плотная, поэтому рассмотрим её
по частям.

\ifnarrow

\begin{clojure/lines}
(defn report-exception [request e]
 (let
   [event
    (-> nil
     (r/add-exception! e)
     (r/add-ring-request! request)
     (r/add-extra! {:some "data"}))]
\end{clojure/lines}

\else

\begin{clojure/lines}
(defn report-exception [request e]
  (let [event (-> nil
                  (r/add-exception! e)
                  (r/add-ring-request! request)
                  (r/add-extra! {:some "data"}))]
\end{clojure/lines}

\fi

Мы передаём в Sentry не просто исключение, а событие \coderef{2}. Сперва мы
наращиваем его исключением, запросом Ring и произвольными данными. Функции
\code{(r/add-...)} дополняют событие различными полями. Raven предлагает
функции, чтобы добавить теги, пользователя и другие сущности. Второй этап~---
безопасно отправить событие:

\ifnarrow

\begin{clojure/lines*}{firstnumber=6}
(try
  @(r/capture! DSN event)
  (catch Exception e-sentry
    (log/errorf
      e-sentry "Sentry error: %s" DSN)
    (log/error e "Request failed")))))
\end{clojure/lines*}

\else

\begin{clojure/lines*}{firstnumber=6}
    (try
      @(r/capture! DSN event)
      (catch Exception e-sentry
        (log/errorf e-sentry "Sentry error: %s" DSN)
        (log/error e "Request failed")))))
\end{clojure/lines*}

\fi

Обратите внимание, что запрос к Sentry тоже обёрнут в \code{try/catch}. Sentry~---
это отдельный сервис, который может быть недоступен. В этом случае в лог пишут
оба исключения: и первичное, и связанное с Sentry. Если вы забыли, как работают
декораторы и middleware, вернитесь к~главе про веб-разработку \page{decorator}.

\index{библиотеки!Manifold}
\index{асинхронность}
\index{синтаксис!@ (дереф)}

Объясним оператор \code{@} перед вызовом \texttt{r/cap\-tu\-re!} \coderef{7}.
Функция работает асинхронно за счёт библиотеки Manifold. Её результат~--- особый
объект \code{deferred}, похожий на футуру. Даже если в нём случилась ошибка, мы
не узнаем этого, пока не <<дерефнем>> его. Оператор~\code{@} ещё встретится нам
в будущих главах.

В боевых системах объекты \code{deferred} обычно не дерефят, а оборачивают в
макросы \code{d/catch} и \code{d/chain}, асинхронные аналоги \code{catch}
и~стрелочного оператора \arr{}. Программирование на Manifold~--- это
отдельная тема, которой мы не касаемся в этой книге.

\section{Переходы по коду}

\index{исключения!переходы}
\index{GOTO}

До сих пор мы рассматривали исключение как сигнал об ошибке. Вспомним ключевое
свойство: исключение прерывает программу и всплывает, пока его не
поймают. Иногда этим пользуются, чтобы перейти вверх по стеку. Если бросить
условное \code{MyGOTOException}, а сверху поставить \code{catch} с этим
классом, получим оператор \code{GOTO}:

\ifnarrow

\begin{clojure/lines}
(try
  (do-step-1)
  (do-step-2)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-step-3)
  (catch MyGOTOException e
    (println "The third step
                  has been skipped")))
\end{clojure/lines}

\else

\begin{clojure/lines}
(try
  (do-step-1)
  (do-step-2)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-step-3)
  (catch MyGOTOException e
    (println "The third step has been skipped")))
\end{clojure/lines}

\fi

Если \code{(condition)} в четвёртой строке вернёт истину, мы пропустим третий
шаг, потому что окажемся в \code{catch}. В~литературе трюк называют <<исключение
как способ управления исполнением>>. Это противоречивая практика; применяйте её
осторожно. Код становится неочевидным и трудным в поддержке.

\index{императивный стиль}

Всё же бывают моменты, когда подобные переходы полезны. Например, мы выяснили,
что у пользователя нет прав к ресурсу. Усложним задачу: пусть проверок
несколько, и на каждой нужно пресечь запрос. В императивных языках это решается
просто. Код на Python выглядел бы так:

\index{языки!Python}

\ifnarrow

\begin{python}
class AccountHandler(RequestHandler):

  def on_get(self, request):

    if not self.check_params(request):
      return BadRequest("Wrong input")

    if not self.check_account(request):
      return NotFound("No such an acc")

    if not self.check_quotas(request):
      return QuotasReached(
             "Request rate is limited")

    return JSONResponse(self.get_data())
\end{python}

\else

\begin{python}
class AccountHandler(RequestHandler):
  def on_get(self, request):

    if not self.check_params(request):
      return BadRequest("Wrong input data")

    if not self.check_account(request):
      return NotFound("No such an account")

    if not self.check_quotas(request):
      return QuotasReached("Request rate is limited")

    return JSONResponse(self.get_data_from_db())
\end{python}

\fi

В Clojure нет оператора \code{return}. Результат нескольких форм~--- это результат
последней. Мы не можем расположить несколько \code{when} на одном уровне друг
под другом. Даже если одна из них вернёт ложь, исполнение перейдёт к следующей
форме.

\index{Pyramid of Doom}

Вариант с каскадом \code{if/else} работает, но выглядит громоздко. По-другому
его называют Pyramid of Doom. Чем ниже вложенность, тем больше проблем у
разработчика. Ради интереса добавьте условие в~середину подобного кода на
Clojure:

\ifnarrow

\begin{clojure}
(defn account-handler [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached
          "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
\end{clojure}

\else

\begin{clojure}
(defn account-handler [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
\end{clojure}

\fi

\index{библиотеки!Ring HTTP Response}
\index{организации!Metosin}

Пирамиду решают разными способами, в том числе исключениями. Библиотека Ring
HTTP Response предлагает функции, чтобы кидать исключения с HTTP-ответом. В
middleware добавляют декоратор, который ловит такие исключения и возвращает из
них ответ. Добавьте библиотеку в проект:

\begin{clojure}
[metosin/ring-http-response "0.9.1"]
\end{clojure}

Напишем другую версию \code{account-handler} с исключениями:

\index{модули!ring.util.http-response}

\ifnarrow

\begin{clojure}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]

  (when-not (check-params request)
    (bad-request! "Wrong input data"))

  (when-not (check-account request)
    (not-found! "No such an account"))

  (when-not (check-quotas request)
    (enhance-your-calm!
      "Request rate is limited"))

  {:status 200
   :body (get-data-from-db)})
\end{clojure}

\else

\iflarge

\begin{clojure}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]

  (when-not (check-params request)
    (bad-request! "Wrong input data"))

  (when-not (check-account request)
    (not-found! "No such an account"))
\end{clojure}

\begin{clojure}
  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))

  {:status 200
   :body (get-data-from-db)})
\end{clojure}

\else

\ifafive

\begin{clojure}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]

  (when-not (check-params request)
    (bad-request! "Wrong input data"))

  (when-not (check-account request)
    (not-found! "No such an account"))
\end{clojure}

\vspace{10mm}\pagebreak

\begin{clojure}
  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))

  {:status 200
   :body (get-data-from-db)})
\end{clojure}

\else

\begin{clojure}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]

  (when-not (check-params request)
    (bad-request! "Wrong input data"))

  (when-not (check-account request)
    (not-found! "No such an account"))

  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))

  {:status 200
   :body (get-data-from-db)})
\end{clojure}

\fi

\fi

\fi

Функции из модуля \texttt{ring.util.http\-/response} бывают с восклицательным
знаком и без него. Это сигнал о том, что функция бросает исключение. Например,
\code{not-found!} бросит \code{ex-info}, в теле которого HTTP-ответ со статусом
404. В же то время \code{not-found} (без знака на конце) просто вернёт ответ.

Новый код похож на императивную версию на Python. Некоторых уязвляет факт, что в
Clojure пользуются императивным подходом. Всё в порядке: наша задача сделать
так, чтобы код был простым и удобным в поддержке. Вопрос парадигмы при этом не
важен.

\index{HTTP!404}

Чтобы схема работала, добавим декоратор \texttt{wrap\-/http\-/response}. Он ловит
ошибки от функций с восклицательным знаком, достаёт из них ответ и возвращает
клиенту. Таким образом, вызов \code{(not-found! "...")} приведёт к ожидаемому
ответу 404, а не ошибке сервера 500.

\begin{clojure}
(require '[ring.middleware.http-response
           :refer [wrap-http-response]])

(def app
  (-> app-naked
      wrap-params
      wrap-session
      wrap-cookies
      wrap-http-response))
\end{clojure}

Избегайте исключений для прыжков по коду. Убедитесь, что это крайняя мера. Вы
должны что-то выиграть: сократить код или оперативно решить проблему. Если
пришлось идти на этот шаг, возьмите библиотеку, чтобы сослаться на примеры и
документацию.

\index{finally}
\index{контекстный менеджер}

\section{Finally и контекстный менеджер}

Иногда код выполняют в рамках ресурса. Это может быть файл, сокет или транзакция
базы данных. В начале работы ресурс <<открывают>>, а в конце
<<закрывают>>. Открытый ресурс считается занятым. Когда ресурс занят, другие
клиенты не могут пользоваться им в полной мере. Например, открытый кем-то файл
можно читать, но не менять.

Закрывайте ресурс сразу же, как только в нём отпала нужда. Этому может
помешать ошибка. Если код, который работает с ресурсом, не поймал исключение,
файл или порт останутся открытыми до конца работы. Чтобы закрыть ресурс даже в
случае ошибки, прибегают к~форме \code{finally}.

Форму ставят последней в \code{try}. Если ошибки не было, \code{finally}
выполняется после основного кода из \code{try}. Когда возникло исключение,
\code{finally} сработает в промежутке между его появлением и выбросом.

Рассмотрим ручной доступ к файлу: запишем в него несколько
байт. \code{Finally} гарантирует, что файл закроется, даже если в процессе
возникло исключение.

\ifnarrow

\begin{clojure}
(import '[java.io File FileWriter])

(let [out (new FileWriter
            (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
\end{clojure}

\else

\begin{clojure}
(import '[java.io File FileWriter])

(let [out (new FileWriter (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
\end{clojure}

\fi

Чтобы вы не забыли закрыть файл, современные языки предлагают контекстные
менеджеры. Это может быть класс, оператор или макрос. Менеджер исполняет код с
дополнительными эффектами. Перед основным кодом сработает логика входа, а за
ним~--- логика выхода. Выход получит управление, даже если код бросил
исключение. В этом случае платформа удержит его, обработает выход и снова
бросит.

\index{языки!Python}

Особо изящно менеджер устроен в Python. Это оператор \code{with}, который
ожидает объект. У объекта должны быть методы \code{\_\_enter\_\_} и~\code{\_\_exit\_\_},
которые сработают на входе и выходе конструкции \code{with}. Её применяют для
файлов, транзакций базы данных, фикстур в тестах. Пример с~файлом:

\index{файлы}

\begin{python}
with open("/path/to/file.txt", "w") as f:
    f.write("test")
\end{python}

Напишем похожий менеджер для Clojure. Это макрос, который принимает символ и
путь к файлу. Внутри макроса файл связан с~символом. \code{Finally}
гарантирует, что файл закроется при выходе из блока.

\index{классы!FileWriter}

\ifnarrow

\begin{clojure}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter
                 (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
\end{clojure}

\else

\begin{clojure}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
\end{clojure}

\fi

Выполните код и исследуйте файл \code{test.txt}. Он должен быть с текстом внутри
и при этом не занят процессом Java. Чтобы проверить последнее, удалите его с
помощью терминала или менеджера файлов.

\begin{clojure}
(with-file-writer [out "test.txt"]
  (.write out "Hello macro!")
  (/ 0 0))
\end{clojure}

Контекстные менеджеры именуют с префиксом \code{with-}. Так делают акцент на
том, что код работает в рамках ресурса.

\index{clojure.core!with-open}

В Clojure предусмотрен макрос \code{with-open}. Это улучшенная версия кода, что
мы написали. В отличие от нашего примера, \code{with-open} работает с более
абстрактным источником, который в том числе может быть и файлом. Выход из
макроса, даже с ошибкой, закрывает источник.

Важно помнить, что код из \code{finally} не попадёт в результат. Форма
\code{try} устроена так, что при ошибке результат приходит из одной из веток
\code{catch}, а в \code{finally} находятся побочные эффекты. Лучше всего это
видно на примере с печатью:

\begin{clojure}
(try (/ 0 0)
     (catch Exception e
       (println "catch")
       :result-catch)
     (finally
       (println "finally")
       :result-finally))
\end{clojure}

\noindentnarrow
Если выполнить форму в REPL, увидим вывод:

\begin{clojure}
catch
finally
:result-catch
\end{clojure}

Такой порядок говорит о том, что сначала Clojure выполнит код из \code{catch}
(печать <<catch>>) и запомнит результат (кейворд \code{:result-catch}). Потом выполнит
\code{finally} (печать <<finally>>) и отбросит результат
(\code{:result-finally}). Кейворд \code{:result-catch} станет итогом \code{try}.

Для сравнения приведём неудачный пример из практики. Нужно было выполнить некое
действие и независимо от исхода вернуть положительный результат. Программист
обернул код в \code{try/catch} и записал ошибку в лог. Однако результат он
поместил в \code{finally}, что вызвало странное поведение: вместо словаря
возвращался \code{nil}.

\begin{clojure}
(try
  (do-something)
  (catch Exception e
    (log/error e "some error"))
  (finally
    {:status 200}))
\end{clojure}

Видимо, программист решил, что \code{finally}~--- в буквальном смысле финальный
результат \code{try}. Это не совсем так: \code{finally} и правда сработает
последним, но \code{try} вернёт либо результат основного кода, либо одной из
веток catch.

В \code{finally} нет смысла при работе с коллекциями или чистыми
функциями. Пользуйтесь им только если ресурс занят и должен быть освобожден.

\section{Исключения на предикатах}

\index{исключения!на предикатах}
\index{предикаты!в исключениях}

Система \code{try/catch} работает на классах и наследовании. Если нужно поймать
особый случай, для него пишут класс и бросают его экземпляр. Почти каждый проект
на Java или Python содержит модуль с исключениями, которые описывают нештатные
ситуации. Как правило, это условный класс \code{BaseException} и унаследованные
от него \code{UserNotFound}, \code{AccessDenied} и другие.

\index{библиотеки!Slingshot}

В главе про Spec мы говорили, что предикаты мощнее типов
\page{type-and-pred}. Это верно и для исключений: если можно поймать их
функцией, не понадобится класс. Подход с предикатами предлагает библиотека
\footurl{Slingshot}{https://github.com/scgilardi/slingshot}[Slingshot] (англ.~<<рогатка>>).
В ней находятся улучшенные версии \code{try}, \code{catch} и~\code{throw}.

\index{фундаментальность}

Это удивит тех, кто не знаком с Clojure: с помощью макросов в~ней меняют даже
такие фундаментальные вещи, как перехват исключений. В других языках подобных
изменений ждут годами, а в Clojure подключают библиотеку.

\index{макросы!try\Plus}
\index{макросы!throw\Plus}

Slingshot содержит макросы \code{throw+} и \code{try+}. Они совместимы
с~обычными \code{throw} и \code{try}: если заменить старые формы на версии с
плюсом, ничего не изменится. Однако новые формы способны на большее.

Макрос \code{throw+} принимает не только исключение, но и любой объект. Лучше
всего на эту роль подходит словарь: он объединяет несколько значений в
ключах. Пример ниже бросит \code{ex-info} с заданным словарём:

\ifnarrow

\begin{clojure}
(require
  '[slingshot.slingshot
    :refer [try+ throw+]])

(throw+ {:user-id 5 :action :create})
\end{clojure}

\else

\begin{clojure}
(require '[slingshot.slingshot :refer [try+ throw+]])

(throw+ {:user-id 5 :action :create})
\end{clojure}

\fi

Кроме объекта, \code{throw+} принимает исклю\-че\-ние-при\-чи\-ну, шаблон
сообщения и параметры подстановки. Ниже~--- пример со всеми возможными
аргументами:

\pagebreakafive[3]

\ifnarrow

\begin{clojure}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e
      "File error: %s" path))))
\end{clojure}

\else

\begin{clojure}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e "File error: %s" path))))
\end{clojure}

\fi

Обратите внимание, что порядок аргументов отличается от
\code{ex-info}. Slingshot делает ставку на данные и ожидает сперва объект, а
сообщение~--- в последнюю очередь. Стандартный \code{ex-info}, наоборот,
принимает сначала текст, а затем данные.

\index{предикаты!в исключениях}

Форма \code{catch} внутри \code{try+} ловит исключения не только
классами. Slingshot предлагает для этого селекторы и предикаты. Под селектором
понимают вектор, где нечётный элемент~--- это ключ словаря, а чётный~---
значение. Селектор проверяет, что ключи и значения входят в контекст. Если да,
управление переходит в ветку с этим селектором.

\begin{clojure/lines}
(try+
 (throw+ {:type ::user-error
          :user 5
          :action :update
          :data {:name "Ivan"}})
 (catch [:type ::user-error] e
   (clojure.pprint/pprint e)))
\end{clojure/lines}

Подумаем, каким полем лучше перехватывать исключения. Официальных требований на
этот счёт нет. Самым простым и популярным считается поле \code{:type}. Когда
бросают словарь, в него добавляют ключ с текущим пространством, в нашем случае
\code{::user-error} \coderef{2}. При отлове исключений в другом модуле селектор
примет вид \code{[:type :book.exceptions/user-error]}. Пространство обещает,
что мы не перехватим \texttt{:user\-/error} из чужой библиотеки.

Пример выше напечатает брошенный словарь. Внутри \code{catch} переменная
\code{e} ссылается не на исключение, а на данные, которые передали
в~\code{throw+}.

Вместо селектора может быть предикат, функция одного аргумента. Если класс
ошибки \texttt{Excep\-tion\-Info}, предикат получит словарь данных, а иначе~--- объект
исключения. Функция должна учесть, что тип аргумента может быть разным. Когда
предикат вернул истину, управление переходит в его ветку \code{catch}.

\index{сервисы!Amazon S3}

Предикатами пользуются, когда нужно тонкое условие перехвата. Рассмотрим
загрузку файла в Amazon S3. В особых случаях Java SDK бросает исключение уже
после того, как файл загружен. В основном это случается из-за разницы в
контрольных суммах. Загрузка считается неудачной, и мы должны удалить файл,
чтобы он не занимал место.

К сожалению, в SDK нет класса \texttt{Check\-sum\-Er\-ror} или аналога. Вместо него
приходит обычный \texttt{Ama\-zon\-S3\-Excep\-tion} с длинным текстом. Чтобы выделить
наш случай, сравним сообщение с шаблоном. Вынесем проверку в функцию:

\ifnarrow

\begin{clojure}
(defn aws-checksum-error? [e]
  (and
    (instance? AmazonS3Exception e)
    (some?
      (re-find
        #"(?i)The Content-Md5
            you specified did not match"
        (ex-message e)))))
\end{clojure}

\else

\begin{clojure}
(defn aws-checksum-error? [e]
  (and (instance? AmazonS3Exception e)
       (some?
        (re-find
         #"(?i)The Content-Md5 ... did not match"
         (ex-message e)))))
\end{clojure}

\fi

\noindent
Поместим её в \code{catch}, чтобы поймать случай с контрольной суммой и удалить
файл:

\begin{clojure}
(try+
  (s3/put-object ...)
  (catch aws-checksum-error? e
    (s3/delete-object ...)))
\end{clojure}

Slingshot используется в \footurl{Clj-http}{https://github.com/dakrone/clj-http}[Clj-http]~---
популярном HTTP-кли\-ен\-те для Clojure. В случае ошибки он бросает ответ через
\code{throw+}. Если обернуть запрос в \code{try+}, получим более тонкий
разбор ошибок. Например, отдельные ветки для статусов 403, 500 и негативного
ответа в целом.

\pagebreakafive

\ifnarrow

\begin{clojure}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 403] e
  (println "Access denied"))
 (catch [:status 500] e
  (println "The service is unavailable"))
 (catch
  [:type :client/unexceptional-status] e
  (println "Negative response")))
\end{clojure}

\else

\begin{clojure}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 403] e
  (println "Access denied"))
 (catch [:status 500] e
   (println "The service is unavailable"))
 (catch [:type :client/unexceptional-status] e
   (println "Negative response")))
\end{clojure}

\fi

Slingshot делает ставку на данные, а не классы, что поощряется
в~Clojure. Начинающим не всегда очевидны плюсы этого подхода. Советуем читателю
сперва разобраться с обычными \code{try/catch}. Подключайте Slingshot только
если чувствуете в нём потребность.

\index{библиотеки!Ex}
\index{организации!Exoscale}

Slingshot не единственный пример <<кложурных>> исключений. Обратите внимание на
\footurl{Ex}{https://github.com/exoscale/ex}[Ex]~--- аналог, которым пользуются
в Exoscale. Библиотека учитывает семантику ключей (\code{:fault},
\code{:con\-flict}), их наследование, поддерживает Manifold и многое другое.

\section{Приёмы и функции}

Напоследок рассмотрим несколько техник для исключений. Они просты и поэтому не
стоят того, чтобы вынести их в отдельную библиотеку. Чаще всего их копируют из
проекта в проект с небольшими изменениями.

\index{языки!Lua}

\label{pcall}

\textbf{Безопасный вызов функции.} В языке Lua нет операторов \code{try} и
\code{catch}. Чтобы обезопасить вызов от ошибки, используют
\footurl{\texttt{pcall}}{https://www.lua.org/pil/8.4.html}[Lua pcall]. Это сокращение от
protected call, <<защищённый вызов>>. Иногда приём полезен и в Clojure.

\code{Pcall} принимает функцию, её аргументы и возвращает пару значений. Первое
означает успех выполнения. Если это истина, на втором месте результат
вычислений, а иначе~--- экземпляр ошибки. Версия на Clojure:

\index{функции!pcall}

\begin{clojure}
(defn pcall [f & args]
  (try
    [true (apply f args)]
    (catch Exception e [false e])))
\end{clojure}

Для краткости разбейте результат в \code{let}:

\ifnarrow

\begin{clojure}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println
      (str "The result is "
        result-error))
    (println "Failure")))
\end{clojure}

\else

\begin{clojure}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println (str "The result is " result-error))
    (println "Failure")))
\end{clojure}

\fi

\index{языки!JavaScript}

В JavaScript популярна другая семантика: функции-колбэки принимают аргументы
\code{error} и \code{result}. Функция \code{pcall-js}~--- это изменённый вариант
\code{pcall}, который вернёт пару \tuple{ошибка, результат}. Если первый элемент
пары~--- не \code{nil}, это значит, что вызов функции не удался.

\begin{clojure}
(defn pcall-js [f & args]
  (try
    [nil (apply f args)]
    (catch Exception e [e nil])))
\end{clojure}

\noindent
Разбиение выглядит по-другому:

\ifnarrow

\begin{clojure}
(let [[e user]
      (pcall-js get-user-by-id 5)]
  (if e
    (println (ex-message e))
    (println user)))
\end{clojure}

\else

\begin{clojure}
(let [[e user] (pcall-js get-user-by-id 5)]
  (if e
    (println (ex-message e))
    (println user)))
\end{clojure}

\fi

\index{функции!с повтором}

\textbf{Попытки с задержкой.} Иногда сторонний сервис нестабилен, и~к~нему
обращаются несколько раз. Чтобы не копировать код, выразим повтор с помощью
функции. \code{Call-retry} пытается выполнить целевую функцию за несколько
подходов. Первый удачный вызов станет результатом. Если была ошибка, но попытки
ещё не кончились, функция ждёт и повторяет вызов. Когда попытки исчерпаны,
функция бросит исключение. Внутри используется \code{pcall}, который мы задали
выше.

\index{функции!call-retry}
\index{итерация!loop}

\ifnarrow

\begin{clojure}
(defn call-retry [n f & args]
  (loop [attempt 0]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do (Thread/sleep
             (* (inc attempt) 1000))
            (recur (inc attempt)))

        :else (throw res)))))
\end{clojure}

\else

\begin{clojure}
(defn call-retry [n f & args]
  (loop [attempt 0]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do (Thread/sleep (* (inc attempt) 1000))
            (recur (inc attempt)))

        :else (throw res)))))
\end{clojure}

\fi

\pagebreaklarge[3]

Вот как получить пользователя по номеру за три попытки:

\begin{clojure}
(call-retry 3 get-user-by-id user-id)
\end{clojure}

Это наивная версия, и в реальности её улучшают: меняют стратегию ожидания,
добавляют логи. Однако принцип остаётся прежним.

Любопытно, что функции стыкуются между собой. Построим комбинацию из
\code{pcall} и \code{call-retry}. Даже если сервис недоступен и мы обращались к
нему много раз, получим пару \code{[ok? result]}.

\begin{clojure}
(pcall call-retry get-user-by-id 5)
\end{clojure}

\textbf{Исключения в Loop.} Форма \code{loop} устроена особо: её часть
\code{recur} не может быть внутри \code{try}. Предположим, мы хотим написать
функцию повтора без \code{pcall}. Фрагмент кода:

\index{итерация}
\index{clojure.core!loop}

\begin{clojure}
(defn call-retry [n f & args]
  (loop [attempt 0]
    ...
    (try
      (apply f args)
      (catch Exception e
        (recur (inc n))))))
\end{clojure}

Из-за последней строки компилятор не примет код с сообщением <<Can only recur
from tail position>>. Чтобы исправить ошибку, нужно вынести \code{recur} из
\code{try}. Проще всего это сделать с помощью \code{pcall}, как в примере с
\code{call-retry}.

\textbf{Throw in place.} До сих пор мы кидали исключения с помощью
\code{ex-info} и \code{throw}. Первая строит исключение, а вторая
бросает. Совместим их в функцию \code{error!} и упростим аргументы:

\index{функции!error"!}

\ifnarrow

\begin{clojure}
(defn error! [message & [data e]]
  (throw (ex-info message
           (or data {}) e)))
\end{clojure}

\else

\begin{clojure}
(defn error! [message & [data e]]
  (throw (ex-info message (or data {}) e)))
\end{clojure}

\fi

\noindent
Чтобы вызвать исключение, нужна только строка, а остальное по желанию:

\begin{clojure}
(error! "Error")
(error! "Error" {:type ::error})
(error! "Error" {:type ::error} e)
\end{clojure}

\textbf{Сообщение с параметрами.} Иногда ошибке достаточно подробной строки без
контекста. В этом случае \code{ex-info} избыточен, потому что требует
словаря. Напишем функцию, которая бросает \code{Exception} с форматированным
сообщением. В неё передают шаблон и значения подстановки. Частичка \code{f} на
конце имени означает форматирование.

\index{функции!errorf"!}

\ifnarrow

\begin{clojure}
(defn errorf! [template & args]
  (let [message (apply format
                  template args)]
    (throw (new Exception
             ^String message))))

(errorf! "Error, user: %s, action: %s"
  5 :delete)
\end{clojure}

\else

\begin{clojure}
(defn errorf! [template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(errorf! "Error, user: %s, action: %s" 5 :delete)
\end{clojure}

\fi

\textbf{Безопасный макрос.} Перехват исключений работает и в макросах. Как
правило, макрос выглядит короче и выразительней обычной функции (но это не
значит, что макросами нужно злоупотреблять). Следующий пример показывает, как
выполнить код в безопасном режиме, игнорируя ошибку:

\index{макросы!with-safe}

\begin{clojure}
(defmacro with-safe [& body]
  `(try
     ~@body
     (catch Exception e#)))
\end{clojure}

\noindent
Пустая форма \code{catch} вернёт \code{nil}. Мы получим его, если случится
исключение:

\begin{clojure}
(with-safe (/ 0 0))
nil
\end{clojure}

На практике \code{nil} не всегда означает ошибку, поэтому возвращают ключи
\code{:error} или \code{:invalid}. Так работает Spec, которую мы разобрали в
прошлой главе \page{spec-invalid}. Иногда в \code{catch} добавляют запись в лог
или обращение к Sentry. Подавляйте ошибку только если она действительно неважна.

\section{Заключение}

Исключения в Clojure устроены как в Java. Формы \code{try} и \code{catch} похожи
на одноимённые операторы. Перехват работает на классах и~наследовании. Чем выше
класс в иерархии, тем больше ошибок он охватывает.

Класс \code{ExceptionInfo} создан специально для Clojure. Функция \code{ex-info}
работает конструктором этого класса. Параметр \code{data} принимает словарь,
который называют контекстом. Семантику исключения определяет поле \code{:type},
в котором полный кейворд с пространством.

У ошибки может быть причина, \code{cause}. Если вы поймали исключение, но не
знаете, что с ним делать, бросьте новое с контекстом и~ссылкой на исходное. Так
собираются цепочки исключений. Чтобы выяснить причину, пригодятся данные со всей
цепочки, а не только с верхнего звена.

Код на вершине приложения определяет, что делать с исключением. Лучше всего
отправить его в систему сбора ошибок, чтобы разобрать позже. На роль сборщика
подходят Sentry и аналоги. Убедитесь, что клиент для Sentry передаёт всю
информацию об ошибке, а не только стек-трейс.

В ветке \code{finally} обычно закрывают ресурс, чтобы он не остался
занятым при ошибке. Доступ к ресурсу упрощает контекстный менеджер. Это макрос
вида \code{with-<something>}, который оборачивает блок кода
в~\code{try/finally}. Для работы с файлами Clojure предлагает макрос
\code{with-open}.

Иногда исключением пользуются, чтобы перейти в другое место в~коде. Это
противоречивый подход, и на него должны быть причины. Если переходов не
избежать, подключите специальную библиотеку, чтобы коллеги прочли документацию.

Slingshot предлагает улучшенные макросы \code{try+} и \code{throw+}. С ними
ошибки ловят не классами, а селекторами и предикатами. Вместо исключений
используют словари.

Ряд мелких функций упрощает контроль за исключениями. Возьмите их на заметку,
чтобы сократить код.
