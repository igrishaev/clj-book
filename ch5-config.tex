\chapter{Конфигурация}

\index{конфигурация}

\label{chapter-config}

\begin{teaser}
В этой главе мы рассмотрим, как сделать проект на Clojure удобным в
настройке. Разберём основы конфигурации: форматы файлов, переменные среды,
библиотеки, их достоинства и недостатки.
\end{teaser}

\section{Постановка проблемы}

В материалах по Clojure встречаются примеры:

\begin{english}
  \begin{clojure}
(def server
  (jetty/run-jetty app {:port 8080}))

(def db {:dbtype   "postgres"
         :dbname   "test"
         :user     "ivan"
         :password "test"})
  \end{clojure}
\end{english}

Это сервер на порту 8080 и параметры подключения к базе. Польза примеров в том,
что их можно скопировать в REPL и оценить результат: открыть страницу в браузере
или прочитать таблицу.

На практике код пишут так, чтобы в нём не было конкретных чисел и строк. С точки
зрения проекта плохо, что серверу явно задали порт. Это подойдёт для
документации и примеров, но не для боевого запуска.

Порт 8080 и другие комбинации нулей и восьмёрок популярны
у~программистов. Велики шансы, что порт занят другим сервером. Это случается,
когда запускают не отдельный сервис, а их связку на время разработки или тестов.

Код, написанный программистом, проходит несколько стадий. В~разных фирмах набор
отличается, но в целом это разработка, тестирование, предварительный и боевой
запуск.

\label{hardcode}

На каждой стадии приложение запускают бок о бок с другими
проектами. Предположение, что порт 8080 свободен в любой момент,~--- это утопия. На
жаргоне разработчиков ситуацию называют <<хардкод>> \eng{hardcode} или <<прибито
гвоздями>>. Когда в коде <<прибитые>> значения, это вносит проблемы в его
цикл. Вы не сможете одновременно работать над проектом и тестировать его.

Приложение не должно знать порт сервера~--- информация об этом приходит извне. В
простом случае это файл настроек. Программа читает из него порт и запускает
сервер именно так, как это нужно на~конкретной машине.

\index{менеджер конфигураций}

В более сложных сценариях файл составляет не человек, а специальная
программа~--- менеджер конфигураций. Менеджер хранит информацию о топологии
сети, адреса машин, параметры доступа к~базам. По запросу он выдаёт файл для
определённой машины или сегмента сети.

Процесс, когда приложению сообщают параметры, а оно принимает их, называется
конфигурацией. Это интересный и важный этап в~разработке программ. Когда он
устроен удачно, проект легко проходит по всем стадиям производства.

\section{Семантика}

Цель конфигурации в том, чтобы управлять программой без изменений в коде. К ней
приходят с ростом кодовой базы и инфраструктуры. Если у вас мелкий скрипт на
Python, нет ничего зазорного в том, чтобы открыть его в блокноте и поменять
константу. На предприятиях такие скрипты работают годами.

Чем сложнее инфраструктура фирмы, тем больше в ней ограничений. Современный
подход сводит на нет спонтанные изменения в~проекте. Нельзя сделать \verb|git push|
напрямую в мастер; запрещён \verb|merge|, пока вашу работу не одобрят
двое коллег; приложение не попадёт на~сервер, пока не пройдут тесты.

Это приводит к тому, что малейшее изменение в коде займёт час, чтобы попасть в
бой. Правка в конфигурации дешевле, чем выпуск новой версии продукта. Из этого
следует правило: если можно вынести что-то в конфигурацию, сделайте это сейчас.

\index{фичи}
\index{feature flags}

В крупных фирмах практикуют то, что называют feature flag. Это логическое
поле, которое включает целый пласт логики в приложении. Например, новый
интерфейс, систему обработки заявок, улучшенный чат. Обновления тестируют внутри
фирмы, но всегда остаётся риск, что в бою \emph{что-то пойдёт не так}. В этом случае
флаг меняют на ложь и~перезапускают сервер. Это не только сэкономит время, но и
сохранит репутацию фирмы.

\label{feature-flags}

\section{Цикл конфигурации}

При запуске приложение ищет конфигурацию. Чем лучше устроено приложение, тем
больше его частей опирается на параметры. Обработка конфигурации~--- это не
монолитная задача, а набор шагов. Перечислим наиболее важные из них.

На первом этапе программа \textbf{читает конфигурацию}. Чаще всего это файл или
переменные среды. Данные в файлах хранят в форматах JSON, YAML и
других. Приложение содержит код, чтобы разобрать формат и получить данные. Мы
рассмотрим плюсы и минусы известных форматов ниже.

Переменные среды~--- это часть операционной системы. Представьте~их как глобальный
словарь в памяти. Каждое приложение наследует его при запуске. Языки и
фреймворки предлагают функции, чтобы считать переменные в строки и словари.

Файлы и переменные среды дополняют друг друга. Например, приложение читает
данные из файла, но путь к нему ищет в переменных среды. Иногда в файле опускают
критические данные: пароли, API-ключи. Так поступают, чтобы их не увидели другие
программы, в~том числе шпионские. Приложение читает параметры из файла,
а~секретные данные~--- из переменных.

\index{теги}

Продвинутые конфигурации используют теги. В файле перед значением
ставят тег: \verb|:password #env DB_PASSWORD|. Это значит, что в~поле
\verb|password| не строка \verb|DB_PASSWORD|, а значение одноимённой
переменной.

Первый этап завершается тем, что мы получили данные. Неважно, был ли это файл,
переменные среды или что-то другое. Приложение переходит ко второму этапу~---
\textbf{выводу типов}.

\index{вывод!типов}

JSON или YAML выделяют базовые типы: строки, числа, булево и~\verb|null|. Легко
заметить, что среди них нет даты. С помощью дат задают промоакции или события,
связанные с календарём. В файлах даты указывают либо строкой в формате ISO, либо
числом секунд c~1~января~1970 года (\footurl{эпоха UNIX}{https://en.wikipedia.org/wiki/Unix\_time}[Unix time][1mm]).
Специальный код пробегает про данным и~приводит даты к типу, принятому в языке.

Вывод типов применяют и для коллекций. Иногда словарей и~массивов не хватает для
комфортной работы. Типы события хранят в виде множества, потому что оно отсекает
дубли и предлагает быструю проверку на вхождение. Скаляры тоже оборачивают в
классы, например \verb|UUID| для идентификаторов.

Переменные среды не настолько гибки, как современные форматы. Если JSON выделяет
скаляры и коллекции, то переменные несут только текст. Вывод типов для них не
просто желателен, а необходим. Нельзя передать порт в виде строки туда, где
ожидают число.

\index{валидация}

После вывода типов приступают к \textbf{валидации данных}. В главе про Spec мы
выяснили, что тип не обещает верное значение \page{type-and-pred}.
Проверка нужна, чтобы в конфигурации нельзя было указать порт 0, -1 или 80.

Из той же главы мы помним, что иногда значения верны по отдельности, но не могут
быть в паре. Пусть в конфигурации задан период акции. Это массив из двух дат,
начало и завершение. Легко перепутать даты местами, и проверка любой даты
на интервал вернёт ложь.

После валидации переходят к последней стадии. Приложение решает, где
\textbf{хранить конфигурацию}. Это может быть глобальная переменная или
компонент системы. Другие части программы читают параметры уже оттуда, а не из
файла.

\section{Ошибки конфигурации}

\index{ошибки!конфигурации}

На каждом этапе может возникнуть ошибка: не найден файл, нарушения в синтаксисе,
неверное поле. В этом случае программа выводит сообщение и завершается.
Текст должен чётко ответить на вопрос, что случилось. Часто программисты
держат в голове только положительный путь и забывают об ошибках. При запуске
их программ виден стек-трейс, который трудно понять.

Если ошибка случилась на этапе проверки, объясните, какое поле тому виной. В
главе про Spec мы рассмотрели, как улучшить отчёт спеки \page{spec-messages}.
Это требует усилий, но окупается со временем.

\index{DevOps}
\index{отчёт!explain}

В IT-индустрии одни сотрудники пишут код, а другие управляют им. Ваш
коллега-DevOps не знает Clojure и не поймёт сырой \verb|explain|. Рано или
поздно он попросит доработать сообщения конфигурации. Сделайте это заранее из
уважения к коллегам.

Если с конфигурацией что-то не так, программа не должна работать в надежде, что
всё обойдется. Бывает, один из параметров задан неверно, но программа к нему не
обращается. Избегайте этого: ошибка появится в неподходящий момент.

\index{каналы!stderr}

Когда один из шагов конфигурации не сработал, программа завершается с кодом,
отличным от нуля. Сообщение пишут в канал \verb|stderr|, чтобы подчеркнуть
внештатную ситуацию. Продвинутые терминалы печатают текст из \verb|stderr|
красным цветом.

\section{Загрузчик конфигурации}

\index{конфигурация!загрузка}

Чтобы закрепить теорию, напишем систему конфигурации. Это отдельный модуль
примерно на сто строк. Прежде чем садиться за редактор, обдумаем основные
положения.

Будем хранить конфигурацию в JSON-файле. Считаем, что фирма недавно перешла на
Clojure и у DevOps уже написаны скрипты на Python для управления
настройками. Формат EDN усложнит работу коллегам.

\index{даты}

Путь к файлу задают в переменной среды \verb|CONFIG_PATH|. От файла мы ожидаем
порт сервера, параметры базы данных и диапазон дат для промоакции. Даты должны
стать объектами \verb|java.util.Date|. Дата начала строго меньше конца.

Готовый словарь запишем в глобальную переменную \verb|CONFIG|. Если на одном
из шагов случилась ошибка, покажем сообщение и завершим программу.

Начнём со вспомогательной функции \verb|exit|. Она принимает код завершения,
текст и параметры форматирования. Если код равен нулю, пишем сообщение в
\verb|stdout|, иначе~--- в \verb|stderr|.

\index{функции!exit}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn exit
  [code template & args]
  (let [out (if (zero? code)
              *out*
              *err*)]
    (binding [*out* out]
      (println (apply format
        template args))))
  (System/exit code))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn exit
  [code template & args]
  (let [out (if (zero? code) *out* *err*)]
    (binding [*out* out]
      (println (apply format template args))))
  (System/exit code))
  \end{clojure}
\end{english}

\fi

Переходим к загрузчику. Это набор шагов, каждый из которых принимает результат
предыдущего. Логику каждого легко понять по имени. Вывод типов и валидацию
совместили в \verb|coerce-config|, поскольку технически это вызов
\verb|s/conform|.

\index{функции!load-config"!}

\begin{english}
  \begin{clojure}
(defn load-config! []
  (-> (get-config-path)
      (read-config-file)
      (coerce-config)
      (set-config!)))
  \end{clojure}
\end{english}

Теперь опишем каждый шаг. Функция \verb|get-config-path| читает переменную
среды и проверяет, есть ли такой файл на диске. Если всё в~порядке, функция
вернёт путь к файлу, а иначе вызовет \verb|exit|:

\index{файлы}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(import 'java.io.File)

(defn get-config-path []
  (if-let [filepath (System/getenv
                      "CONFIG_PATH")]
    (if (-> filepath (new File) .exists)
      filepath
      (exit 1 "File %s does not exist"
        filepath))
    (exit 1 "File path is not set")))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(import 'java.io.File)

(defn get-config-path []
  (if-let [filepath (System/getenv "CONFIG_PATH")]
    (if (-> filepath (new File) .exists)
      filepath
      (exit 1 "File %s does not exist" filepath))
    (exit 1 "File path is not set")))
  \end{clojure}
\end{english}

\fi

Шаг \verb|read-config-file| читает файл по его пути. Для разбора JSON служит
библиотека Cheshire. Функция \verb|parse-string| вернёт данные из
строки документа.

\index{библиотеки!Cheshire}
\index{модули!cheshire.core}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[cheshire.core :as json])

(defn read-config-file
  [filepath]
  (try
    (-> filepath
        slurp
        (json/parse-string true))
    (catch Exception e
      (exit 1
        "Malformed config,
                   file: %s, error: %s"
            filepath (ex-message e)))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[cheshire.core :as json])

(defn read-config-file
  [filepath]
  (try
    (-> filepath slurp (json/parse-string true))
    (catch Exception e
      (exit 1 "Malformed config, file: %s, error: %s"
            filepath (ex-message e)))))
  \end{clojure}
\end{english}

\fi

\index{валидация}
\index{вывод!типов}
\index{идентичность}
\index{библиотеки!Expound}

Вывод типов и проверка~--- это самые важные этапы. Нельзя допустить, чтобы приложение
получило неверные параметры. Шаг \verb|coerce-config| пропускает данные из файла
через \verb|s/conform|. Вызов опасен исключением, поэтому обернём его в
\verb|pcall|~--- безопасный вызов, который вернёт ошибку и
результат \page{pcall}.

Если результат \verb|::s/invalid|, формируем отчёт об ошибке и завершаем
программу. Для отчёта возьмём библиотеку Expound. Функция \verb|s/invalid?|~--- это
быстрая проверка на \emph{идентичность} кейворду \verb|::s/invalid|. В отличие
от равенства, идентичность работает быстрее.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
(require '[expound.alpha :as expound])

(defn coerce-config [config]
  (let [[e result] (pcall s/conform
                     ::config config)]
    (cond
      (some? e)
      (exit 1 "Wrong config values: %s"
        (ex-message e))

      (s/invalid? result)
      (let [report (expound/expound-str
                     ::config config)]
        (exit 1
          "Invalid config values: %s %s"
          \newline report))

      :else result)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
(require '[expound.alpha :as expound])

(defn coerce-config [config]
  (let [[e result] (pcall s/conform ::config config)]
    (cond
      (some? e)
      (exit 1 "Wrong config values: %s" (ex-message e))

      (s/invalid? result)
      (let [report (expound/expound-str ::config config)]
        (exit 1 "Invalid config values: %s %s" \newline report))

      :else result)))
  \end{clojure}
\end{english}

\fi

Не хватает спеки. Откроем конфигурацию и изучим её структуру:

\index{форматы!JSON}

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}
\end{english}

\noindent
Опишем спеку сверху вниз. Это словарь с ключами:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::config
  (s/keys :req-un [::server_port
                   ::db ::event]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::config
  (s/keys :req-un [::server_port ::db ::event]))
  \end{clojure}
\end{english}

\fi

\index{даты!диапазон}

Порт сервера~--- это комбинация двух предикатов: число и вхождение в диапазон.
Проверка на число нужна, чтобы во второй предикат не попали \verb|nil| и
строка. Это вызовет исключение там, где его не ждали.

\begin{english}
  \begin{clojure}
(s/def ::server_port
  (s/and int? #(<= 1024 % 65535)))
  \end{clojure}
\end{english}

\index{spec!int-in}

Проверка на число и диапазон встречается часто, и Spec предлагает макрос
\verb|s/int-in| на этот случай. Только учтите, что правая граница
исключительного типа, то есть не входит в интервал. На языке математики мы бы
написали \verb|[1024, 65535)|.

\begin{english}
  \begin{clojure}
(s/def ::server_port
  (s/int-in 1024 (inc 65535)))
  \end{clojure}
\end{english}

\index{spec!::ne-string}

\noindent
Подключение к базе данных. Напомним, что \verb|::ne-string| означает
непустую строку.

\begin{english}
  \begin{clojure}
(s/def :db/dbtype   #{"mysql"})
(s/def :db/dbname   ::ne-string)
(s/def :db/user     ::ne-string)
(s/def :db/password ::ne-string)

(s/def ::db
  (s/keys :req-un [:db/dbtype
                   :db/dbname
                   :db/user
                   :db/password]))
  \end{clojure}
\end{english}

Поле \verb|event| сложное. Оно состоит из кортежа дат и проверки на интервал:

\begin{english}
  \begin{clojure}
(s/def ::event
  (s/and (s/tuple ::->date ::->date)
         ::date-range))
  \end{clojure}
\end{english}

\index{даты!разбор}
\index{модули!clojure.instant}
\index{функции!read-instant-date}
\index{spec!::ne-string}
\index{spec!::\arr{}date}

Спека \verb|::->date| выводит дату из строки. Чтобы не парсить её вручную,
возьмём функцию \verb|read-instant-date| из пакета \verb|clojure.instant|.
Функция лояльна к формату и~читает неполные даты, например только год.
Обернём её в \verb|s/conformer|. Впереди ставим \verb|::ne-string|,
чтобы отсечь мусор.

\index{функции!read-instant-date}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[clojure.instant :as inst])

(s/def ::->date
  (s/and ::ne-string
    (s/conformer read-instant-date)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.instant :as inst])

(s/def ::->date
  (s/and ::ne-string (s/conformer read-instant-date)))
  \end{clojure}
\end{english}

\fi

\index{классы!Date}
\index{clojure.core!compare}

Опишем проверку диапазона. Она принимает пару объектов \verb|Date| и~сравнивает
их. Даты нельзя сравнить знаками <<больше>> или <<меньше>>. Для этого служит
функция \verb|compare|, которая вернёт -1, 0 и 1 для случаев <<меньше>>, <<равно>> и
<<больше>>.

\begin{english}
  \begin{clojure}
(s/def ::date-range
  (fn [[date1 date2]]
    (neg? (compare date1 date2))))
  \end{clojure}
\end{english}

На этом месте можно вызвать \verb|load-config!| и убедиться, что на выходе
словарь с правильными типами. Последний шаг \verb|set-config!| пишет словарь в
глобальную переменную \verb|CONFIG|. Мы выбрали имя в верхнем регистре, чтобы не
затенить его локальной \verb|config|. Для подмены переменной используем
\verb|alter-var-root|.

\index{clojure.core!alter-var-root}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def CONFIG nil)

(defn set-config!
  [config]
  (alter-var-root (var CONFIG)
    (constantly config)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def CONFIG nil)

(defn set-config!
  [config]
  (alter-var-root (var CONFIG) (constantly config)))
  \end{clojure}
\end{english}

\fi

На старте программы выполните \verb|(load-config!)|, чтобы в переменной
появилась конфигурация. Другие модули импортируют \verb|CONFIG| и читают
нужные им ключи. Вот как запустить сервер или выполнить запрос с учётом
конфигурации:

\index{JDBC!query}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[project.config :refer [CONFIG]])

(jetty/run-jetty app
  {:port (:server_port CONFIG)
   :join? false})

(jdbc/query (:db CONFIG)
  "select * from users")
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[project.config :refer [CONFIG]])

(jetty/run-jetty app {:port (:server_port CONFIG)
                      :join? false})

(jdbc/query (:db CONFIG) "select * from users")
  \end{clojure}
\end{english}

\fi

\subsection{Работа над ошибками}

Мы написали загрузчик конфигурации. Он удобен в поддержке: каждый шаг~--- это
функция, которую легко доработать. Код не претендует на промышленное решение, но
подойдёт для небольших проектов.

Преимущество в том, что конфигурацию можно считать заново в~любой момент. Это
удобно при разработке: измените файл и выполните \verb|load-config!| в
REPL. В~\verb|CONFIG| появится новая конфигурация.

\index{функции!exit}

Недостаток загрузчика в том, что код привязан к функции \verb|exit|, которая
завершает JVM. В боевом запуске это верный подход: нельзя продолжать, если в
параметрах ошибка. При разработке от завершения больше проблем: любая ошибка
убивает REPL, и нужно включать его заново.

Завершение JVM~--- это слишком радикальное действие. Ошибка и~реакция на неё
должны быть разделены. Наивный способ~--- вызвать \verb|load-config!| в рамках
подмены \verb|exit|. Функция ниже не завершит JVM, а только бросит исключение
с текстом, который передали в \verb|exit|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn load-config-repl! []
  (with-redefs
    [exit
     (fn [_ template & args]
       (let [^String message
             (apply format
               template args)]
         (throw
           (new Exception message))))]
    (load-config!)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn load-config-repl! []
  (with-redefs
    [exit (fn [_ template & args]
            (let [^String message
                  (apply format template args)]
              (throw (new Exception message))))]
    (load-config!)))
  \end{clojure}
\end{english}

\fi

\index{die-fn}
\index{функция смерти}
\index{REPL}

Более удачное решение~--- передать в \verb|load-config!| дополнительные
параметры. Назовём один из них \verb|:die-fn|, <<функция смерти>>, которая
принимает исключение. В боевом запуске она завершает JVM, а в~разработке пишет
сообщение в REPL. Доработайте загрузчик так, чтобы он поддерживал параметр
\verb|:die-fn|. Продумайте поведение по умолчанию, если он не задан.

Для вывода типов загрузчик опирается на \verb|s/conform|. В главе про Spec мы
рассмотрели случай, когда \verb|s/conform| добавляет логические теги и меняет
структуру данных \page{jdbc-conform-warning}. Если заменить спеку \verb|::db| на
\verb|::jdbc/db-spec|, получим тот самый случай. Чтобы не искажать данные, мы
задали свою версию \verb|::db| без макросов \verb|s/or|.

\index{теги}

По-другому типы выводят с помощью \emph{тегов}. Эту технику мы обсудим в
следующих разделах главы.

\section{Подробнее о переменных среды}

\index{environment}
\index{переменные!среды}

Загрузчик читает данные из файла. Из переменных среды он берёт лишь малую
часть~--- путь к файлу. Изменим загрузчик: пусть он читает данные из переменных
среды и не нуждается в файлах. Чтобы понять преимущества этого подхода,
поговорим о переменных в отрыве от языка.

Переменные среды называют ENV, <<энвы>> (англ.~environment~--- <<окружающая
среда>>). Это фундаментальное свойство операционной системы. Представьте
переменные как глобальный словарь, который наполняется во время запуска
компьютера. В словаре основные параметры системы: локаль, домашняя директория,
список путей, где система ищет программы, и многое другое.

\index{утилиты!printenv}

Чтобы увидеть текущие переменные, запустите в терминале \verb|env| или
\verb|printenv|. На экране появится пары \verb|ИМЯ=значение|. Имена переменных в
верхнем регистре, чтобы выделить их на общем фоне и подчеркнуть
приоритет. Большинство систем различают регистр, поэтому \verb|home|
и~\verb|HOME|~--- это разные переменные. Пробелы и дефисы недопустимы; лексемы
отделяют подчёркиванием. Фрагмент \verb|printenv|:

\begin{english}
  \begin{bash}
USER=ivan
PWD=/Users/ivan
SHELL=/bin/zsh
TERM_PROGRAM=iTerm.app
  \end{bash}
\end{english}

Каждый процесс получает копию этого словаря. Процесс может добавить или удалить
переменную, но изменения видны только ему и~потомкам. Потомок процесса наследует
переменные родителя.

\subsection{Локальные и глобальные переменные}

\index{шелл}
\index{переменные!среды}

Различают переменные \emph{среды} и \emph{шелла}, они же глобальные и локальные
переменные. Их часто путают новички. Выполните в терминале команду:

\begin{english}
  \begin{bash}
$ FOO=42
  \end{bash}
\end{english}

Вы задали переменную шелла (командной оболочки). Чтобы сослаться на значение по
имени (<<дерефнуть>>), поставьте перед ней доллар. Пример напечатает 42:

\begin{english}
  \begin{bash}
$ echo $FOO
42
  \end{bash}
\end{english}

\index{переменные!шелла}

Если выполнить \verb|printenv|, мы не увидим \verb|FOO| в выводе. Команда
\verb|FOO=42| задаёт переменную шелла, а не среды. Эти переменные видны только
ему и не наследуются потомками. Проверим это: из текущего шелла запустим новый и
повторим печать.

\begin{english}
  \begin{bash}
$ sh
$ echo $FOO
  \end{bash}
\end{english}

Получим пустую строку, потому что у потомка нет такой переменной. Выполните
\verb|exit|, чтобы вернуться в родительский шелл.

\index{export}
\index{переменные!экспорт}
\index{переменные!шелла}

Команда \verb|export| помещает переменную в среду. Заданная таким образом,
переменная видна \verb|printenv|:

\begin{english}
  \begin{bash}
$ export FOO=42
$ printenv | grep FOO
FOO=42
  \end{bash}
\end{english}

\noindent
и процессам-потомкам:

\begin{english}
  \begin{bash}
$ sh
$ echo $FOO
42
  \end{bash}
\end{english}

Иногда нужно запустить процесс с переменной, но так, чтобы не повлиять на
текущее состояние. Тогда выражение \verb|ИМЯ=значение| ставят перед основной
командой:

\begin{english}
  \begin{bash}
$ BAR=99 printenv | grep BAR
BAR=99
  \end{bash}
\end{english}

\verb|Printenv| порождает новый процесс, которому доступна переменная
\verb|BAR|. Если снова напечатать \verb|$BAR|, получим пустую строку.

\index{базы данных!PostgreSQL}

Программы читают параметры из переменных среды. Клиент к~базе данных PostgreSQL
различает два десятка переменных: \verb|PGHOST|, \verb|PGDATABASE|,
\verb|PGUSER| и другие. У переменных среды выше приоритет, чем у параметров
\verb|--host|, \verb|--user| и аналогов. Если в текущем шелле выполнить:

\ifx\devicetype\mobile

\begin{english}
  \begin{bash}
$ export PGHOST=host.com \
    PGDATABASE=project,
  \end{bash}
\end{english}

\else

\begin{english}
  \begin{bash}
$ export PGHOST=host.com PGDATABASE=project,
  \end{bash}
\end{english}

\fi

\noindent
то каждая утилита PostgreSQL сработает на заданном сервере и базе. Это удобно
для серии команд: не придётся каждый раз указывать \verb|--host| и другие
аргументы.

Обратите внимание на префикс \verb|PG|. Он нужен, чтобы не затереть чужую
переменную \verb|HOST|. В среде нет пространств имён, поэтому префикс~--- это
единственный способ отделить ваши переменные от других.

\section{Конфигурация в среде}

Переменными среды можно задать конфигурацию. Каждый язык предлагает функции,
чтобы читать переменные в строки или словарь. Разберём плюсы и минусы этого
подхода.

Поскольку окружение находится в памяти, приложение не обращается к диску при их
чтении. Дело не в том, что память быстрее диска: человек не отличит сотую долю
секунды от тысячной. Приложение, которое не зависит от файлов, более автономно и
потому удобней в~поддержке.

Иногда файл конфигурации оказался в другой папке и приложение не может его
найти. Или, что хуже, запускается со старой версией файла. Это замедляет работу
и вносит путаницу.

\label{password-note}

\index{безопасность!конфигурации}

Хранить пароли и ключи в переменных безопаснее, чем в файлах. В случае с файлами
их могут прочесть другие программы, в том числе вредоносные. По ошибке файл
может попасть в репозиторий и остаться в истории. Существуют скрипты, которые
ищут в открытых репозиториях ключи к облачным платформам и кошелькам (и порой
находят, к сожалению).

Даже если файлом владеет другой пользователь, он может быть доступен для чтения
остальным. Переменные среды эфемерны: они живут только памяти операционной
системы. Один пользователь не может прочесть переменные другого~--- это
ограничение на уровне операционной системы.

\index{контейнеры}
\index{виртуализация}

Индустрия переходит от файлов к виртуализации. Если раньше мы копировали файлы
по FTP, то сегодня приложение запускают из образов. Это архив, в который
упакованы код и его окружение. В отличие от настоящего архива, образ нельзя
изменить. Чтобы обновить файл в~образе, нужно собрать его заново, что усложняет
процесс.

\index{Docker}

Наоборот, виртуализация лояльна к переменным среды. Их указывают при запуске
образа в параметрах. Один и тот же образ используют с разными переменными; новая
сборка не требуется. Чем больше опций можно задать переменными, тем удобней
образ в работе. Ниже сервер PostgreSQL включается с готовой базой и
пользователем:

\begin{english}
  \begin{bash}
$ docker run \
  -e POSTGRES_DB=book \
  -e POSTGRES_USER=ivan \
  -e POSTGRES_PASSWORD=**** \
  -d postgres
  \end{bash}
\end{english}

\index{сайты!12factor.net}

Принцип <<конфигурация в среде>> описан в~\footurl{The Twelve-Factor App}{https://12factor.net}[12-Factor App].
Это свод правил для разработки надёжных приложений. Его третий пункт посвящён конфигурации.
Автор упоминает те же плюсы переменных, что мы рассмотрели: независимость от файлов,
безопасность, поддержка на всех платформах.

\section{Недостатки среды}

\index{декларативность}

Переменные не поддерживают типы: любое значение~--- это текст. Вывод типов остаётся
на ваше усмотрение. Делайте это декларативно, а не вручную. Неудачный пример на
Python:

\index{языки!Python}

\begin{english}
  \begin{python}
db_port = int(os.environ["DB_PORT"])
  \end{python}
\end{english}

Когда переменных больше двух, код становится уродливым. Задайте словарь, где
ключ~--- это имя переменной, а значение~--- функция вывода. Специальный код обходит
словарь и наполняет результат. Для краткости опустим перехват ошибок:

\begin{english}
  \begin{python}
import os
env_mapping = {"DB_PORT": int}

result = {}
for (env, fn) in env_mapping.iteritems():
    result[env] = fn(os.environ[env])
  \end{python}
\end{english}

Подход справедлив и для других языков. В Clojure для этого служит спека.

Переменные среды не работают с иерархией. Это плоский набор ключей и значений,
что не всегда ложится на конфигурацию. Чем больше в ней параметров, тем чаще их
группируют по смыслу. Предположим, подключение к базе задают десять
параметров. Чтобы не ставить перед каждым префикс, их выносят в дочерний
словарь.

\index{вложенность}
\index{коллекции!вложенность}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; so-so
{:db-name "book"
 :db-user "ivan"
 :db-pass "****"}
  \end{clojure}

\splitter

  \begin{clojure}
;; better
{:db {:name "book"
      :user "ivan"
      :pass "****"}}
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
;; so-so
{:db-name "book"
 :db-user "ivan"
 :db-pass "****"}
  \end{clojure}

&

  \begin{clojure}
;; better
{:db {:name "book"
      :user "ivan"
      :pass "****"}}
  \end{clojure}

\end{tabular}

\end{english}

\fi

В разных системах вложенные переменные читают по-разному. Например, одинарное
подчёркивание разделяет лексемы, но не меняет структуру. Двойное подчёркивание
означает вложенность:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
DB_NAME=book
DB_PASS=pass

{:db-name "book"
 :db-pass "pass"}
  \end{clojure}

\splitter

  \begin{clojure}
DB__NAME=book
DB__PASS=pass

{:db {:name "book"
      :pass "pass"}}
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
DB_NAME=book
DB_PASS=pass

{:db-name "book"
 :db-pass "pass"}
  \end{clojure}

&

  \begin{clojure}
DB__NAME=book
DB__PASS=pass

{:db {:name "book"
      :pass "pass"}}
  \end{clojure}

\end{tabular}

\end{english}

\fi

\index{коллекции!массив}

Массив задают в квадратных скобках или через запятую. При разборе массива
возникает риск ложного разбиения. Это случается, когда запятая или скобка
относится к слову, а не к синтаксису.

\index{форматы!JSON}
\index{форматы!YAML}

Форматы JSON и YAML задают чёткий стандарт, как описывать коллекции. Для
переменных среды нет единого соглашения. Ситуация ухудшается, когда ожидают
параметр большой вложенности, например список словарей. Переменные среды не
справляются со структурой.

В разработке проявляется ещё один недостаток переменных~--- в~некоторых системах
они доступны только для чтения. Это верно идеологически, но вынуждает заново
включать REPL на каждое изменение конфигурации. Для файла достаточно изменить
его и~прочитать заново.

\subsection{Env-файлы}

\index{файлы!переменных среды}

Когда переменных много, вводить их вручную через \verb|export|
утомительно. Переменные выносят в файл, который называют
\emph{env}-кон\-фи\-гу\-ра\-цией. Технически это шелл-скрипт, но чем меньше в
нём скриптовых возможностей, тем лучше. В идеале файл содержит только пары
\verb|ИМЯ=значение| по одной на каждую строку. Назовём его просто \verb|ENV| без
расширения.

\begin{english}
  \begin{bash}
DB_NAME=book
DB_USER=ivan
DB_PASS=****
  \end{bash}
\end{english}

Чтобы считать переменные в шелл, вызывают \verb|source <file>|. Это команда
\verb|bash|, которая выполнит скрипт в \emph{текущем} сеансе. Команду используют
так часто, что для краткости её заменяют точкой: \verb|. <file>|. Скрипт добавит
переменные в шелл, и вы увидите их после \verb|source|. Это важное отличие от
команды \verb|bash <file>|: последняя выполнит скрипт в новом шелле, и вы не
увидите изменений в текущем.

\begin{english}
  \begin{bash}
$ source ENV
$ echo $DB_NAME
book
  \end{bash}
\end{english}

Если запустить из текущего шелла приложение, оно всё ещё не получит переменные
из файла. Вспомним, что выражение \verb|VAR=value| задаёт локальную
переменную. \verb|DB_NAME| и другие не попадут в окружение, и~программа не
унаследует их. Проверим это с помощью \verb|printenv|:

\index{утилиты!printenv}

\begin{english}
  \begin{bash}
$ source ENV
$ printenv | grep DB
# exit 1
  \end{bash}
\end{english}

Проблему решают двумя способами. Первый~--- открыть файл и~расставить перед
каждой парой \verb|export|. Тогда \verb|source| этого файла добавит переменные в
окружение:

\begin{english}
  \begin{bash}
$ cat ENV
export DB_NAME=book
export DB_USER=ivan
export DB_PASS=****

$ source ENV
$ printenv | grep DB
DB_NAME=book
DB_USER=ivan
DB_PASS=****
  \end{bash}
\end{english}

Недостаток в том, что в файле появилась логика скрипта. Если не поставить
\verb|export| перед переменной, приложение не прочитает её.

Второй способ основан на параметре \verb|-a| (\textbf{a}llexport) текущего
шелла. Когда он установлен, локальная переменная попадает в окружение. Перед
тем, как читать переменные из файла, флаг возводят в истину, а затем снова в
ложь.

\begin{english}
  \begin{bash}
$ set -a
$ source ENV
$ printenv | grep DB
# prints all the vars
$ set +a
  \end{bash}
\end{english}

Выражение \verb|set| противоречиво: параметр с минусом \emph{включает}
параметр, а с плюсом~--- отключает. Это исключение, которое придётся запомнить.

Если считать переменную, которая уже в окружении, она заменит прежнее
значение. Так появляются файлы с переопределениями. Если нужны особые настройки
для тестов, не обязательно копировать весь файл. Создайте файл с полями,
которые нужно заменить и выполните его после главного.

Пусть тестовые настройки отличаются именем базы. Файл \verb|ENV| содержит
основные параметры, а в \verb|ENV_TEST| поместим новое значение
\verb|DB_NAME=test|. Прочтём оба файла и проверим, что получилось:

\begin{english}
  \begin{bash}
$ set -a
$ source ENV
$ source ENV_TEST
$ set +a

$ echo $DB_NAME
test
  \end{bash}
\end{english}

Читатель заметит, что ENV-файлы противоречивы. Мы сказали, что переменные
снимают зависимость от файлов, но в итоге поместили их в файл. Какой в этом
смысл?

\index{DevOps}

Разница между JSON- и ENV-файлами в том, кто их читает. В~первом случае это
приложение, а во втором~--- операционная система. Файл находится в строго
заданной директории, а переменные среды доступны отовсюду. Мы избавим
приложение от кода, который ищет и читает файл. Заодно облегчим работу коллегам
DevOps: они задают переменные по-разному в зависимости от инструмента (шелл,
Docker, Kubernetes). Так среда становится единой точкой обмена настройками.

\section{Переменные среды в Clojure}

\index{классы!System}

Clojure~--- это гостевая платформа, поэтому язык не предлагает доступ к системным
ресурсам. В главном модуле нет функции для чтения переменных среды. Получим их
из класса \verb|java.lang.System|. Импортировать класс не нужно, он доступен в
любом пространстве имён.

Статический метод \verb|getenv| вернёт либо одну переменную по имени, либо
весь словарь, если имя не указали.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
;; a single variable
(System/getenv "HOME")
"/Users/ivan"

;; all variables
(System/getenv)
;; truncated
{"JAVA_ARCH" "x86_64",
 "LANG" "en_US.UTF-8"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
;; a single variable
(System/getenv "HOME")
"/Users/ivan"

;; all variables
(System/getenv)
{"JAVA_ARCH" "x86_64", "LANG" "en_US.UTF-8"} ;; truncated
  \end{clojure}
\end{english}

\fi

Во втором случае получили не Clojure-, а Java-коллекцию. Это неизменяемая версия
\verb|Map|, поэтому переменные нельзя изменить после запуска JVM.

Чтобы облегчить работу со словарём, приведём его к типу Clojure. Заодно исправим
ключи: сейчас это строки в верхнем регистре и~подчёркиваниями. В Clojure
пользуются кейвордами и записью kebab-case: нижний регистр с дефисами.

Напишем функцию для перевода ключа:

\begin{english}
  \begin{clojure}
(require '[clojure.string :as str])

(defn remap-key [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      keyword))
  \end{clojure}
\end{english}

\noindent
и убедимся в её работе:

\begin{english}
  \begin{clojure}
(remap-key "DB_PORT")
:db-port
  \end{clojure}
\end{english}

\index{функции!remap-env}
\index{функции!remap-key}

Функция \verb|remap-env| проходит по словарю Java и возвращает его
<<кложурную>> версию с привычными ключами:

\begin{english}
  \begin{clojure}
(defn remap-env [env]
  (reduce
   (fn [acc [k v]]
     (let [key (remap-key k)]
       (assoc acc key v)))
   {}
   env))
  \end{clojure}
\end{english}

Приведём небольшую часть словаря:

\begin{english}
  \begin{clojure}
(remap-env (System/getenv))

{:home "/Users/ivan"
 :lang "en_US.UTF-8"
 :term "xterm-256color"
 :java-arch "x86_64"
 :term-program "iTerm.app"
 :shell "/bin/zsh"}
  \end{clojure}
\end{english}

Когда переменные в словаре, они идут по тому же конвейеру: вывод типов,
валидация спекой. Поскольку все значения~--- строки, спеку нужно доработать, чтобы
она выводила числа из строк. Раньше в этом не было нужды, потому что числа
приходили из JSON в готовом виде. Будет удачной спека, которая учитывает и
число, и строку. Вот как выглядит умный парсер числа:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (cond
       (int? value) value
       (string? value)
       (try (Integer/parseInt value)
            (catch Exception e
              ::s/invalid))
       :else ::s/invalid))))
  \end{clojure}
\end{english}

\noindent
С этой спекой можно менять источник данных без изменений в коде.

\subsection{Проблема лишних ключей}

У словаря переменных недостаток~--- много посторонних полей. Приложению не нужно
знать версию терминала или путь к Python. Эти поля вносят шум при печати и
записи в лог. Если спека не прошла проверку, мы увидим лишние данные в
\verb|explain|.

\index{clojure.core!select-keys}
\index{ключи!выборка}

На последнем шаге \verb|s/conform| нужно выбрать из словаря только полезную
часть. Функция \verb|select-keys| вернёт подмножество по списку ключей. Но где
взять ключи? Перечислять их вручную долго, и к~тому же мы дублируем код. Мы уже
указали ключи в спеке \verb|::config|, и~делать это второй раз не хочется. С
помощью трюка мы вытащим ключи \emph{из спеки}.

Функция \verb|s/form| принимает ключ спеки и возвращает <<замороженную>> форму
того, что передали в \verb|s/def|. Это список, где каждый элемент~--- примитив или
коллекция примитивов (число, строка, символ и другие). Для спеки \verb|::config|
получим форму:

\begin{english}
  \begin{clojure}
(clojure.spec.alpha/keys
 :req-un [:book.config/server_port
          :book.config/db
          :book.config/event])
  \end{clojure}
\end{english}

\index{коллекции!список}

Обратите внимание: это \emph{список}, а не код. Нужные ключи находятся в третьем
элементе после \verb|:req-un|. Ст\'{о}ит учесть и другие типы ключей, например
\verb|:opt-un|. Напишем универсальную функцию, которая вернёт все ключи из
\verb|s/keys|.

Отбросим первый символ формы. Останется список, где нечётные элементы~--- тип ключа,
а чётные~--- их вектор. Перестроим список в~словарь и объединим значения. Для
ключей \verb|-un| отбросим пространство. Всё вместе даёт нам функцию:

\index{spec!spec\arr{}keys}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn spec->keys
  [spec-keys]
  (let [form (s/form spec-keys)
        params (apply hash-map
                 (rest form))
        {:keys [req opt req-un opt-un]}
        params
        ->unqualify (comp keyword name)]
    (concat req
            opt
            (map ->unqualify opt-un)
            (map ->unqualify req-un))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn spec->keys
  [spec-keys]
  (let [form (s/form spec-keys)
        params (apply hash-map (rest form))
        {:keys [req opt req-un opt-un]} params
        ->unqualify (comp keyword name)]
    (concat req
            opt
            (map ->unqualify opt-un)
            (map ->unqualify req-un))))
  \end{clojure}
\end{english}

\fi

\noindent
Проверим спеку загрузчика. Действительно, получим три ключа:

\begin{english}
  \begin{clojure}
(spec->keys ::config)
(:server_port :db :event)
  \end{clojure}
\end{english}

\noindent
Перепишем чтение переменных в словарь. На последнем шаге мы выбираем
подмножество этих ключей.

\begin{english}
  \begin{clojure}
(defn read-env-vars []
  (let [cfg-keys (spec->keys ::config)]
    (-> (System/getenv)
        (remap-env)
        (select-keys cfg-keys))))
  \end{clojure}
\end{english}

Преимущество в том, что мы избежали повторов. Если в \verb|::config| появится
новое поле, функция \verb|spec->keys| подхватит его.

\subsection{Загрузчик среды}

Доработаем загрузчик, чтобы он работал с переменными среды. Замените первые два
шага на \verb|read-env-vars|. Теперь программа не зависит от файла
конфигурации.

\begin{english}
  \begin{clojure}
(defn load-config! []
  (-> (read-env-vars)
      (coerce-config)
      (set-config!)))
  \end{clojure}
\end{english}

Сделайте так, чтобы источник данных можно было задать параметром. Например,
\verb|:source "/path/to/config.json"| означает: считать файл, а
\verb|:source :env|~--- переменные среды.

\index{коллекции!слияние}

Ещё сложнее: как считать оба источника и объединить их? Важен ли порядок и
как его обеспечить? Как объединить словари ассиметрично, то есть когда второй
только \emph{замещает} поля первого, но не дополняет новыми?

\subsection{Вывод структуры}

\index{структура}

Редко бывает так, что конфигурация~--- это плоский словарь. Близкие параметры
выносят во вложенные словари, например отдельно поля сервера и базы
данных. Когда настройки в группе, их легче поддерживать. Удачный пример~---
разбиение конфигурации на части с~помощью \clojureinline{{:keys [db server]}}.
Каждый компонент системы принимает одноимённую часть в качестве мини-конфигурации.

Улучшим загрузчик: научим его читать вложенные переменные. Договоримся, что
двойное подчёркивание означает смену уровня. Поместим в файл \verb|ENV_NEST|
следующие переменные:

\begin{english}
  \begin{bash}
DB__NAME=book
DB__USER=ivan
DB__PASS=****
HTTP__PORT=8080
HTTP__HOST=api.random.com
  \end{bash}
\end{english}

\index{REPL}

\noindent
Прочитаем его и запустим REPL с новой средой:

\begin{english}
  \begin{bash}
$ set -a
$ source ENV_NEST
$ lein repl
  \end{bash}
\end{english}

Изменим разбор окружения. Функция \verb|remap-key-nest| принимает ключ-строку и
возвращает вектор составных частей (лексем):

\begin{english}
  \begin{clojure}
(defn remap-key-nest
  [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      (str/split #"--")
      (->> (map keyword))))

(remap-key-nest "DB__PORT")
;; (:db :port)
  \end{clojure}
\end{english}

\index{clojure.core!assoc}
\index{clojure.core!assoc-in}
\index{clojure.core!reduce}

\noindent
Функция обхода вызывает не \verb|assoc|, а \verb|assoc-in|, что порождает
вложенную структуру:

\begin{english}
  \begin{clojure}
(defn remap-env-nest
  [env]
  (reduce
   (fn [acc [k v]]
     (let [key-path (remap-key-nest k)]
       (assoc-in acc key-path v)))
   {}
   env))
  \end{clojure}
\end{english}

Код ниже вернёт параметры по группам, как и задумано. Приведём их подмножество:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(-> (System/getenv)
    (remap-env-nest)
    (select-keys [:db :http]))

{:db {:user "ivan"
      :pass "****"
      :name "book"}
 :http {:port "8080"
        :host "api.random.com"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(-> (System/getenv)
    (remap-env-nest)
    (select-keys [:db :http]))

{:db {:user "ivan", :pass "****", :name "book"},
 :http {:port "8080", :host "api.random.com"}}
  \end{clojure}
\end{english}

\fi

\noindent
Дальше действуем как обычно: пишем спеку, выводим типы из строк и так далее.

Подумайте, как задать в переменной массив. Чем разделить элементы? Когда
возможно ложное разбиение и как его не допустить?

\section{Простой менеджер конфигурации}

\index{менеджер конфигураций}

К этому моменту читатель решит, что конфигурация в файле~--- это плохая идея. Однако
не бросайтесь переписывать код на переменные среды. На практике работают с
\emph{гибридными} моделями, которые сочетают оба подхода. Приложение читает
основные параметры из файла, а пароли и ключи доступа~--- из среды.

\index{утилиты!gettext}
\index{утилиты!envsubst}

Рассмотрим, как подружить файлы и окружение. Наивное решение не потребует писать
код: оно работает на утилитах командной строки. Программа \verb|envsubst| из
пакета GNU gettext предлагает простую шаблонную систему. Чтобы установить
\verb|gettext|, выполните в терминале команду:


\begin{english}
  \begin{bash}
$ <manager> install gettext,
  \end{bash}
\end{english}

\noindent
где \verb|<manager>|~--- это мастер пакетов вашей системы (\verb|brew|,
\verb|apt|, \verb|yum| и~другие).

\index{каналы!stdin}
\index{шаблоны}

Текст шаблона приходит из \verb|stdin|, а роль контекста играют переменные
среды. Утилита заменяет выражения \verb|$VAR_NAME| на значения одноимённой
переменной. Поместим шаблон в файл \verb|config.tpl.json|. Частичка tpl
означает template.

\begin{english}
  \begin{json/lines}
{
    "server_port": $HTTP_PORT,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "$DB_NAME",
        "user":     "$DB_USER",
        "password": "$DB_PASS"
    },
    "event": [
        "$EVENT_START",
        "$EVENT_END"
    ]
}
  \end{json/lines}
\end{english}

\noindent
Обратите внимание, что порт сервера не окружён кавычками, потому что это число
\coderef{2}. Поместим переменные в файл \verb|ENV_TPL|:

\begin{english}
  \begin{bash}
$ cat ENV_TPL
DB_NAME=book
DB_USER=ivan
DB_PASS='*(&fd}A53z#$!'
HTTP_PORT=8080
EVENT_START='2019-07-05T12:00:00'
EVENT_END='2019-07-12T23:59:59'
  \end{bash}
\end{english}

\noindent
Прочитаем их и отрендерим шаблон:

\begin{english}
  \begin{bash}
$ source ENV_TPL
$ cat config.tpl.json | envsubst
  \end{bash}
\end{english}

\begin{listing}[ht!]

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "*(&fd}A53z#$!"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}
\end{english}

\caption{Конфигурация после подстановки переменных}
\label{fig:json-render}

\end{listing}

\noindent
Подстановка прошла успешно (результат рендера в~листинге
\ref{fig:json-render}). Чтобы записать результат в~файл, добавьте в конец
оператор вывода:

\ifx\devicetype\mobile

\begin{english}
  \begin{bash}
$ cat config.tpl.json |
    envsubst > config.ready.json
  \end{bash}
\end{english}

\else

\begin{english}
  \begin{bash}
$ cat config.tpl.json | envsubst > config.ready.json
  \end{bash}
\end{english}

\fi

Способ с \verb|envsubst| на первый взгляд примитивен, но полезен на
практике. Шаблон снимает вопрос о структуре: переменные становятся в нужное
место, и не нужно думать о вложенности.

Иногда приложение требует несколько файлов конфигурации, в~том числе для
инфраструктуры. Порт веб-сервера нужен Nginx для проксирования. В Sendmail нужно
указать тот же адрес почты, что и в~приложении. Очевидно, должен быть единый
источник данных, и~рендер шаблонов ложится на эту модель.

Утилита \verb|envsubst| становится менеджером конфигураций. Чтобы
автоматизировать процесс, добавьте скрипт, который пробегает по шаблонам и
рендерит их переменными. Решение не тянет на <<энтерпрайзный>> уровень, но
подойдёт для простых проектов.

\section{Чтение среды из конфигурации}

Следующие техники делают так, что приложение читает параметры
\emph{одновременно} из файла и среды. Разница в том, на каком шаге это
происходит.

Предположим, основные параметры записаны в файле, а пароль к~базе приходит из
среды. Договоримся с командой, что в поле \verb|:password| записан не пароль,
а имя переменной, например \verb|"DB_PASS"|. Напишем спеку, которая выводит
значение переменной по имени:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::->env
  (s/conformer
   (fn [varname]
     (or (System/getenv varname)
         ::s/invalid))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::->env
  (s/conformer
   (fn [varname]
     (or (System/getenv varname) ::s/invalid))))
  \end{clojure}
\end{english}

\fi

Если переменную не задали, вывод вернёт ошибку. Для большего контроля
отбросим пробелы по краям и убедимся, что строка не пустая.

\begin{english}
  \begin{clojure}
(s/def ::db-password
  (s/and ::->env
         (s/conformer str/trim)
         not-empty))
  \end{clojure}
\end{english}

Быстрая проверка: запустим REPL с переменной \verb|DB_PASS| и прочитаем её
спекой:

\begin{english}
  \begin{bash}
DB_PASS='*(&fd}A53z#$!' lein repl

(s/conform ::db-password "DB_PASS")
"*(&fd}A53z#$!"
  \end{bash}
\end{english}

Чтобы вынести поле из файла в среду, замените его значение на имя
переменной. Обновите спеку этого поля: добавьте \verb|::->env| в начало цепочки
\verb|s/and|.

\index{теги!EDN}

Другой способ прочитать переменные из файла~--- расширить его \emph{тегами}. Тег~---
это короткое слово, которое указывает, что значение за ним читают особым
образом. Форматы YAML и EDN поддерживают теги. Библиотеки для них предлагают
несколько основных тегов. По желанию их набор можно расширить.

\index{даты!разбор}
\index{модули!clojure.edn}

В EDN тег начинается со знака решётки и захватывает следующее
значение. Например, \verb|#inst "2019-07-10"| выводит дату из строки. Тег связан
с функцией одного аргумента, которая находит значение из исходного. Чтобы задать
свой тег, в функцию \verb|clojure.edn/read-string| передают специальный
словарь. Его ключи~--- это символы, значения~--- функции.

Добавим тег \verb|#env|, который вернёт значение переменной по имени. Имя
может быть строкой или символом. Определим функцию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn tag-env
  [varname]
  (cond
    (symbol? varname)
    (System/getenv (name varname))
    (string? varname)
    (System/getenv varname)
    :else
    (throw
      (new Exception
        "Wrong variable type"))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn tag-env
  [varname]
  (cond
    (symbol? varname)
    (System/getenv (name varname))
    (string? varname)
    (System/getenv varname)
    :else
    (throw (new Exception "Wrong variable type"))))
  \end{clojure}
\end{english}

\fi

\noindent
Прочитаем EDN-строку с новым тегом:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[clojure.edn :as edn])

(edn/read-string
  {:readers {'env tag-env}}
  "{:db-password #env DB_PASS}")
;; {:db-password "*(&fd}A53z#$!"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.edn :as edn])

(edn/read-string {:readers {'env tag-env}}
                 "{:db-password #env DB_PASS}")
;; {:db-password "*(&fd}A53z#$!"}
  \end{clojure}
\end{english}

\fi

Чтобы не передавать теги каждый раз, подготовим \verb|partial| от
\verb|edn/read-string|. Новая функция принимает только строку:

\begin{english}
  \begin{clojure}
(def read-config
  (partial edn/read-string
           {:readers {'env tag-env}}))
  \end{clojure}
\end{english}

Чтобы разобрать файл с тегами, считайте его в строку и передайте в
\verb|read-config|:

\begin{english}
  \begin{clojure}
(-> "/path/to/config.edn"
    slurp
    read-config)
  \end{clojure}
\end{english}

YAML тоже предусматривает теги. Они начинаются с одного или двух восклицательных
знаков в зависимости от семантики. У стандартных тегов два знака, а у сторонних
(пользовательских) один. Так мы сразу поймём семантику тега, когда встретим его.

\index{форматы!YAML}
\index{библиотеки!Yummy}
\index{теги!YAML}

Библиотека Yummy предлагает парсер YAML, <<заряженный>> полезными тегами. Среди
прочих нас интересует \verb|!envvar|, который вернёт значение переменной по
имени. Опишем конфигурацию в файле \verb|config.yaml|:

\begin{english}
  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     !envvar DB_USER
  password: !envvar DB_PASS
  \end{yaml}
\end{english}

Подключим библиотеку и прочитаем файл. На месте тегов получим значения среды:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[yummy.config :as yummy])
(yummy/load-config
  {:path "config.yaml"})

{:server_port 8080
 :db {:dbtype "mysql"
      :dbname "book"
      :user "ivan"
      :password "*(&fd}A53z#$!"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[yummy.config :as yummy])
(yummy/load-config {:path "config.yaml"})

{:server_port 8080
 :db {:dbtype "mysql"
      :dbname "book"
      :user "ivan"
      :password "*(&fd}A53z#$!"}}
  \end{clojure}
\end{english}
\fi


\noindent
Мы подробно рассмотрим Yummy в следующем разделе главы.

Теги несут преимущества и недостатки. С одной стороны, они делают конфигурацию
плотнее: строка с тегом несёт больше смысла. Запись \verb|#env DB_PASS| выглядит
короче и приятней глазу. Сложные теги выносят в библиотеки и подключают в
зависимости.

С другой стороны, теги привязывают конфигурацию к платформе. Если в YAML-файле
встречается тег \verb|!envvar|, библиотека на Python не~сможет его прочитать: в
ней нет такого тега (точнее, есть, но с~другим именем). Технически это можно
исправить: пропускать незнакомые теги или установить заглушку. Однако подход не
гарантирует одинаковый результат на разных платформах.

С тегами конфигурация обрастает побочными эффектами. В терминах функционального
программирования~--- она теряет чистоту. Появляется соблазн вынести в тег слишком
много логики: включить дочерний файл, форматировать строки. Теги стирают грань
между чтением конфигурации и её обработкой. Когда их слишком много, конфигурацию
трудно поддерживать.

Оба приёма~--- разбор спекой и тегами~--- оппонируют друг другу. Выбирайте тот
способ, который удобен команде и процессу.

\section{Короткий обзор форматов}

Мы упомянули три формата данных: JSON, EDN и YAML. Перечислим особенности
каждого из них. Наша цель не выявить идеальный формат, а подготовить читателя к
неочевидным моментам, которые возникнут в работе с ними.

\subsection{JSON}

\index{форматы!JSON}

С JSON знакомы даже те, кто не работает с вебом. Это запись данных по правилам
JavaScript. Стандарт задаёт числа, строки, логический тип, null и две коллекции:
массив и словарь. Коллекции могут быть вложены друг в друга.

\index{языки!JavaScript}

Преимущество JSON в его популярности: сегодня это стандарт обмена данными между
клиентом и сервером. По сравнению с XML его легче читать и поддерживать. С JSON
работают современные редакторы, языки и платформы. Это естественный способ
хранить данные в~JavaScript.

В JSON не предусмотрены комментарии. На первый взгляд, это мелочь, но на практике
комментарии важны. Если вы добавили новый параметр, напишите комментарий о том,
что он делает и какие значения принимает. Посмотрите конфигурации Redis,
PostgreSQL или Nginx~--- больше половины файла занимают комментарии.

Разработчики придумали уловки, чтобы обойти ограничение. Например, поставить
одноимённое поле перед тем, к которому относится комментарий:

\ifx\devicetype\mobile

\begin{english}
  \begin{json}
{
    "server_port":
    "A port for the HTTP server.",
    "server_port": 8080
}
  \end{json}
\end{english}

\else

\begin{english}
  \begin{json}
{
    "server_port": "A port for the HTTP server.",
    "server_port": 8080
}
  \end{json}
\end{english}
\fi


Расчёт сделан на то, что библиотека обходит поля по очереди и~второе поле
заменит первое. Стандарт JSON ничего не говорит о~порядке полей; приём остаётся
на ваш риск. Логика библиотеки может быть иной, например бросить исключение или
пропустить ключ, который уже обработан.

Иногда в JSON добавляют комментарии на уровне продукта. Редактор Sublime Text
хранит настройки в \verb|.json|-файлах с поддержкой JavaScript-комментариев (двойная
косая черта). В общем случае у~проблемы нет решения.

\index{библиотеки!Cheshire}

Формат не поддерживает теги, о которых мы говорили выше. Для работы с ним служат
библиотеки
\footurl{Cheshire}{https://github.com/dakrone/cheshire}[Cheshire][-22mm] и
\footurl{Data.json}{https://github.com/clojure/data.json}[Data.json].

JSON выгодно отличается от многословного XML, которому пришёл на замену. Данные
в JSON выглядят чище и удобнее, чем дерево тегов. Но современные форматы
выражают данные ещё чище. В YAML любую структуру можно записать без единой
скобки за счёт отступов.

Синтаксис JSON <<шумит>>: он требует кавычек, двоеточий и запятых там, где
другие форматы обходятся без них. Запятая в конце массива или объекта считается
ошибкой. Ключи словаря не могут быть числами. Нельзя записать текст в несколько
строк.

Сравните данные в JSON и YAML. Вторая запись короче и визуально спокойнее:

\ifx\devicetype\mobile

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}

\splitter

  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     user
  password: '****'
event:
  - 2019-07-05T12:00:00
  - 2019-07-12T23:59:59
  \end{yaml}
\end{english}

\else

\begin{english}

\noindent

\begin{tabular}{ @{}p{6cm} @{}p{4cm} }

  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}

&

\linegap

  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     user
  password: '****'
event:
  - 2019-07-05T12:00:00
  - 2019-07-12T23:59:59
  \end{yaml}

\end{tabular}

\end{english}

\fi

\subsection{YAML}

\index{форматы!YAML}

Язык YAML, как и JSON, различает базовые типы: скаляры, null и~коллекции. YAML
делает ставку на краткость записи: вложенность задают отступы, а не
скобки. Запятые необязательны там, где язык выводит их логически. Массив чисел
в одну строку выглядит как в~JSON:

\index{коллекции!в YAML}

\begin{english}
  \begin{yaml}
numbers: [1, 2, 3]
  \end{yaml}
\end{english}

\noindent
Но при записи в столбик запятые и скобки отпадают:

\begin{english}
  \begin{yaml}
numbers:
  - 1
  - 2
  - 3
  \end{yaml}
\end{english}

YAML поддерживает комментарии в стиле Python (знак решётки), за что его любят
DevOps. Программы вроде Docker-compose и~Kubernetes читают настройки из
YAML-файлов.

В YAML можно записать текст в несколько строк. Его проще читать и~копировать,
чем одну строку с~символом переноса \verb|\n| \lis{fig:yaml-multi-line}.

\begin{listing}[ht!]

\ifx\devicetype\mobile

\begin{english}
  \begin{yaml}
description: |
  To solve the problem,
  please do the following:

  - Press Control + Alt + Delete;
  - Turn off your computer;
  - Walk for a while.

  Then try again.
  \end{yaml}
\end{english}

\else

\begin{english}
  \begin{yaml}
description: |
  To solve the problem, please do the following:

  - Press Control + Alt + Delete;
  - Turn off your computer;
  - Walk for a while.

  Then try again.
  \end{yaml}
\end{english}

\fi

\caption{Сообщение из нескольких строк в YAML}
\label{fig:yaml-multi-line}

\end{listing}

Язык официально поддерживает теги.

\index{отступы!в YAML}

Недостатки YAML вытекают из его преимуществ. Отступы кажутся удачным решением до
тех пор, пока файл не станет большим. Глаз прыгает на большие расстояния, чтобы
сверять уровни структур. Иногда часть данных <<съезжает>> из-за лишнего
отступа. С точки зрения YAML ошибки нет, поэтому её трудно найти.

Иногда отказ от кавычек приводит к неверным типам или структуре. Предположим, в
поле \verb|phrases| перечислены фразы, которые увидит пользователь:

\begin{english}
  \begin{yaml}
phrases:
  - Welcome!
  - See you soon!
  - Warning: wrong email address.
  \end{yaml}
\end{english}

Из-за двоеточия в последней строке парсер решит, что это вложенный
словарь. Получим неверную структуру:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:phrases
 ["Welcome!"
  "See you soon!"
  {:Warning "wrong email address."}]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:phrases ["Welcome!"
           "See you soon!"
           {:Warning "wrong email address."}]}
  \end{clojure}
\end{english}

\fi

Другие примеры: версия продукта \verb|3.3|~--- это число, но \verb|3.3.1|~---
строка. Телефон \verb|+79625241745|~--- это число, потому что знак плюса считается
унарным оператором по аналогии с минусом. Лидирующие нули означают восьмеричную
запись: если не добавить кавычки к \verb|000042|, получится \verb|34|.

Это не значит, что YAML неудачный формат. Случаи выше описаны в стандарте и
имеют логическое объяснение. Но иногда YAML ведёт себя не так, как вы
ожидали,~--- это плата за упрощённый синтаксис.

\subsection{EDN}

\index{форматы!EDN}

Формат EDN занимает особое место в обзоре. Он максимально приближен к Clojure и
поэтому играет такую же роль в языке, как JSON в~JavaScript. Это родной способ
связать данные с файлом.

Синтаксис EDN почти полностью совпадает с грамматикой языка. Формат охватывает
больше типов, чем JSON и YAML. Из скаляров доступны символы и кейворды (классы
\verb|Symbol| и \verb|Keyword| из \verb|clojure.lang|). Кроме вектора и словаря
EDN предлагает списки и~множества. Словари могут быть типизированными, чтобы при
чтении получались экземпляры записей. Подробнее о записях мы поговорим в~главе
про системы \page{defrecord}.

\index{теги!EDN}

Тег начинается с символа решётки. По умолчанию стандарт предлагает два тега:
\verb|#inst| и \verb|#uuid|. Первый читает строку в дату, а~второй~---
в~экземпляр \verb|java.util.UUID|. Идентификаторы используют в~распределённых
системах вроде Cassandra и Kafka. Выше мы показали, как добавить свой тег: нужно
связать его с функцией одного аргумента при чтении строки.

Пример с разными типами, коллекциями и тегами:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:user/banned? false
 :task-state
 #{:pending :in-progress :done}
 :account-ids
 [1001 1002 1003 nil]
 :server
 {:host "127.0.0.1" :port 8080}
 :date-range
 [#inst "2019-07-01" #inst "2019-07-31"]
 :cassandra-id #uuid
 "26577362-902e-49e3-83fb-9106be7f60e1"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:user/banned? false
 :task-state #{:pending :in-progress :done}
 :account-ids [1001 1002 1003 nil]
 :server {:host "127.0.0.1" :port 8080}
 :date-range [#inst "2019-07-01" #inst "2019-07-31"]
 :cassandra-id #uuid "26577362-902e-49e3-83fb-9106be7f60e1"}
  \end{clojure}
\end{english}

\fi

Данные в EDN не отличаются от кода. Если скопировать их в REPL или модуль,
компилятор выполнит их. И наоборот: вывод REPL можно записать в файл для
дальнейшей работы.

Функция \verb|pr-str| переводит данные в текст. Сброс в EDN сводится к простым
шагам: <<напечатать>> данные в строку и записать её в файл. Ниже результат
функции пишут в файл \verb|dataset.edn|:

\begin{english}
  \begin{clojure}
(-> (get-dataset)
    (pr-str)
    (->> (spit "dataset.edn")))
  \end{clojure}
\end{english}

Обратное действие~--- прочитать файл и распарсить код на Clojure с~помощью
\verb|read-string|:

\begin{english}
  \begin{clojure}
(-> "dataset.edn" slurp read-string)
;; {:some ["data"]}
  \end{clojure}
\end{english}

\index{синтаксис!\texttt{\#\_} (игнорирование)}

EDN поддерживает не только обычные комментарии. Тег \verb|#_| игнорирует
следующий за ним элемент. Им может быть что угодно, в том числе коллекция. Если
нужно <<заигнорить>> словарь, который занимает несколько строк, поставьте перед
ним \verb|#_|, и парсер пропустит его.

\index{синтаксис!\texttt{;} (комментарий)}

Так отключают целые части конфигурации. В следующем примере мы игнорируем третий
элемент вектора. Если поставить обычный комментарий на строку (точку с запятой),
он заденет закрывающие скобки, и выражение станет неверным.

\begin{english}
  \begin{clojure}
{:users [{:id 1 :name "Ivan"}
         {:id 2 :name "Juan"}
         #_{:id 3 :name "Huan"}]}
  \end{clojure}
\end{english}

EDN~--- это удачный выбор, когда и бекэнд, и фронтэнд работают на~стеке Clojure и
ClojureScript.

EDN привязан к Clojure и поэтому непопулярен в других языках. Редакторы не
подсвечивают его синтаксис без плагинов. EDN доставит проблем DevOps, которые
работают в основном с JSON и YAML. Если конфигурацию читают скрипты на Python
или Ruby, придётся ставить библиотеку для работы с форматом. EDN выбирают там,
где Clojure преобладает над другими технологиями.

\section{Промышленные решения}

Понимать конфигурацию важно, но мы не ожидаем, что в каждом проекте её пишут с
нуля. В последнем разделе мы рассмотрим, что предлагает сообщество для
конфигурации проектов. Мы остановили внимание на Cprop, Aero и Yummy. Библиотеки
отличаются идеологией и архитектурой. Мы специально подобрали их так, чтобы
увидеть проблему с разных сторон.

\subsection{Cprop}

\index{библиотеки!Cprop}

Библиотека \footurl{Cprop}{https://github.com/tolitius/cprop}[Cprop] работает по принципу
<<данные отовсюду>>. В отличие от нашего загрузчика, Cprop понимает больше
источников. Библиотека читает не только файл и переменные среды, но и ресурсы,
property-файлы и обычные словари.

В библиотеке задан порядок обхода источников и их приоритет. Поля одного
источника заменяют другие. Например, переменные среды считаются более важными,
чем файл. Для частных случаев в~Cprop легко задать свой порядок загрузки.

Нас интересует функция \verb|load-config|. Без параметров она запускает
стандартный загрузчик. По умолчанию он ищет два источника данных: ресурс и
property-файл. Ресурс должен называться \verb|config.edn|. Если системное
свойство \verb|conf| не пустое, библиотека полагает, что это путь к
property-файлу, и загружает его.

Свойства~--- это переменные Java-машины, аналог среды окружения JVM. При загрузке
она получает свойства по умолчанию: тип операционной системы, разделитель строк
и другие. Дополнительные свойства задают параметром \verb|-D| при
запуске. Пример ниже запускает jar-файл со свойством \verb|conf|:

\index{JVM!Jar}
\index{JVM!properties}

\ifx\devicetype\mobile

\begin{english}
  \begin{bash}
$ java \
   -Dconf="/path/to/config.properties" \
   -jar project.jar
  \end{bash}
\end{english}

\else

\begin{english}
  \begin{bash}
$ java -Dconf="/path/to/config.properties" -jar project.jar
  \end{bash}
\end{english}

\fi

Файлы \verb|.properties|~--- это пары \verb|поле=значение|, по одной на
строку. Поля похожи на домены: это лексемы, разделённые точкой. Лексемы убывают
по старшинству:

\begin{english}
  \begin{ini}
db.type=mysql
db.host=127.0.0.1
db.pool.connections=8
  \end{ini}
\end{english}

Библиотека трактует точки как вложенные словари. Файл выше вернёт структуру:

\begin{english}
  \begin{clojure}
{:db {:type "mysql"
      :host "127.0.0.1"
      :pool {:connections 8}}}
  \end{clojure}
\end{english}

Получив конфигурацию, Cprop ищет переопределения в переменных среды. Для них
работают те же правила, что и в нашем загрузчике. Например, переменная
\verb|DB__POOL__CONNECTIONS=16| заменит значение 8 во вложенном словаре. Cprop
игнорирует переменные, которые не входят в~конфигурацию, и тем самым не
загрязняет~её.

Нестандартные пути к ресурсу и файлу задают ключами:

\begin{english}
  \begin{clojure}
(load-config
 :resource "private/config.edn"
 :file "/path/custom/config.edn")
  \end{clojure}
\end{english}

\index{модули!cprop.source}

Для тонкой работы Cprop предлагает модуль \verb|cprop.source|. Его функция
\verb|from-env| читает все переменные среды, \verb|from-props-file| загрузит
property-файл и так далее. Легко построить такую комбинацию, которая нужна
проекту.

Ключ \verb|:merge| объединяет конфигурацию с любым источником. В~нём
следуют выражения, которые вернут словарь. Уберпример из документации:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(load-config
 :resource "path/within/classpath/to.edn"
 :file "/path/to/some.edn"
 :merge
 [{:datomic {:url "datomic:mem://test"}}
  (from-file "/path/to/another.edn")
  (from-resource
  "path/within/classpath/to-another.edn")
  (from-props-file
   "/path/to/some.properties")
  (from-system-props)
  (from-env)])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(load-config
 :resource "path/within/classpath/to.edn"
 :file "/path/to/some.edn"
 :merge [{:datomic {:url "datomic:mem://test"}}
         (from-file "/path/to/another.edn")
         (from-resource "path/within/classpath/to-another.edn")
         (from-props-file "/path/to/some.properties")
         (from-system-props)
         (from-env)])
  \end{clojure}
\end{english}

\fi

Чтобы отследить загрузку, установите переменную среды \verb|DEBUG=y|. С~ней
Cprop выводит служебную информацию: список источников, порядок загрузки,
переопределение и так далее.

Cprop только читает данные из источников, но не проверяет их. В~библиотеке нет
валидации спекой, как это сделано в нашем загрузчике. Шаг остаётся на ваше
усмотрение.

Библиотека по-своему выводит типы. Если строка состоит только из цифр, её
приводят к числу. Значения с запятыми становятся списками. Иногда этих правил
недостаточно для полного контроля за типами. Вам по-прежнему понадобятся
Spec и \verb|s/conform| для вывода типов и~сообщений об ошибке.

\subsection{Aero}

\index{библиотеки!Aero}

\footurl{Aero}{https://github.com/juxt/aero}[Aero][1mm] работает с файлами
EDN. Библиотека предлагает теги, с которыми формат похож на мини-язык
программирования. В нём появляются операторы ветвления, импорта,
форматирования. По-другому подход называют <<EDN на стероидах>>.

\index{модули!aero.core}

Функция \verb|read-config| читает файл или ресурс EDN:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[aero.core :refer (read-config)])

(read-config "config.edn")
(read-config
  (clojure.java.io/resource
    "config.edn"))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[aero.core :refer (read-config)])

(read-config "config.edn")
(read-config (clojure.java.io/resource "config.edn"))
  \end{clojure}
\end{english}

\fi

\index{теги!Aero}

Теги~--- это главный момент в Aero, поэтому разберём основные из них. Знакомый нам
\verb|#env| меняет имя переменной среды на значение:

\begin{english}
  \begin{clojure}
{:db {:passwod #env DB_PASS}}
  \end{clojure}
\end{english}

Тег \verb|#envf| форматирует строку переменными среды. Предположим,
подключение к базе состоит из отдельных полей, но вы предпочитаете JDBC URI~---
длинную строку, похожую на веб-адрес. Чтобы не повторяться, адрес вычисляют из
исходных полей:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:db-uri
 #envf ["jdbc:postgresql://%s/%s?user=%s"
        DB_HOST DB_NAME DB_USER]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:db-uri #envf ["jdbc:postgresql://%s/%s?user=%s"
                DB_HOST DB_NAME DB_USER]}
  \end{clojure}
\end{english}

\fi

Тег \verb|#or| похож на аналог Clojure и нужен для значений по
умолчанию. Пусть в файле не задан порт базы данных. Чтобы избежать ошибки,
укажем стандартный порт PostgreSQL:

\begin{english}
  \begin{clojure}
{:db {:port #or [#env DB_PORT 5432]}}
  \end{clojure}
\end{english}

\index{профили!Aero}

Оператор \verb|#profile| позволяет найти значение по
\emph{профилю}. Значение за тегом должно быть словарём. Ключ словаря~--- это
профиль, а~значение~--- то, что получим в результате его разрешения. Профиль
задают в параметрах \verb|read-config|.

Пример ниже показывает, как найти имя базы по профилю. Без профиля получим
\verb|"book"|, но для \verb|:test| имя станет \verb|"book_test"|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:db
 {:name
  #profile {:default "book"
            :dev     "book_dev"
            :test    "book_test"}}}

(read-config "aero.test.edn"
  {:profile :test})
{:db {:name "book_test"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:db {:name #profile {:default "book"
                      :dev     "book_dev"
                      :test    "book_test"}}}

(read-config "aero.test.edn" {:profile :test})
{:db {:name "book_test"}}
  \end{clojure}
\end{english}

\fi

Тег \verb|#include| помещает в конфигурацию другой EDN-файл. В~нём тоже могут
быть теги, и библиотека выполнит их рекурсивно. К~импорту прибегают, когда
конфигурация становится большой.

\begin{english}
  \begin{clojure}
{:queue #include "message-queue.edn"}
  \end{clojure}
\end{english}

Тег \verb|#ref| ставит ссылку на любое место конфигурации. Это вектор ключей,
который обычно передают в \verb|get-in|. Ссылка позволит избежать повторов.
Например, компонент фоновой задачи нуждается в~пользователе, которого мы указали
для базы. Чтобы не копировать его, поставим ссылку:

\begin{english}
  \begin{clojure}
;; config.edn
{:db {:user #env DB_USER}
 :worker {:user #ref [:db :user]}}
  \end{clojure}
\end{english}

\noindent
При чтении файла ссылка разрешается в~значение:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:db {:user "ivan"}
 :worker {:user "ivan"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:db {:user "ivan"}, :worker {:user "ivan"}}
  \end{clojure}
\end{english}

\fi

Aero предлагает несложный язык описания конфигурации. Библиотека подкупает идеей
и красотой реализации. Но в момент, когда вам захочется переехать с негибкого
JSON на Aero, подумайте об обратной стороне медали.

\index{декларативность}

Конфигурацию не случайно отделяют от кода. Если бы не потребность индустрии, мы
бы хранили параметры в исходных файлах. Но этого не делают~--- наоборот, хорошие
практики советуют \emph{отделять} параметры от кода. В том числе потому, что, в
отличие от кода, конфигурация \emph{декларативна}.

Негибкие JSON-файлы обладают важным свойством: они декларативны. Если вы открыли
файл или сделали \verb|cat|, то увидите данные. Синтаксис может быть неудобен,
но данные выражаются сами в себя, и ошибки быть не может.

Наоборот, файл с обилием тегов труден в поддержке. Это не конфигурация,
а \emph{код}. Чтобы увидеть данные, файл нужно выполнить. При чтении
файла в голове запускается мини-интерпретатор, который не гарантирует
правильный результат.

Получается своего рода круг: мы вынесли параметры в конфигурацию, добавили теги
и вернулись к коду. Подход имеет право на жизнь, но к нему приходят осознанно.

\subsection{Yummy}

\index{библиотеки!Yummy}
\index{организации!Exoscale}

Библиотека \footurl{Yummy}{https://github.com/exoscale/yummy}[Yummy][1mm] замыкает обзор. От
аналогов она отличается двумя свойствами. Во-первых, работает с файлами YAML для
чтения конфигурации (отсюда и название). Во-вторых, процесс загрузки похож на
тот, что мы рассмотрели в начале главы.

Полноценный загрузчик не только читает параметры. Цикл включает проверку данных
и вывод ошибки. Сообщение внятно объясняет, в~чём причина. С помощью опций можно
задать реакцию на исключение, которые возникло в работе. Yummy предлагает всё из
перечисленного.

Путь к файлу либо указывают в параметрах, либо библиотека ищет его по особым
правилам. Вариант, когда путь задан явно:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[yummy.config :refer [load-config]])

(load-config
  {:path "/path/to/config.yaml"})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[yummy.config :refer [load-config]])

(load-config {:path "/path/to/config.yaml"})
  \end{clojure}
\end{english}

\fi

Во втором случае вместо пути указали имя проекта. Yummy ищет путь к файлу в
переменной среды \verb|<project>_CONFIGURATION| или свойстве
\verb|<project>.configuration|:

\begin{english}
  \begin{bash}
$ export BOOK_CONFIGURATION=config.yaml
  \end{bash}
\end{english}

\begin{english}
  \begin{clojure}
(load-config {:program-name :book})
  \end{clojure}
\end{english}

Библиотека расширяет YAML несколькими тегами. Это знакомый \verb|!envvar|
для переменных среды:

\index{теги!Yummy}

\begin{english}
  \begin{yaml}
db:
  password: !envvar DB_PASS
  \end{yaml}
\end{english}

\noindent
Тег \verb|!keyword| полезен, чтобы привести строку к кейворду:

\begin{english}
  \begin{yaml}
states:
  - !keyword task/pending
  - !keyword task/in-progress
  - !keyword task/done
  \end{yaml}
\end{english}

\noindent
Результат:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:states [:task/pending
          :task/in-progress
          :task/done]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:states [:task/pending :task/in-progress :task/done]}
  \end{clojure}
\end{english}

\fi

Тег \verb|!uuid| аналогичен \verb|#uuid| для EDN: он возвращает объект
\verb|java.util.UUID| из строки:

\ifx\devicetype\mobile

\begin{english}
  \begin{yaml}
system-user: !uuid
    cb7aa305-997c-4d53-a61a-38e0d8628dbb
  \end{yaml}
\end{english}

\else

\begin{english}
  \begin{yaml}
system-user: !uuid cb7aa305-997c-4d53-a61a-38e0d8628dbb
  \end{yaml}
\end{english}

\fi

Тег \verb|!slurp| читает файл, что полезно для сертификатов шифрования. Их
содержимое~--- это длинная строка, которую неудобно хранить в общей конфигурации. В
ключах \verb|:auth|, \verb|:cert| и \verb|:pkey| окажется содержимое
файлов из папки \verb|certs|.

\begin{english}
  \begin{yaml}
tls:
  auth: !slurp "certs/ca.pem"
  cert: !slurp "certs/cert.pem"
  pkey: !slurp "certs/key.pk8"
  \end{yaml}
\end{english}

\index{spec!assert}

Чтобы проверить конфигурацию, в параметры \verb|load-config| передают ключ
спеки. Когда ключ указан, Yummy выполняет \verb|s/assert| над данными из
файла. Если проверка вернула ложь, всплывает исключение. Yummy использует
Expound, чтобы улучшить текст об ошибке.

\begin{english}
  \begin{clojure}
(load-config {:program-name :book
              :spec ::config})
  \end{clojure}
\end{english}

\index{die-fn}
\index{функция смерти}

Словарь опций принимает параметр \verb|:die-fn|. Это функция, которая
сработает, если любая стадия завершится с ошибкой. Функция принимает исключение
и метку с именем стадии.

\index{каналы!stderr}

Если \verb|:die-fn| не задан, Yummy вызовет обработчик по умолчанию. Он
выводит текст в \verb|stderr| и завершает JVM с кодом 1. На этапе разработки
мы не хотим обрывать REPL из-за ошибки в конфигурации. В интерактивном сеансе
наша \verb|die-fn| только печатает текст и ошибку:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (binding [*out* *err*]
              (println msg
                (ex-message e))))})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (binding [*out* *err*]
              (println msg (ex-message e))))})
  \end{clojure}
\end{english}

\fi

\noindent
В боевом режиме запишем исключение в лог и завершим программу.

\index{логирование}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (log/error e
              "Config error" msg)
            (System/exit 1))})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (log/error e "Config error" msg)
            (System/exit 1))})
  \end{clojure}
\end{english}

\fi

Для валидации Yummy вызывает \verb|s/assert|. Макрос не выводит значения, как
это делает \verb|s/conform|, а только бросает исключение. Это сделано нарочно:
типы выводят тегами, а спека только проверяет их.

\section{Заключение}

Перечислим основные тезисы из этой главы. Конфигурация нужна, чтобы проект шёл
по стадиям производства: разработка, тестирование, релиз. На каждом шаге его
запускают с разными настройками. Без конфигурации это невозможно.

Загрузка конфигурации означает чтение данных, вывод типов и~проверку значений. В
случае ошибки программа выводит сообщение и~завершается с аварийным
кодом. Нельзя продолжать работу с неверными параметрами.

Источниками конфигурации могут быть файл, ресурс, переменные окружения. Бывают
гибридные схемы, когда основные данные приходят из файла, а секретные поля~--- из
окружения.

Переменные среды живут в памяти операционной системы. Когда переменных много, их
помещают в ENV-файл. Приложение не читает его: это делает скрипт, который
управляет приложением на сервере. Приложению неизвестно, откуда пришли
переменные.

Окружение~--- это плоский словарь. Переменные хранят только текст, в ключах нет
вложенности или пространств имён. В разных системах свои соглашения о том, как
извлечь структуру из имени переменной. Это могут быть точки, двойные
подчеркивания или что-то ещё.

Форматы данных отличаются синтаксисом и типами. Форматы общего назначения задают
строки, числа, словари и списки. Они не настолько гибки, но работают
везде. Наоборот, формат для конкретной платформы тесно связан с ней, но непопулярен в других языках.

Некоторые форматы поддерживают теги. С помощью тегов из скаляров получают более
сложные типы, например даты. Теги опасны тем, что когда их много, конфигурация
превращается в код.

Clojure предлагает несколько библиотек для конфигурации приложения. Они
различаются замыслом и архитектурой, и каждый разработчик найдёт то, что ему по
душе. Нет точного ответа на вопрос, какой формат или библиотека лучше. Выбирайте
то, что предельно дёшево решит вашу задачу.
