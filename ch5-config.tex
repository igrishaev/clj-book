\chapter{Конфигурация}

\index{конфигурация}

\label{chapter-config}

\begin{teaser}
В этой главе мы рассмотрим, как сделать проект на Clojure удобным в
настройке. Разберём основы конфигурации: форматы файлов, переменные среды,
библиотеки, их достоинства и недостатки.
\end{teaser}

\section{Постановка проблемы}

В материалах по Clojure встречаются примеры:

\begin{clojure}
(def server
  (jetty/run-jetty app {:port 8080}))

(def db {:dbtype   "postgres"
         :dbname   "test"
         :user     "ivan"
         :password "test"})
\end{clojure}

Это сервер на порту 8080 и параметры подключения к базе. Польза примеров в том,
что их можно скопировать в REPL и оценить результат: открыть страницу в браузере
или выполнить запрос.

На практике код пишут так, чтобы в нём не было конкретных чисел и строк. С точки
зрения проекта плохо, что серверу явно задали порт. Это подойдёт для
документации и примеров, но не для боевого запуска.

Порт 8080 и другие комбинации нулей и восьмёрок популярны
у~программистов. Велики шансы, что порт занят другим сервером. Это случается,
когда запускают не отдельный сервис, а их связку на время разработки или тестов.

Код, написанный программистом, проходит несколько стадий. В~разных фирмах набор
отличается, но в целом это разработка, тестирование, предварительный и боевой
запуск.

\label{hardcode}

На каждой стадии приложение запускают бок о бок с другими
проектами. Предположение, что порт 8080 свободен в любой момент,~--- это
утопия. На жаргоне разработчиков ситуацию называют <<хардкод>> \eng{hardcode}
или <<прибито гвоздями>>. Когда в коде <<прибитые>> значения, это вносит
проблемы в его цикл. Из-за конфликта портов вы не сможете запустить два сервиса
одновременно.

Приложение не должно знать порт сервера~--- информация об этом приходит извне. В
простом случае это файл настроек. Программа читает из него порт и запускает
сервер именно так, как это нужно на~конкретной машине.

\index{менеджер конфигураций}

В более сложных сценариях файл составляет не человек, а специальная
программа~--- менеджер конфигураций. Менеджер хранит информацию о топологии
сети, адреса машин, параметры доступа к~базам. По запросу он выдаёт файл для
определённой машины или сегмента сети.

Процесс, когда приложению сообщают параметры, а оно принимает их, называется
конфигурацией. Это интересный и важный этап в~разработке программ. Когда он
устроен верно, проект легко проходит по всем стадиям производства.

\section{Семантика}

Цель конфигурации в том, чтобы управлять программой без изменений в коде. К ней
приходят с ростом кодовой базы и инфраструктуры. Если у вас мелкий скрипт на
Python, нет ничего зазорного в том, чтобы открыть его в блокноте и поменять
константу. На предприятиях такие скрипты работают годами.

Чем сложнее инфраструктура фирмы, тем больше в ней ограничений. Современный
подход сводит на нет спонтанные изменения в~проекте. Нельзя делать пуш
напрямую в мастер; запрещён \code{merge}, пока вашу работу не одобрят
двое коллег; приложение не попадёт на~сервер, пока не пройдут тесты.

Это приводит к тому, что малейшее изменение в коде займёт час, чтобы попасть в
бой. Правка конфигурации дешевле, чем выпуск новой версии продукта. Из этого
следует правило: если можно вынести что-то в конфигурацию, сделайте это сейчас.

\index{фичи}
\index{feature flags}

В крупных фирмах практикуют то, что называют feature flag. Это логическое поле,
которое включает целый пласт логики в приложении. Например, новый интерфейс,
систему обработки заявок, улучшенный чат. Обновления проверяют до выпуска, но
всегда остаётся риск, что в бою \emph{что-то пойдёт не так}. В таком случае флаг
меняют на ложь и~перезапускают сервер. Это не только сэкономит время, но и
сохранит репутацию фирмы.

\label{feature-flags}

\section{Цикл конфигурации}

Чем лучше устроено приложение, тем больше его частей опирается на параметры.
Поэтому первое, что делает программа при запуске~--- ищет конфигурацию. Её
обработка~--- не монолитная задача, а набор шагов. Перечислим наиболее важные из
них.

На первом этапе программа \textbf{читает конфигурацию}. Чаще всего она находится
в файле в формате JSON, YAML и других. Приложение содержит код, чтобы разобрать
формат и получить данные. Мы рассмотрим плюсы и минусы известных форматов ниже.

Другой способ сообщить программе настройки~--- поместить их в переменные среды.
Переменные~--- часть операционной системы, глобальный словарь в памяти. Каждое
приложение наследует его при запуске. Языки и фреймворки предлагают функции,
чтобы считать переменные в строки и словари.

Файлы и переменные среды дополняют друг друга. Например, приложение читает
данные из файла, но путь к нему ищет в переменных среды.

Возможна и обратная схема: приложение читает параметры из файла, а~секретные
данные~--- из переменных. Так поступают, чтобы другие программы, в том числе
шпионские, не смогли прочитать из файлов пароли и ключи доступа.

\index{теги}

Продвинутые конфигурации используют теги. Перед значением в файле ставят тег~---
короткую строку, которая означает, что значение нужно обработать особо.
Например, в строке \code{:password \#env DB\_PASSWORD} тег \code{\#env} говорит о
том, что в \code{:password} окажется значение одноимённой переменной.

Первый этап завершается тем, что мы получили данные. Неважно, был ли это файл,
переменные среды или что-то другое. Приложение переходит ко второму этапу~---
\textbf{выводу типов}.

\index{вывод!типов}

JSON и YAML выделяют базовые типы: строки, числа, булево и~\code{null}. Легко
заметить, что среди них нет даты. С помощью дат задают промоакции или события,
связанные с календарём. В файлах даты указывают либо строкой в формате ISO, либо
числом секунд c~1~января~1970 года (\footurl{эпоха UNIX}{https://en.wikipedia.org/wiki/Unix\_time}[Unix time]).
Специальный код приводит такую запись к типу даты, принятому в языке.

Вывод типов применяют и для коллекций. Иногда словарей и~массивов не хватает для
комфортной работы. Если нужно указать допустимые значения чего-либо, логично
сделать это множеством, потому что оно отсекает дубли и предлагает быструю
проверку на вхождение.

Сложные типы удобнее описать скаляром (числом или строкой) и позже вывести
их. Например, строка \code{"http://test.com"} станет экземпляром класса
\code{java.net.URL}, а цепочка из 36 символов и дефисов~--- объектом
\code{java.util.UUID}.

Переменные среды не настолько гибки, как современные форматы. Если JSON выделяет
скаляры и коллекции, то переменные несут только текст. Вывод типов для них не
просто желателен, а необходим. Нельзя передать порт в виде строки туда, где
ожидают число.

\index{валидация}

После вывода типов приступают к \textbf{валидации данных}. В главе про Spec мы
выяснили, что тип не обещает верное значение \page{type-and-pred}. Проверка
нужна, чтобы в конфигурации нельзя было указать порт 0 или -1.

Из той же главы мы помним, что иногда значения верны по отдельности, но не могут
быть в паре. Пусть в конфигурации задан период акции. Это массив из двух дат,
начало и завершение. Легко перепутать даты местами, и любая проверка на интервал
вернёт ложь.

После валидации переходят к последней стадии. Приложение решает, где
\textbf{хранить конфигурацию}. Это может быть глобальная переменная или
компонент системы. Другие части программы читают параметры уже оттуда, а не из
файла.

\section{Ошибки конфигурации}

\index{ошибки!конфигурации}

На каждом этапе может возникнуть ошибка: не найден файл, нарушения в синтаксисе,
неверное поле. В этом случае программа выводит сообщение и завершается.  Текст
должен чётко отвечать на вопрос, что случилось. Часто программисты держат в
голове только положительный путь и забывают об ошибках. При запуске их программ
виден стек-трейс, который трудно понять.

Если ошибка случилась на этапе проверки конфигурации, объясните, какое поле тому
виной. В главе про Spec мы рассмотрели, как улучшить отчёт
спеки \page{spec-messages}.  Это требует усилий, но окупается со временем.

\index{DevOps}
\index{отчёт!explain}

В IT-индустрии одни сотрудники пишут код, а другие управляют им. Ваш
коллега-DevOps не знает Clojure и не поймёт сырой \code{explain}. Рано или
поздно он попросит доработать сообщение конфигурации. Сделайте это заранее из
уважения к коллегам.

Если с конфигурацией что-то не так, программа не должна работать в надежде, что
всё обойдется. Бывает, один из параметров задан неверно, но в данный момент
программа не обращается к нему. Избегайте этого: ошибка появится в самый
неподходящий момент.

\index{каналы!stderr}

Когда один из шагов конфигурации не сработал, программа завершается с кодом,
отличным от нуля. Сообщение пишут в канал \code{stderr}, чтобы подчеркнуть
внештатную ситуацию. Продвинутые терминалы печатают текст из \code{stderr}
красным цветом, чтобы привлечь к себе внимание.

\section{Загрузчик конфигурации}

\index{конфигурация!загрузка}

Чтобы закрепить теорию, напишем свою систему конфигурации. Это отдельный модуль
примерно на сто строк. Прежде чем садиться за редактор, обдумаем основные
положения.

Будем хранить конфигурацию в JSON-файле. Считаем, что фирма недавно перешла на
Clojure и у DevOps уже написаны скрипты на Python для управления настройками. В
данном случае нам бы подошёл формат EDN, но он усложнит работу коллегам.

\index{даты}

Путь к файлу задают в переменной среды \code{CONFIG\_PATH}. От файла мы ожидаем
порт сервера, параметры базы данных и диапазон дат для промоакции. Даты должны
стать объектами \code{java.util.Date}. Дата начала строго меньше конца.

Готовый словарь запишем в глобальную переменную \code{CONFIG}. Если на одном
из шагов случилась ошибка, покажем сообщение и завершим программу.

Начнём со вспомогательной функции \code{exit}. Она принимает код завершения,
текст и параметры форматирования. Если код равен нулю, пишем сообщение в
\code{stdout}, иначе~--- в \code{stderr}.

\index{функции!exit}

\ifnarrow

\begin{clojure}
(defn exit
  [code template & args]
  (let [out (if (zero? code)
              *out*
              *err*)]
    (binding [*out* out]
      (println (apply format
        template args))))
  (System/exit code))
\end{clojure}

\else

\begin{clojure}
(defn exit
  [code template & args]
  (let [out (if (zero? code) *out* *err*)]
    (binding [*out* out]
      (println (apply format template args))))
  (System/exit code))
\end{clojure}

\fi

Переходим к загрузчику. Это набор шагов, каждый из которых принимает результат
предыдущего. Получилось четыре этапа: найти путь к файлу, прочитать файл,
обработать данные, записать их в глобальную переменную. Вывод типов и валидацию
мы совместили в \code{coerce-config}, поскольку технически это вызов
\code{s/conform}.

\index{функции!load-config"!}

\begin{clojure}
(defn load-config!
  []
  (-> (get-config-path)
      (read-config-file)
      (coerce-config)
      (set-config!)))
\end{clojure}

Теперь опишем каждый шаг. Функция \texttt{get\-/config\-/path} читает переменную
среды и проверяет, есть ли такой файл на диске. Если всё в~порядке, функция
вернёт путь к файлу, а иначе вызовет \code{exit}:

\index{файлы}

\pagebreaklarge

\ifnarrow

\begin{clojure}
(import 'java.io.File)

(defn get-config-path []
  (if-let [filepath (System/getenv
                      "CONFIG_PATH")]
    (if (-> filepath (new File) .exists)
      filepath
      (exit 1 "File %s does not exist"
        filepath))
    (exit 1 "File path is not set")))
\end{clojure}

\else

\begin{clojure}
(import 'java.io.File)

(defn get-config-path []
  (if-let [filepath (System/getenv "CONFIG_PATH")]
    (if (-> filepath (new File) .exists)
      filepath
      (exit 1 "File %s does not exist" filepath))
    (exit 1 "File path is not set")))
\end{clojure}

\fi

Шаг \code{read-config-file} читает файл по его пути. Для разбора JSON служит
библиотека Cheshire. Её функция \code{parse-string} вернёт данные из строки
документа.

\index{библиотеки!Cheshire}
\index{модули!cheshire.core}

\ifnarrow

\begin{clojure}
(require '[cheshire.core :as json])

(defn read-config-file
  [filepath]
  (try
    (-> filepath
        slurp
        (json/parse-string true))
    (catch Exception e
      (exit 1
        "Malformed config,
                   file: %s, error: %s"
            filepath (ex-message e)))))
\end{clojure}

\else

\begin{clojure}
(require '[cheshire.core :as json])

(defn read-config-file
  [filepath]
  (try
    (-> filepath slurp (json/parse-string true))
    (catch Exception e
      (exit 1 "Malformed config, file: %s, error: %s"
            filepath (ex-message e)))))
\end{clojure}

\fi

\index{валидация}
\index{вывод!типов}
\index{идентичность}
\index{библиотеки!Expound}

Вывод типов и проверка~--- самые важные этапы. Нельзя допустить, чтобы
приложение получило неверные параметры. Шаг \code{coerce-config} пропускает
данные из файла через \code{s/conform}. Вызов опасен исключением, поэтому
обернём его в \code{pcall}~--- безопасный вызов, который вернёт ошибку и
результат \page{pcall}.

Если произошло исключение, напечатаем его текст и завершим программу. То же
самое делаем для результата \code{::s/invalid} с той разницей, что сообщение
получим библиотекой Expound \page{expound}. Мы вынуждены учитывать оба случая,
потому что сбой и неверный результат~--- это разные события.

\ifnarrow

\begin{clojure}
(require '[clojure.spec.alpha :as s])
(require '[expound.alpha :as expound])

(defn coerce-config [config]
  (let [[e result] (pcall s/conform
                     ::config config)]
    (cond
      (some? e)
      (exit 1 "Wrong config values: %s"
        (ex-message e))

      (s/invalid? result)
      (let [report (expound/expound-str
                     ::config config)]
        (exit 1
          "Invalid config values: %s %s"
          \newline report))

      :else result)))
\end{clojure}

\else

\begin{clojure}
(require '[clojure.spec.alpha :as s])
(require '[expound.alpha :as expound])
\end{clojure}

\pagebreaklarge

\begin{clojure}
(defn coerce-config [config]
  (let [[e result] (pcall s/conform ::config config)]
    (cond
      (some? e)
      (exit 1 "Wrong config values: %s" (ex-message e))

      (s/invalid? result)
      (let [report (expound/expound-str ::config config)]
        (exit 1 "Invalid config values: %s %s"
              \newline report))

      :else result)))
\end{clojure}

\fi

Не хватает спеки \code{::config}. Откроем конфигурацию и изучим её структуру:

\index{форматы!JSON}

\begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
\end{json}

\noindent
Опишем спеку сверху вниз. Это словарь с ключами:

\ifnarrow

\begin{clojure}
(s/def ::config
  (s/keys :req-un [::server_port
                   ::db ::event]))
\end{clojure}

\else

\begin{clojure}
(s/def ::config
  (s/keys :req-un [::server_port ::db ::event]))
\end{clojure}

\fi

\index{даты!диапазон}

Порт сервера~--- комбинация двух предикатов: число и вхождение в диапазон.
Проверка на число нужна, чтобы во второй предикат не попали \code{nil} и
строка. Это вызовет исключение там, где его не ждали.

\begin{clojure}
(s/def ::server_port
  (s/and int? #(<= 1024 % 65535)))
\end{clojure}

\index{spec!int-in}

Проверка на число и диапазон встречается часто, и Spec предлагает макрос
\code{s/int-in} на этот случай. Его правая граница исключительного типа, то есть
не входит в интервал. На языке математики мы бы написали \code{[1024, 65535)}.
Чтобы включить правое значение в проверку, увеличьте его на единицу.

\begin{clojure}
(s/def ::server_port
  (s/int-in 1024 (inc 65535)))
\end{clojure}

\index{spec!::ne-string}

Теперь опишем подключение к базе данных. С ним не будем проблем, потому что все
его поля~--- строки. Для большей строгости используем \code{::ne-string} \page{ne-string},
чтобы отсечь пустые строки. Тип базы логично задать множеством, в данном
случае с одним элементом <<mysql>>. Так мы исключим посторонние значения.

\begin{clojure}
(s/def :db/dbtype   #{"mysql"})
(s/def :db/dbname   ::ne-string)
(s/def :db/user     ::ne-string)
(s/def :db/password ::ne-string)

(s/def ::db
  (s/keys :req-un [:db/dbtype
                   :db/dbname
                   :db/user
                   :db/password]))
\end{clojure}

Наиболее интересно \code{event}. Оно состоит из кортежа дат и проверки на
интервал:

\begin{clojure}
(s/def ::event
  (s/and (s/tuple ::->date ::->date)
         ::date-range))
\end{clojure}

\index{даты!разбор}
\index{модули!clojure.instant}
\index{функции!read-instant-date}
\index{spec!::ne-string}
\index{spec!::\arr{}date}

Спека \code{s/tuple} проверяет, что в коллекции именно столько элементов. Пустой
вектор, а также с одной или тремя датами не пройдут проверку.

Спека \code{::->date} выводит дату из строки. Чтобы не парсить её вручную,
возьмём функцию \code{read-instant-date} из пакета \code{clojure.instant}.
Функция лояльна к формату и~читает неполные даты, например только год.  Обернём
её в \code{s/conformer}. Впереди ставим \code{::ne-string}, чтобы отсечь
\code{nil} и пустые строки.

\index{функции!read-instant-date}

\ifnarrow

\begin{clojure}
(require '[clojure.instant :as inst])

(s/def ::->date
  (s/and ::ne-string
    (s/conformer read-instant-date)))
\end{clojure}

\else

\begin{clojure}
(require '[clojure.instant :as inst])

(s/def ::->date
  (s/and ::ne-string (s/conformer read-instant-date)))
\end{clojure}

\fi

\index{классы!Date}
\index{clojure.core!compare}

Опишем проверку диапазона. Функция принимает вектор двух объектов \code{Date}
и~сравнивает их. Даты нельзя сравнить знаками <<больше>> или <<меньше>>. Для
этого служит функция \code{compare}, которая вернёт -1, 0 и 1 для случаев
<<меньше>>, <<равно>> и <<больше>>. Нас интересует первый случай, когда число
отрицательное.

\begin{clojure}
(s/def ::date-range
  (fn [[date1 date2]]
    (neg? (compare date1 date2))))
\end{clojure}

Последний шаг \code{set-config!} установит словарь конфигурации в глобальную
переменную \code{CONFIG}. Мы выбрали имя в верхнем регистре, чтобы подчеркнуть
её важность и не затенить её локальной переменной \code{config}. Чтобы изменить
переменную, используем \code{alter-var-root}.

\index{clojure.core!alter-var-root}

\ifnarrow

\begin{clojure}
(def CONFIG nil)

(defn set-config!
  [config]
  (alter-var-root (var CONFIG)
    (constantly config)))
\end{clojure}

\else

\begin{clojure}
(def CONFIG nil)

(defn set-config!
  [config]
  (alter-var-root (var CONFIG) (constantly config)))
\end{clojure}

\fi

На старте программы выполните \code{(load\-/config!)}, и в переменной появится
конфигурация. Другие модули импортируют \code{CONFIG} и читают нужные им
ключи. Вот как запустить сервер или выполнить запрос к базе с учётом
конфигурации:

\index{JDBC!query}

\ifnarrow

\begin{clojure}
(require
  '[project.config :refer [CONFIG]])

(jetty/run-jetty app
  {:port (:server_port CONFIG)
   :join? false})

(jdbc/query (:db CONFIG)
  "select * from users")
\end{clojure}

\else

\begin{clojure}
(require '[project.config :refer [CONFIG]])

(jetty/run-jetty app {:port (:server_port CONFIG)
                      :join? false})

(jdbc/query (:db CONFIG) "select * from users")
\end{clojure}

\fi

\subsection{Работа над ошибками}

Мы написали загрузчик конфигурации. Он удобен в поддержке: каждый шаг~--- это
функция, которую легко доработать. Код не претендует на промышленное решение, но
подойдёт для небольших проектов.

Преимущество загрузчика в том, что конфигурацию можно считать заново в~любой
момент. Это удобно при разработке: измените файл и выполните
\code{(load-config!)}. В~переменной \code{CONFIG} появится новая конфигурация.

\index{функции!exit}

В коде есть недостатки, и один из них~--- привязка к функции \code{exit},
которая завершает JVM. В боевом запуске это верный подход: нельзя продолжать,
если в параметрах ошибка. Но в разработке от завершения больше проблем: любая
ошибка обрывает REPL, и нужно включать его заново.

Завершение JVM~--- слишком радикальное действие. Ошибка и~реакция на неё должны
быть разделены. Наивный способ в том, чтобы вызвать \code{load-config!} в рамках
подмены \code{exit} на функцию, которая только бросит исключение, но не завершит
JVM. Назовём её \code{fake-exit}:

\ifnarrow

\begin{clojure}
(defn fake-exit
  [_ template & args]
  (let [msg (apply format template args)]
    (throw (new Exception msg))))

(defn load-config-repl! []
  (with-redefs [exit fake-exit]
    (load-config!)))
\end{clojure}

\else

\begin{clojure}
(defn fake-exit
  [_ template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(defn load-config-repl! []
  (with-redefs [exit fake-exit]
    (load-config!)))
\end{clojure}

\fi

\index{die-fn}
\index{функция смерти}
\index{REPL}

Более удачное решение~--- передать в \texttt{load-con\-fig!} дополнительные
параметры. Назовём один из них \code{:die-fn}, <<функция смерти>>, которая
принимает исключение. В боевом запуске она завершает JVM, а в~разработке пишет
сообщение в REPL. Доработайте загрузчик так, чтобы он поддерживал параметр
\code{:die-fn}. Продумайте поведение по умолчанию, если он не задан.

Второе замечание касается спеки базы данных. Наш загрузчик выводит типы с
помощью \code{s/conform}. В главе про Spec мы рассмотрели случай, когда
\code{s/conform} добавляет логические теги и меняет структуру
данных \page{jdbc-conform-warning}. Если заменить спеку \code{::db} на
\code{::jdbc/db-spec} из модуля \texttt{clojure.java.jdbc.spec}, получим тот
самый случай. Чтобы не искажать данные, мы задали свою версию \code{::db} без
макросов \code{s/or}.

\index{теги}

По-другому типы выводят с помощью тегов. Эту технику мы обсудим в следующих
разделах главы.

\section{Подробнее о переменных среды}

\index{environment}
\index{переменные!среды}

Наш загрузчик читает данные из файла, а из переменных среды берёт лишь малую
часть~--- путь к файлу. Изменим загрузчик: пусть он читает данные из переменных
среды и не нуждается в файлах. Чтобы понять преимущества этого подхода,
поговорим о переменных в отрыве от языка.

Переменные среды называют ENV или <<энвы>> (англ.~envi\-ron\-ment~--- <<окружающая
среда>>). Это фундаментальное свойство операционной системы. Представьте
переменные как глобальный словарь, который наполняется во время запуска
компьютера. В словаре основные параметры системы: локаль, домашняя директория,
список путей, где система ищет программы, и многое другое.

\index{утилиты!printenv}

Чтобы увидеть текущие переменные, запустите в терминале команду \code{env} или
\code{printenv}. На экране появится пары \code{ИМЯ=значение}. Имена переменных в
верхнем регистре, чтобы подчеркнуть их приоритет и выделить на общем
фоне. Большинство систем различают регистр, поэтому \code{home}
и~\code{HOME}~--- это разные переменные. Пробелы и дефисы недопустимы; лексемы
отделяют подчёркиванием. Фрагмент \code{printenv}:

\begin{bash}
USER=ivan
PWD=/Users/ivan
SHELL=/bin/zsh
TERM_PROGRAM=iTerm.app
\end{bash}

Каждый процесс получает копию этого словаря. Процесс может добавить или удалить
переменную, но изменения видны только ему и~потомкам. Потомок процесса наследует
переменные родителя.

\subsection{Локальные и глобальные переменные}

\index{шелл}
\index{переменные!среды}

Различают переменные среды и шелла, они же глобальные и локальные переменные. Их
часто путают новички. Выполните в терминале команду:

\begin{bash}
$ FOO=42
\end{bash}

Вы задали локальную переменную шелла (командной оболочки). Чтобы сослаться на
значение по имени (<<дерефнуть>>), поставьте перед ней доллар. Пример напечатает
42:

\begin{bash}
$ echo $FOO
42
\end{bash}

\index{переменные!шелла}

Если выполнить \code{printenv}, мы не увидим \code{FOO} в выводе. Команда
\code{ИМЯ=значение} задаёт переменную шелла, а не среды. Такие переменные видны
только шеллу и не наследуются потомками. Проверим это: из текущего шелла
запустим новый и повторим печать.

\begin{bash}
$ sh
$ echo $FOO
\end{bash}

Получим пустую строку, потому что у потомка нет такой переменной. Выполните
\code{exit}, чтобы вернуться в родительский шелл. Он по-прежнему хранит
переменную \code{FOO}.

\index{export}
\index{переменные!экспорт}
\index{переменные!шелла}

Команда \code{export} помещает переменную в среду. Заданная таким образом,
переменная видна \code{printenv}:

\begin{bash}
$ export FOO=42
$ printenv | grep FOO
FOO=42
\end{bash}

\noindent
и процессам-потомкам:

\begin{bash}
$ sh
$ echo $FOO
42
\end{bash}

Иногда нужно запустить процесс с переменной, но так, чтобы не повлиять на
текущее состояние шелла. Тогда выражение \code{ИМЯ=значение} ставят перед
основной командой:

\begin{bash}
$ BAR=99 printenv | grep BAR
BAR=99
\end{bash}

\code{Printenv} порождает новый процесс, которому доступна переменная
\code{BAR}. Если снова напечатать \code{\$BAR}, получим пустую строку.

\index{базы данных!PostgreSQL}

Многие программы читают параметры из переменных среды. Клиент к~базе данных
PostgreSQL различает два десятка переменных: \code{PGHOST}, \texttt{PGDATABASE},
\code{PGUSER} и другие. У переменных среды выше приоритет, чем у параметров
\code{--host}, \code{--user} и аналогов. Если в текущем шелле выполнить:

\ifnarrow

\begin{bash}
$ export PGHOST=host.com \
         PGDATABASE=project
\end{bash}

\else

\begin{bash}
$ export PGHOST=host.com PGDATABASE=project
\end{bash}

\fi

\noindent
, то каждая утилита PostgreSQL обратится к заданному серверу и базе. Это удобно
для серии команд: не придётся каждый раз указывать ключи \code{--host},
\code{-d} и другие.

Обратите внимание на префикс \code{PG}. Он нужен, чтобы не затенить чужую
переменную \code{HOST}. В среде нет пространств имён, поэтому префикс~---
единственный способ отделить ваши переменные от чужих.

\section{Конфигурация в среде}

Каждый язык предлагает метод или функцию, чтобы читать переменные среды. Это
значит, ими можно задать конфигурацию. Разберём плюсы и минусы такого подхода.

Поскольку окружение находится в памяти, приложение не обращается к диску при их
чтении. Дело не в том, что память быстрее диска: человек не отличит сотую долю
секунды от тысячной. Приложение, которое не зависит от файлов, более автономно и
потому удобней в~поддержке.

Иногда файл конфигурации оказался в другой папке, и приложение не может его
найти. Или, что хуже, программа сканирует несколько путей и запускается не с тем
файлом, что мы ожидали. Это замедляет работу и вносит путаницу.

\label{password-note}

\index{безопасность!конфигурации}

Хранить пароли и ключи в переменных безопаснее, чем в файлах. В случае с файлами
их могут прочесть другие программы, в том числе вредоносные. По ошибке файл
может попасть в репозиторий и остаться в истории. Существуют скрипты, которые
ищут в открытых репозиториях ключи к облачным платформам и кошелькам (и порой
находят, к сожалению).

Даже если файлом владеет другой пользователь, он может быть доступен для чтения
остальным. Переменные среды эфемерны: они живут только памяти операционной
системы. Один пользователь не может прочесть переменные другого из-за
ограничений на уровне операционной системы.

\index{контейнеры}
\index{виртуализация}

Индустрия переходит от файлов к виртуализации. Если раньше мы копировали файлы
по FTP, то сегодня приложение запускают из образов. Это архив, в который
упакованы код и его окружение. В отличие от настоящего архива, образ нельзя
изменить. Чтобы обновить файл в~образе, нужно собрать его заново, что усложняет
процесс.

\index{Docker}

Однако виртуализация лояльна к переменным среды. Их указывают при запуске образа
в параметрах. Один и тот же образ используют с разными переменными; новая сборка
не требуется. Чем больше опций можно задать переменными, тем удобней образ в
работе. Ниже сервер PostgreSQL включается с готовой базой и пользователем:

\begin{bash}
$ docker run \
  -e POSTGRES_DB=book \
  -e POSTGRES_USER=ivan \
  -e POSTGRES_PASSWORD=**** \
  -d postgres
\end{bash}

\index{сайты!12factor.net}

Принцип <<конфигурация в среде>> описан в~\footurl{The Twelve-Factor App}{https://12factor.net}[12-Factor App].
Это свод правил для разработки надёжных приложений. Его третий пункт посвящён конфигурации.
Автор упоминает те же плюсы переменных, что мы рассмотрели: независимость от файлов,
безопасность, поддержка на всех платформах.

\section{Недостатки среды}

\index{декларативность}

Переменные не поддерживают типы: любое значение~--- текст. Вывод типов остаётся
на ваше усмотрение. Делайте это декларативно, а не вручную. Неудачный пример на
Python:

\index{языки!Python}

\begin{python}
db_port = int(os.environ["DB_PORT"])
\end{python}

Когда переменных больше двух, подобный разбор становится уродливым. Задайте
словарь, где ключ~--- имя переменной, а значение~--- функция вывода. Специальный
код обходит словарь и наполняет результат. Для краткости опустим перехват
ошибок:

\begin{python}
import os
env_mapping = {"DB_PORT": int}

result = {}
for (env, fn) in env_mapping.iteritems():
    result[env] = fn(os.environ[env])
\end{python}

Подход справедлив и для других языков: меньше кода, больше декларативной
части. В Clojure для этого служит спека.

Переменные среды не работают с иерархией. Это плоский набор ключей и значений,
что не всегда ложится на конфигурацию. Чем больше в ней параметров, тем чаще их
группируют по смыслу. Предположим, подключение к базе включает десять
параметров. Чтобы не ставить перед каждым префикс, их выносят в дочерний
словарь.

\index{вложенность}
\index{коллекции!вложенность}

\noindent
\ifnarrow
\begin{tabular}{ @{}p{3.9cm} @{}p{3.7cm} }
\else
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }
\fi

\begin{clojure}
;; so-so
{:db-name "book"
 :db-user "ivan"
 :db-pass "****"}
\end{clojure}

&

\begin{clojure}
;; better
{:db {:name "book"
      :user "ivan"
      :pass "****"}}
\end{clojure}

\end{tabular}

В разных системах вложенные переменные читают по-разному. Например, одинарное
подчёркивание разделяет лексемы, но не меняет структуру. Двойное подчёркивание
означает вложенность:

\noindent
\ifnarrow
\begin{tabular}{ @{}p{3.9cm} @{}p{3.7cm} }
\else
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }
\fi

\begin{clojure}
DB_NAME=book
DB_PASS=pass

{:db-name "book"
 :db-pass "pass"}
\end{clojure}

&

\begin{clojure}
DB__NAME=book
DB__PASS=pass

{:db {:name "book"
      :pass "pass"}}
\end{clojure}

\end{tabular}

\index{коллекции!массив}

Массив записывают в квадратных скобках или через запятую. При разборе массива
возникает риск ложного разбиения. Это случается, когда запятая или скобка
относится к слову, а не к синтаксису.

\index{форматы!JSON}
\index{форматы!YAML}

Если форматы JSON и YAML задают чёткий стандарт, как описывать коллекции, то для
переменных среды нет единого соглашения. Ситуация ухудшается, когда ожидают
параметр большой вложенности, например список словарей. Переменные среды не
справляются с подобной структурой.

В разработке проявляется ещё один недостаток переменных~--- в~некоторых системах
они доступны только для чтения. Это верно идеологически, но вынуждает
перезагружать REPL на каждое изменение конфигурации. В случае с файлом
достаточно изменить его и~прочитать заново.

\subsection{Env-файлы}

\index{файлы!переменных среды}

Когда переменных много, вводить их вручную через \code{export}
утомительно. Переменные выносят в файл, который называют
\emph{env}-кон\-фи\-гу\-ра\-цией. Технически это шелл-скрипт, но чем меньше в
нём скриптовых возможностей, тем лучше. В идеале файл содержит только пары
\code{ИМЯ=значение} по одной на каждую строку. Назовём его просто \code{ENV} без
расширения.

\begin{bash}
DB_NAME=book
DB_USER=ivan
DB_PASS=****
\end{bash}

Чтобы считать переменные в шелл, вызывают \code{source <file>}. Это команда
\code{bash}, которая выполнит скрипт в текущем сеансе. Команду используют так
часто, что для краткости её заменяют точкой: \code{. <file>}. Скрипт добавит
переменные в шелл, и вы увидите их после \code{source}. Это важное отличие от
команды \code{bash <file>}: последняя выполнит скрипт в новом шелле, и вы не
увидите изменений в текущем.

\begin{bash}
$ source ENV
$ echo $DB_NAME
book
\end{bash}

Если запустить приложение из текущего шелла, оно всё ещё не получит новые
переменные. Вспомним, что выражение \code{VAR=value} задаёт локальную
переменную. \code{DB\_NAME} и другие не попадут в окружение, и приложение не
унаследует их. Проверим это с помощью \code{printenv}~--- команда \code{grep}
ниже ничего не найдёт.

\index{утилиты!printenv}

\begin{bash}
$ source ENV
$ printenv | grep DB
# exit 1
\end{bash}

Проблему решают двумя способами. Первый~--- открыть файл и~расставить перед
каждой парой \code{export}. Тогда \code{source} этого файла добавит переменные в
окружение:

\begin{bash}
$ cat ENV
export DB_NAME=book
export DB_USER=ivan
export DB_PASS=****

$ source ENV
$ printenv | grep DB
DB_NAME=book
DB_USER=ivan
DB_PASS=****
\end{bash}

Недостаток в том, что в файле появилась логика скрипта. Если не поставить
\code{export} перед переменной, она не попадёт в приложение.

Второй способ основан на параметре \code{-a} (\textbf{a}ll\-ex\-port) текущего
шелла. Когда он установлен, локальная переменная автоматически переходит в
окружение. Перед тем, как читать переменные из файла, флаг возводят в истину, а
затем снова в ложь.

\begin{bash}
$ set -a
$ source ENV
$ printenv | grep DB
# prints all the vars
$ set +a
\end{bash}

Выражение \code{set} слегка обманчиво: параметр с минусом включает параметр, а с
плюсом~--- отключает. Это исключение, которое придётся запомнить.

Если считать переменную, которая уже в окружении, она заменит прежнее
значение. Так появляются файлы переопределений. Если нужны особые настройки для
тестов, не обязательно копировать весь файл. Создайте файл с теми полями, что
нужно заменить и выполните его после главного.

Пусть тестовые настройки отличаются только именем базы. Файл \code{ENV} содержит
основные параметры, а в \code{ENV\_TEST} поместим новое значение
\code{DB\_NAME=test}. Прочтём оба файла и проверим, что получилось:

\begin{bash}
$ set -a
$ source ENV
$ source ENV_TEST
$ set +a

$ echo $DB_NAME
test
\end{bash}

Читатель заметит, что ENV-файлы противоречивы. Мы сказали, что переменные
снимают зависимость от файлов, но в итоге поместили их в файл. Какой в этом
смысл?

\index{DevOps}

Разница между обычными и ENV-файлами в том, кто их читает. В~первом случае это
приложение, а во втором~--- операционная система. Если файл находится в строго
заданной директории, то переменные среды доступны отовсюду. Мы избавим
приложение от кода, который ищет и читает файл. Заодно облегчим работу коллегам
DevOps: они задают переменные по-разному в зависимости от инструмента (шелл,
Docker, Kubernetes). Так среда становится единой точкой обмена настройками.

\section{Переменные среды в~Clojure}

\index{классы!System}

Clojure~--- гостевая платформа, поэтому язык не предлагает доступ к системным
ресурсам. В модуле \code{clojure.core} и других нет функции для чтения
переменных среды. Получим их из класса \code{java.lang.System}. Импортировать
класс не нужно: как и в Java, он доступен в любом месте автоматически.

Статический метод \code{getenv} вернёт либо одну переменную по имени, либо
весь словарь, если имя не указали.

\ifnarrow

\begin{clojure}
;; a single variable
(System/getenv "HOME")
"/Users/ivan"

;; all variables (truncated)
(System/getenv)
{"JAVA_ARCH" "x86_64",
 "LANG" "en_US.UTF-8"...}
\end{clojure}

\else

\begin{clojure}
;; a single variable
(System/getenv "HOME")
"/Users/ivan"

;; all variables (truncated)
(System/getenv)
{"JAVA_ARCH" "x86_64", "LANG" "en_US.UTF-8"...}
\end{clojure}

\fi

Во втором случае мы получили экземпляр \texttt{UnmodifiableMap}. Это
неизменяемая версия \code{Map}, поэтому переменные нельзя изменить после запуска
JVM.

Чтобы облегчить работу со словарём, приведём его к типу, принятому в
Clojure. Заодно исправим ключи: сейчас это строки в верхнем регистре
и~подчёркиваниями. В Clojure пользуются кейвордами и записью kebab-case: нижний
регистр с дефисами.

Напишем функцию для перевода ключа:

\begin{clojure}
(require '[clojure.string :as str])

(defn remap-key [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      keyword))
\end{clojure}

\noindent
и убедимся в её работе:

\begin{clojure}
(remap-key "DB_PORT")
:db-port
\end{clojure}

\index{функции!remap-env}
\index{функции!remap-key}

Функция \code{remap-env} проходит по словарю Java и возвращает его
<<кложурную>> версию с привычными ключами:

\begin{clojure}
(defn remap-env [env]
  (reduce
   (fn [acc [k v]]
     (let [key (remap-key k)]
       (assoc acc key v)))
   {}
   env))
\end{clojure}

Приведём небольшую часть словаря:

\begin{clojure}
(remap-env (System/getenv))

{:home "/Users/ivan"
 :lang "en_US.UTF-8"
 :term "xterm-256color"
 :java-arch "x86_64"
 :term-program "iTerm.app"
 :shell "/bin/zsh"}
\end{clojure}

Когда переменные в словаре, они идут по тому же конвейеру: вывод типов,
валидация спекой. Поскольку все значения~--- строки, спеку нужно доработать, чтобы
она выводила числа из строк. Раньше в этом не было нужды, потому что числа
приходили из JSON в готовом виде. Будет удачной спека, которая учитывает и
число, и строку. Вот как выглядит умный парсер числа:

\begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (cond
       (int? value) value
       (string? value)
       (try (Integer/parseInt value)
            (catch Exception e
              ::s/invalid))
       :else ::s/invalid))))
\end{clojure}

\noindent
С этой спекой можно менять источник данных без изменений в коде.

\subsection{Проблема лишних ключей}

У словаря переменных недостаток~--- много посторонних полей. Приложению не нужно
знать версию терминала или путь к Python. Эти поля вносят шум при печати и
записи в лог. Если спека не прошла проверку, мы увидим лишние данные в
\code{explain}.

\index{clojure.core!select-keys}
\index{ключи!выборка}

На последнем шаге \code{s/conform} нужно выбрать из словаря только полезную
часть. Функция \code{select-keys} вернёт подмножество по списку ключей. Но где
взять ключи? Перечислять их вручную долго, и к~тому же мы дублируем код. Мы уже
указали ключи в спеке \code{::config}, и~делать это второй раз не хочется. С
помощью трюка мы вытащим ключи из спеки.

Функция \code{s/form} принимает ключ спеки и возвращает исходную форму того, что
передали в \code{s/def}. Это список, где каждый элемент~--- примитив или
коллекция примитивов (число, строка, символ и другие). Для спеки \code{::config}
получим форму:

\begin{clojure}
(s/form ::config)

(clojure.spec.alpha/keys
 :req-un [:book.config/server_port
          :book.config/db
          :book.config/event])
\end{clojure}

\index{коллекции!список}

Обратите внимание: это именно список, а не код. Нужные ключи находятся в третьем
элементе после \code{:req-un}. Ст\'{о}ит учесть и другие типы ключей, например
\code{:opt-un}. Напишем универсальную функцию, которая вернёт все ключи из
\code{s/keys}.

Отбросим первый элемент формы~--- символ \code{.../keys}. Останется список, где
нечётный элемент~--- тип ключа, а чётный~--- вектор ключей. Перестроим список
в~словарь и объединим значения. Для ключей с типом \code{-un} отбросим
пространство. Всё вместе даёт нам функцию:

\index{spec!spec\arr{}keys}

\ifnarrow

\begin{clojure}
(defn spec->keys
  [spec-keys]
  (let [form (s/form spec-keys)
        params (apply hash-map
                 (rest form))
        {:keys [req opt req-un opt-un]}
        params
        ->unqualify (comp keyword name)]
    (concat req
            opt
            (map ->unqualify opt-un)
            (map ->unqualify req-un))))
\end{clojure}

\else

\begin{clojure}
(defn spec->keys
  [spec-keys]
  (let [form (s/form spec-keys)
        params (apply hash-map (rest form))
        {:keys [req opt req-un opt-un]} params
        ->unqualify (comp keyword name)]
    (concat req opt
            (map ->unqualify opt-un)
            (map ->unqualify req-un))))
\end{clojure}

\fi

\noindent
Проверим спеку загрузчика. Действительно, получим три ключа:

\begin{clojure}
(spec->keys ::config)
(:server_port :db :event)
\end{clojure}

\noindent
Перепишем чтение переменных в словарь. На последнем шаге мы выбираем только те
ключи, что указаны в спеке.

\begin{clojure}
(defn read-env-vars []
  (let [cfg-keys (spec->keys ::config)]
    (-> (System/getenv)
        (remap-env)
        (select-keys cfg-keys))))
\end{clojure}

Преимущество в том, что мы избежали повторов. Если в \code{::config} появится
новое поле, функция \code{spec->keys} автоматически подхватит его.

\subsection{Загрузчик среды}

Доработаем загрузчик, чтобы он работал с переменными среды. Для этого заменим
первые два шага на \code{read-env-vars}. Теперь программа не зависит от файла
конфигурации.

\begin{clojure}
(defn load-config! []
  (-> (read-env-vars)
      (coerce-config)
      (set-config!)))
\end{clojure}

Сделайте так, чтобы источник данных можно было задать параметром. Например,
\code{:source "/path/to/config.json"} означает: считать файл, а
\code{:source :env}~--- переменные среды.

\index{коллекции!слияние}

Ещё сложнее: как считать оба источника и объединить их? Важен ли порядок и как
его обеспечить? Как объединить словари ассиметрично, то есть когда второй только
замещает поля первого, но не дополняет новыми?

\subsection{Вывод структуры}

\index{структура}

Редко бывает так, что конфигурация~--- плоский словарь. Близкие параметры
помещают во вложенные словари, например отдельно поля сервера и базы
данных. Когда поля разбиты по группам, конфигурацию проще поддерживать. Удачный
пример~--- разбор конфигурации на части с~помощью синтаксиса \code{:keys}:

\begin{clojure}
(let [{:keys [db server ...]} config])
\end{clojure}

\noindent
В этом случае каждый компонент системы принимает одноимённую часть в качестве
мини-конфигурации.

Улучшим загрузчик: научим его читать вложенные переменные. Договоримся, что
двойное подчёркивание означает смену уровня. Поместим в файл \code{ENV\_NEST}
следующие переменные:

\begin{bash}
DB__NAME=book
DB__USER=ivan
DB__PASS=****
HTTP__PORT=8080
HTTP__HOST=api.random.com
\end{bash}

\index{REPL}

\noindent
Прочитаем его и запустим REPL с новой средой:

\begin{bash}
$ set -a
$ source ENV_NEST
$ lein repl
\end{bash}

Изменим разбор окружения. Функция \texttt{remap\-/key\-/nest} принимает ключ-строку и
возвращает вектор составных частей (лексем):

\begin{clojure}
(defn remap-key-nest
  [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      (str/split #"--")
      (->> (mapv keyword))))

(remap-key-nest "DB__PORT")
;; [:db :port]
\end{clojure}

\index{clojure.core!assoc}
\index{clojure.core!assoc-in}
\index{clojure.core!reduce}

Доработаем функцию, которая наполняет словарь переменными. Для каждой переменной
получим вектор лексем. Добавим значение с помощью \code{assoc-in}, что породит
вложенную структуру.

\begin{clojure}
(defn remap-env-nest
  [env]
  (reduce
   (fn [acc [k v]]
     (let [key-path (remap-key-nest k)]
       (assoc-in acc key-path v)))
   {}
   env))
\end{clojure}

Код ниже вернёт параметры, разбитые по группам, как и было задумано. Приведём их
подмножество:

\ifnarrow

\begin{clojure}
(-> (System/getenv)
    (remap-env-nest)
    (select-keys [:db :http]))

{:db {:user "ivan"
      :pass "****"
      :name "book"}
 :http {:port "8080"
        :host "api.random.com"}}
\end{clojure}

\else

\begin{clojure}
(-> (System/getenv)
    (remap-env-nest)
    (select-keys [:db :http]))

{:db {:user "ivan", :pass "****", :name "book"},
 :http {:port "8080", :host "api.random.com"}}
\end{clojure}

\fi

\noindent
Дальше действуем как обычно: пишем спеку, выводим типы из строк и так далее.

Подумайте, как задать в переменной массив. Чем разделить элементы? Когда
возможно ложное разбиение и как его не допустить?

\section{Простой менеджер конфигурации}

\index{менеджер конфигураций}

К этому моменту читатель решит, что конфигурация в файле~--- плохая идея. Однако
не бросайтесь переписывать код на переменные среды. На практике работают с
гибридными моделями, которые сочетают оба подхода. Приложение читает
основные параметры из файла, а пароли и ключи доступа~--- из среды.

\index{утилиты!gettext}
\index{утилиты!envsubst}

Рассмотрим, как подружить файлы и окружение. Наивное решение не потребует писать
код: оно работает на утилитах командной строки. Программа \code{envsubst} из
пакета GNU Gettext предлагает простую шаблонную систему. Чтобы установить
\code{gettext}, выполните в терминале команду:

\begin{bash}
$ <manager> install gettext
\end{bash}

\noindent
, где \code{<manager>}~--- мастер пакетов вашей системы (\code{brew},
\code{apt}, \code{yum} и~другие).

\index{каналы!stdin}
\index{шаблоны}

Текст шаблона приходит из \code{stdin} (стандартного потока), а роль контекста
играют переменные среды. Утилита заменяет в файле выражения \code{\$VAR\_NAME} на
значения одноимённой переменной. Поместим шаблон в файл
\code{config.tpl.json}. Частичка tpl означает template.

\begin{json/lines}
{
    "server_port": $HTTP_PORT,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "$DB_NAME",
        "user":     "$DB_USER",
        "password": "$DB_PASS"
    },
    "event": [
        "$EVENT_START",
        "$EVENT_END"
    ]
}
\end{json/lines}

Обратите внимание, что порт сервера не окружён кавычками, потому что это число
\coderef{2}. В файле \code{ENV\_VARS} укажем переменные:

\begin{bash}
$ cat ENV_VARS
DB_NAME=book
DB_USER=ivan
DB_PASS='secret123'
HTTP_PORT=8080
EVENT_START='2019-07-05T12:00:00'
EVENT_END='2019-07-12T23:59:59'
\end{bash}

\noindent
Прочитаем их и сделаем рендер шаблона:

\pagebreaklarge

\begin{bash}
$ source ENV_VARS
$ cat config.tpl.json | envsubst
\end{bash}

\begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "secret123"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
\end{json}

\noindent
Подстановка прошла успешно. Чтобы записать результат в~файл, добавьте в конец
оператор вывода:

\ifnarrow

\begin{bash}
$ cat config.tpl.json |
    envsubst > config.ready.json
\end{bash}

\else

\begin{bash}
$ cat config.tpl.json | envsubst > config.ready.json
\end{bash}

\fi

Способ с \code{envsubst} на первый взгляд примитивен, но полезен на
практике. Шаблон снимает вопрос о структуре: переменные становятся в нужное
место, и не нужно думать о вложенности.

Иногда приложение требует несколько файлов конфигурации, в~том числе для
инфраструктуры. Один и тот же параметр нужно указать во многих местах, чтобы
программы работали согласованно. Например, порт веб-сервера нужен Nginx для
проксирования. В Sendmail нужно указать тот же адрес почты, что и
в~приложении. Очевидно, должен быть единый источник данных и несколько шаблонов
под каждую из программ. Рендер с помощью \code{envsubst} удачно ложится на эту
модель.

Таким образом, утилита \code{envsubst} становится менеджером конфигураций. Чтобы
автоматизировать процесс, добавьте скрипт, который пробегает по шаблонам и
рендерит их переменными. Решение не тянет на <<энтерпрайзный>> уровень, но
подойдёт для простых проектов.

\section{Чтение среды из конфигурации}

Следующие техники делают так, что приложение читает параметры одновременно из
файла и среды. Разница в том, на каком шаге это происходит.

Предположим, основные параметры записаны в файле, а пароль к~базе приходит из
среды. Договоримся с командой, что в поле \code{:password} в файле записан не
пароль, а имя переменной, например \code{"DB\_PASS"}. Напишем спеку, которая
выводит значение переменной по имени:

\ifnarrow

\begin{clojure}
(s/def ::->env
  (s/conformer
   (fn [varname]
     (or (System/getenv varname)
         ::s/invalid))))
\end{clojure}

\else

\begin{clojure}
(s/def ::->env
  (s/conformer
   (fn [varname]
     (or (System/getenv varname) ::s/invalid))))
\end{clojure}

\fi

Если переменную не задали, вывод вернёт ошибку. Для большего контроля
отбросим пробелы по краям и убедимся, что строка не пустая.

\begin{clojure}
(s/def ::db-password
  (s/and ::->env
         (s/conformer str/trim)
         not-empty))
\end{clojure}

Быстрая проверка: запустим REPL с переменной \code{DB\_PASS} и прочитаем её
спекой:

\begin{bash}
$ DB_PASS='secret123' lein repl

(s/conform ::db-password "DB_PASS")
"secret123"
\end{bash}

Чтобы вынести поле из файла в среду, замените его значение на имя
переменной. Обновите спеку этого поля: добавьте \code{::->env} в начало цепочки
\code{s/and}.

\index{теги!EDN}

Другой способ прочитать переменные из файла~--- расширить его тегами. Тег~---
это короткое слово, которое указывает, что значение за ним читают особым
образом. Форматы YAML и EDN поддерживают теги. Библиотеки для них предлагают
несколько основных тегов. По желанию их набор можно расширить.

\index{даты!разбор}
\index{модули!clojure.edn}

В EDN тег начинается со знака решётки и захватывает следующее за ним
значение. Например, \code{\#inst "2019-07-10"} выводит дату из строки. Тег связан
с функцией одного аргумента, которая находит новое значение из исходного. Чтобы
задать свой тег, в функцию \code{clojure.edn/read-string} передают специальный
словарь. Его ключи~--- символы тегов, значения~--- функции.

\label{tag-env}

Добавим тег \code{\#env}, который вернёт значение переменной по имени. Имя
может быть строкой или символом. Определим функцию:

\ifnarrow

\begin{clojure}
(defn tag-env
  [varname]
  (cond
    (symbol? varname)
    (System/getenv (name varname))
    (string? varname)
    (System/getenv varname)
    :else
    (throw
      (new Exception
        "Wrong variable type"))))
\end{clojure}

\else

\begin{clojure}
(defn tag-env
  [varname]
  (cond
    (symbol? varname)
    (System/getenv (name varname))
    (string? varname)
    (System/getenv varname)
    :else
    (throw (new Exception "Wrong variable type"))))
\end{clojure}

\fi

\noindent
Прочитаем EDN-строку с новым тегом:

\ifnarrow

\begin{clojure}
(require '[clojure.edn :as edn])

(edn/read-string
  {:readers {'env tag-env}}
  "{:db-password #env DB_PASS}")
;; {:db-password "secret123"}
\end{clojure}

\else

\begin{clojure}
(require '[clojure.edn :as edn])

(edn/read-string {:readers {'env tag-env}}
                 "{:db-password #env DB_PASS}")
;; {:db-password "secret123"}
\end{clojure}

\fi

Чтобы не передавать теги каждый раз, подготовим <<заряженную>> функцию
\code{read-config}. Получим её как \code{partial} от \code{edn/read-string}.
Новая функция принимает только строку документа:

\begin{clojure}
(def read-config
  (partial edn/read-string
           {:readers {'env tag-env}}))
\end{clojure}

Чтобы разобрать файл с тегами, считайте его в строку и передайте в
\code{read-config}:

\begin{clojure}
(-> "/path/to/config.edn"
    slurp
    read-config)
\end{clojure}

YAML тоже предусматривает теги. Они начинаются с одного или двух восклицательных
знаков в зависимости от семантики. У~стандартных тегов два знака, а у
пользовательских~--- один. Так мы сразу поймём семантику тега, когда встретим
его.

\index{форматы!YAML}
\index{библиотеки!Yummy}
\index{теги!YAML}

Библиотека Yummy предлагает парсер YAML, <<заряженный>> полезными тегами. Среди
прочих нас интересует \code{!envvar}, который вернёт значение переменной по
имени. Опишем конфигурацию в файле \code{config.yaml}:

\begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     !envvar DB_USER
  password: !envvar DB_PASS
\end{yaml}

Подключим библиотеку и прочитаем файл. На месте тегов получим значения среды:

\ifnarrow

\begin{clojure}
(require '[yummy.config :as yummy])
(yummy/load-config
  {:path "config.yaml"})

{:server_port 8080
 :db {:dbtype "mysql"
      :dbname "book"
      :user "ivan"
      :password "secret123"}}
\end{clojure}

\else

\begin{clojure}
(require '[yummy.config :as yummy])
(yummy/load-config {:path "config.yaml"})

{:server_port 8080
 :db {:dbtype "mysql"
      :dbname "book"
      :user "ivan"
      :password "secret123"}}
\end{clojure}

\fi

\noindent
Мы подробно рассмотрим Yummy в следующем разделе главы.

Теги несут преимущества и недостатки. С одной стороны, они делают конфигурацию
плотнее: строка с тегом несёт больше информации. Запись \code{\#env DB\_PASS}
выглядит короче и приятней глазу. Сложные теги выносят в библиотеки и подключают
в зависимостях проекта.

С другой стороны, теги привязывают конфигурацию к платформе. Если в YAML-файле
встречается тег \code{!envvar}, библиотека на Python не~сможет его прочитать: в
ней нет такого тега (точнее, есть, но с~другим именем). Технически это можно
исправить: пропускать незнакомые теги или установить заглушку. Однако подход не
гарантирует одинаковый результат на разных платформах.

С тегами конфигурация обрастает побочными эффектами. В терминах функционального
программирования говорят, что она теряет чистоту. Появляется соблазн вынести в
тег слишком много логики: включить дочерний файл, форматировать строки. Теги
стирают грань между чтением конфигурации и её обработкой. Когда их слишком
много, конфигурацию трудно поддерживать.

Оба приёма~--- разбор спекой и тегами~--- оппонируют друг другу. Выбирайте тот
способ, который удобен команде и процессу.

\section{Короткий обзор форматов}

Мы упомянули три формата данных: JSON, EDN и YAML. Перечислим особенности
каждого из них. Наша цель не выявить идеальный формат, а подготовить читателя к
неочевидным моментам, которые возникнут в работе с ними.

\subsection{JSON}

\index{форматы!JSON}

С JSON знакомы даже те, кто не работает с вебом. Это запись данных по правилам
JavaScript. Стандарт задаёт числа, строки, логический тип, \code{null} и две
коллекции: массив и объект. Последний играет роль словаря, то есть сопоставляет
ключ и значение. Коллекции могут быть вложены друг в друга.

\index{языки!JavaScript}

Преимущество JSON в его популярности: сегодня это стандарт обмена данными между
клиентом и сервером. По сравнению с XML его легче читать и поддерживать. С JSON
работают современные редакторы, языки и платформы. Это естественный способ
хранить данные в~JavaScript.

В JSON не предусмотрены комментарии. На первый взгляд, это мелочь, но на
практике комментарии важны. Многим параметрам нужно объяснение, что они делают и
какие значения принимают. Посмотрите конфигурации Redis, PostgreSQL или
Nginx~--- больше половины файла занимают комментарии.

Разработчики придумали уловки, чтобы обойти ограничение. Например, поставить
одноимённое поле перед тем, к которому относится комментарий:

\ifnarrow

\begin{json}
{
    "server_port":
    "A port for the HTTP server.",
    "server_port": 8080
}
\end{json}

\else

\begin{json}
{
  "cache_type": "Caching backend (memcache or redis)",
  "cache_type": "memcache",

  "server_port": "A port for the HTTP server",
  "server_port": 8080
}
\end{json}

\fi

Расчёт сделан на то, что библиотека обходит поля по очереди и~второе поле
заменит первое. Но стандарт JSON ничего не говорит о~порядке полей; приём
остаётся на ваш риск. Логика библиотеки может быть иной, например бросить
исключение или пропустить ключ, который уже обработан.

Некоторые программы поддерживают комментарии в JSON на уровне синтаксиса.
Редактор Sublime Text хранит настройки в \code{.json}-файлах с комментариями в
стиле JavaScript (двойная косая черта).  Однако в общем случае у~проблемы нет
решения.

\index{библиотеки!Cheshire}

Формат не поддерживает теги, о которых мы говорили выше.

JSON выгодно отличается от многословного XML, которому пришёл на замену. Данные
в JSON выглядят чище и удобнее, чем дерево тегов. Но современные форматы
выражают данные ещё чище. Например, в YAML любую структуру можно записать без
единой скобки за счёт отступов.

Синтаксис JSON <<шумит>>: он требует кавычек, двоеточий и запятых там, где
другие форматы обходятся без них. Запятая в конце массива или объекта считается
ошибкой. Ключи словаря не могут быть числами. Нельзя записать текст в несколько
строк.

Сравните данные в JSON и YAML. Вторая запись короче и визуально
спокойнее\iflarge\lis{fig:json-vs-yaml}\fi.

\ifnarrow

\begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
\end{json}

\splitter

\begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     user
  password: '****'
event:
  - 2019-07-05T12:00:00
  - 2019-07-12T23:59:59
\end{yaml}

\else

\iflarge
\begin{listing}[ht!]
\fi

\noindent
\iflarge
\begin{tabular}{ @{}p{6.5cm} @{}p{4cm} }
\else
\begin{tabular}{ @{}p{6cm} @{}p{4cm} }
\fi

\begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
\end{json}

&

\linegap

\begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     user
  password: '****'
event:
  - 2019-07-05T12:00:00
  - 2019-07-12T23:59:59
\end{yaml}

\end{tabular}

\iflarge
\caption{Одна и та же структура данных в разных форматах}
\label{fig:json-vs-yaml}
\end{listing}
\fi

\fi

В Clojure для работы с JSON служат библиотеки
\footurl{Cheshire}{https://github.com/dakrone/cheshire}[Cheshire] и
\footurl{Data.json}{https://github.com/clojure/data.json}[Data.json]. Они
сводятся к двум функциям: прочитать и записать документ. Подробные примеры вы
найдёте на страницах проектов в GitHub.

\subsection{YAML}

\index{форматы!YAML}

Язык YAML, как и JSON, различает базовые типы: скаляры, \code{null}
и~коллекции. YAML делает ставку на краткость записи: вложенность задают отступы,
а не скобки. Запятые необязательны там, где язык выводит их логически. Массив
чисел в одну строку выглядит как в~JSON:

\index{коллекции!в YAML}

\begin{yaml}
numbers: [1, 2, 3]
\end{yaml}

\noindent
, но при записи в столбик запятые и скобки отпадают:

\begin{yaml}
numbers:
  - 1
  - 2
  - 3
\end{yaml}

YAML поддерживает комментарии в стиле Python (знак решётки), за что его любят
DevOps. В комментариях можно ставить ссылки на документацию или предупредить о
неочевидных моментах. Программы вроде Docker-compose и~Kubernetes читают
настройки из YAML-файлов.

В YAML можно записать текст в несколько строк. Его проще читать и~копировать,
чем одну строку с~символом переноса \code{\textbackslash{}n} как в JSON.

\ifnarrow

\begin{yaml}
description: |
  To solve the problem,
  please do the following:

  - Press Control + Alt + Delete;
  - Turn off your computer;
  - Walk for a while.

  Then try again.
\end{yaml}

\else

\begin{yaml}
description: |
  To solve the problem, please do the following:

  - Press Control + Alt + Delete;
  - Turn off your computer;
  - Walk for a while.

  Then try again.
\end{yaml}

\fi

Язык официально поддерживает теги.

\index{отступы!в YAML}

Недостатки YAML вытекают из его преимуществ. Отступы кажутся удачным решением до
тех пор, пока файл не станет большим. Глаз начнёт прыгать на большие расстояния,
чтобы сверять уровни структур. Иногда часть данных <<съезжает>> из-за лишнего
отступа. С точки зрения YAML ошибки нет, поэтому её трудно найти.

Иногда отказ от кавычек приводит к неверным типам или структуре. Предположим, в
поле \code{phrases} перечислены фразы, которые увидит пользователь:

\pagebreakafive

\begin{yaml}
phrases:
  - Welcome!
  - See you soon!
  - Warning: wrong email address.
\end{yaml}

Из-за двоеточия в последней строке парсер решит, что это вложенный словарь
(обратите внимание на подсветку синтаксиса). Получим неверную структуру:

\ifnarrow

\begin{clojure}
{:phrases
 ["Welcome!"
  "See you soon!"
  {:Warning "wrong email address."}]}
\end{clojure}

\else

\begin{clojure}
{:phrases ["Welcome!"
           "See you soon!"
           {:Warning "wrong email address."}]}
\end{clojure}

\fi

Другие примеры: версия продукта \code{3.3}~--- число, но \code{3.3.1}~---
строка. Телефон \texttt{+7962524\-17\-45}~--- это число, потому что знак плюса
считается унарным оператором по аналогии с минусом. Лидирующие нули означают
восьмеричную запись: если не добавить кавычки к \code{000042}, получится
\code{34}.

Это не значит, что YAML неудачный формат. Случаи выше описаны в стандарте и
имеют логическое объяснение. Но иногда YAML ведёт себя не так, как вы
ожидали,~--- это плата за упрощённый синтаксис.

\subsection{EDN}

\index{форматы!EDN}

Формат EDN занимает особое место в обзоре. Он максимально приближен к Clojure и
поэтому играет такую же роль в языке, как JSON в~JavaScript. Это родной способ
связать данные с файлом.

Синтаксис EDN почти полностью совпадает с грамматикой Clojure. Формат охватывает
больше типов, чем JSON и YAML. Из скаляров доступны символы и кейворды (классы
\code{Symbol} и \code{Keyword} из пакета \code{clojure.lang}). Кроме вектора и
словаря EDN предлагает списки и~множества. Словари могут быть типизированными,
чтобы при чтении получались экземпляры записей. Подробнее о записях мы поговорим
в~главе про системы \page{defrecord}.

\index{теги!EDN}

Тег начинается с символа решётки. По умолчанию стандарт предлагает два тега:
\code{\#inst} и \code{\#uuid}. Первый читает строку в дату, а~второй~---
в~экземпляр \code{java.util.UUID}. Выше мы показали, как добавить свой тег:
нужно связать его с функцией одного аргумента при чтении строки.

Пример с разными типами, коллекциями и тегами:

\ifnarrow

\begin{clojure}
{:user/banned? false
 :task-state
 #{:pending :in-progress :done}
 :account-ids
 [1001 1002 1003]
 :server
 {:host "127.0.0.1" :port 8080}
 :date-range
 [#inst "2019-07-01" #inst "2019-07-31"]
 :node-id #uuid
 "26577362-902e-49e3-83fb-9106be7f60e1"}
\end{clojure}

\else

\begin{clojure}
{:user/banned? false
 :task-state #{:pending :in-progress :done}
 :account-ids [1001 1002 1003]
 :server {:host "127.0.0.1" :port 8080}
 :date-range [#inst "2019-07-01" #inst "2019-07-31"]
 :node-id #uuid "26577362-902e-49e3-83fb-9106be7f60e1"}
\end{clojure}

\fi

Данные в EDN не отличаются от кода. Если скопировать их в REPL или модуль,
компилятор выполнит их. И наоборот: вывод REPL можно записать в файл для
дальнейшей работы.

Сброс данных в EDN сводится к простым шагам: <<напечатать>> их в строку и
записать в файл. Функция \code{pr-str} переводит данные в текст. Код ниже
создаст файл \code{dataset.edn} с данными:

\begin{clojure}
(-> {:some ["data"]}
    (pr-str)
    (->> (spit "dataset.edn")))
\end{clojure}

Обратное действие~--- прочитать файл и распарсить код на Clojure с~помощью
\code{edn/read-string}:

\begin{clojure}
(require '[clojure.edn :as edn])

(-> "dataset.edn" slurp edn/read-string)
;; {:some ["data"]}
\end{clojure}

\index{синтаксис!\texttt{\#\_} (игнорирование)}

EDN поддерживает не только обычные комментарии. Тег \code{\#\_} игнорирует
следующий за ним элемент. Им может быть что угодно, в том числе коллекция. Если
нужно <<заигнорить>> словарь, который занимает несколько строк, поставьте перед
ним \code{\#\_}, и парсер пропустит его.

\index{синтаксис!\texttt{;} (комментарий)}

Так отключают целые части конфигурации. В следующем примере мы игнорируем третий
элемент вектора. Если поставить обычный комментарий на всю строку (точку с
запятой), он заденет закрывающие скобки, и выражение станет неверным.

\begin{clojure}
{:users [{:id 1 :name "Ivan"}
         {:id 2 :name "Juan"}
         #_{:id 3 :name "Huan"}]}
\end{clojure}

EDN привязан к Clojure и поэтому непопулярен в других языках. Редакторы не
подсвечивают его синтаксис без плагинов. EDN доставит проблем DevOps, которые
работают в основном с JSON и YAML. Если конфигурацию читают скрипты на Python
или Ruby, придётся ставить библиотеку для работы с форматом.

EDN~--- удачный выбор, когда и бекэнд, и фронтэнд одновременно работают на~стеке
Clojure и ClojureScript. Его выбирают там, где Clojure преобладает над другими
технологиями.

\section{Промышленные решения}

Понимать конфигурацию важно, но мы не ожидаем, что в каждом проекте её пишут с
нуля. В последнем разделе мы рассмотрим, что предлагает сообщество для
конфигурации проектов. Мы остановили внимание на Cprop, Aero и Yummy. Библиотеки
отличаются идеологией и архитектурой. Мы специально подобрали их так, чтобы
увидеть проблему с разных сторон.

\subsection{Cprop}

\index{библиотеки!Cprop}

Библиотека \footurl{Cprop}{https://github.com/tolitius/cprop}[Cprop] работает по
принципу <<данные отовсюду>>. В~отличие от нашего загрузчика, Cprop понимает
больше источников. Библиотека читает не только файл и переменные среды, но и
ресурсы, property-файлы и обычные словари.

В библиотеке задан порядок обхода источников и их приоритет. Поля одного
источника заменяют другие. Например, переменные среды считаются более важными,
чем файл. Для частных случаев в~Cprop легко задать свой порядок загрузки.

Нас интересует функция \code{load-config}. Без параметров она запускает
стандартный загрузчик. По умолчанию он ищет два источника данных: ресурс и
property-файл. Ресурс должен называться \code{config.edn}. Cprop ожидает от него
данные в формате EDN.

Если системное свойство \code{conf} не пустое, библиотека полагает, что это путь
к property-файлу, и загружает его. Свойства~--- это переменные Java-машины,
аналог среды окружения для JVM. При загрузке JVM получает свойства по умолчанию:
тип операционной системы, разделитель строк и другие. Дополнительные свойства
задают параметром \code{-D} при запуске. Пример ниже запускает проект со
свойством \code{conf}:

\index{JVM!Jar}
\index{JVM!properties}

\ifnarrow

\begin{bash}
$ java \
   -Dconf="/path/to/config.properties" \
   -jar project.jar
\end{bash}

\else

\begin{bash}
$ java -Dconf="/path/config.properties" -jar project.jar
\end{bash}

\fi

Файлы \code{.properties} содержат пары \code{поле=значение}, по одной на
строку. Поля похожи на домены: это лексемы, разделённые точкой. Лексемы убывают
по старшинству:

\begin{ini}
db.type=mysql
db.host=127.0.0.1
db.pool.connections=8
\end{ini}

Библиотека трактует точки как вложенные словари. Файл выше вернёт структуру:

\begin{clojure}
{:db {:type "mysql"
      :host "127.0.0.1"
      :pool {:connections 8}}}
\end{clojure}

Получив конфигурацию, Cprop ищет переопределения в переменных среды. Для них
работают те же правила, что и в нашем загрузчике. Например, переменная
\texttt{DB\_\_POOL\_\_CONNEC\-TIONS=16} заменит значение 8 на 16 во вложенном
словаре. Cprop игнорирует переменные, которые не входят в~конфигурацию, и тем
самым не загрязняет~её.

Нестандартные пути к ресурсу и файлу задают ключами:

\begin{clojure}
(load-config
 :resource "private/config.edn"
 :file "/path/custom/config.edn")
\end{clojure}

\index{модули!cprop.source}

Для тонкой работы Cprop предлагает модуль \code{cprop.source}. Его функция
\code{from-env} читает все переменные среды, \texttt{from\-/props\-/file}
загрузит property-файл и так далее. Легко построить такую комбинацию, которая
нужна проекту.

Ключ \code{:merge} объединяет конфигурацию с любым источником. В~нём следуют
выражения, которые вернут словарь. Надуманный пример из документации:

\ifnarrow

\begin{clojure}
(load-config
 :resource "path/within/classpath/to.edn"
 :file "/path/to/some.edn"
 :merge
 [{:datomic {:url "datomic:mem://test"}}
  (from-file "/path/file.edn")
  (from-resource "/path/resource.edn")
  (from-props-file "/path/cfg.properties")
  (from-system-props)
  (from-env)])
\end{clojure}

\else

\begin{clojure}
(load-config
 :resource "path/within/classpath/to.edn"
 :file "/path/to/some.edn"
 :merge [{:datomic {:url "datomic:mem://test"}}
         (from-file "/path/to/file.edn")
         (from-resource "/path/to/resource.edn")
         (from-props-file "/path/to/some.properties")
         (from-system-props)
         (from-env)])
\end{clojure}

\fi

Чтобы отследить загрузку, установите переменную среды \code{DE\-BUG=y}. С~ней
Cprop выводит служебную информацию: список источников, порядок загрузки,
переопределение и так далее.

Cprop только читает данные из источников, но не проверяет их. В~библиотеке нет
валидации спекой, как сделано в нашем загрузчике. Шаг остаётся на ваше
усмотрение.

Библиотека по-своему выводит типы. Если строка состоит только из цифр, её
приводят к числу. Значения с запятыми становятся списками. Иногда этих правил
недостаточно для полного контроля за типами. Вам по-прежнему понадобятся
Spec и \code{s/conform} для вывода типов и~сообщений об ошибке.

\subsection{Aero}

\index{библиотеки!Aero}

\footurl{Aero}{https://github.com/juxt/aero}[Aero] работает с файлами
EDN. Библиотека предлагает теги, с которыми формат становится похож на мини-язык
программирования. В нём появляются операторы ветвления, импорта,
форматирования. По-другому подход называют <<EDN на стероидах>>.

\index{модули!aero.core}

Функция \code{read-config} читает файл или ресурс EDN:

\pagebreakafive

\ifnarrow

\begin{clojure}
(require
  '[aero.core :refer (read-config)])

(read-config "config.edn")
(read-config
  (clojure.java.io/resource
    "config.edn"))
\end{clojure}

\else

\begin{clojure}
(require '[aero.core :refer [read-config]]
         '[clojure.java.io :as io])

(read-config "config.edn")
(read-config (io/resource "config.edn"))
\end{clojure}

\fi

\index{теги!Aero}

Теги~--- главный момент в Aero, поэтому разберём основные из них. Знакомый нам
\code{\#env} находит значение по имени переменной среды:

\begin{clojure}
{:db {:passwod #env DB_PASS}}
\end{clojure}

Тег \code{\#envf} форматирует строку переменными. Предположим, подключение к базе
состоит из отдельных полей, но вы предпочитаете JDBC URI~--- длинную строку,
похожую на веб-адрес. Чтобы не повторяться, адрес вычисляют из исходных полей:

\ifnarrow

\begin{clojure}
{:db-uri
 #envf ["jdbc:postgresql://%s/%s?user=%s"
        DB_HOST DB_NAME DB_USER]}
\end{clojure}

\else

\begin{clojure}
{:db-uri #envf ["jdbc:postgresql://%s/%s?user=%s"
                DB_HOST DB_NAME DB_USER]}
\end{clojure}

\fi

Тег \code{\#or} похож на аналог Clojure: он возвращает первое истинное значение
из списка. В основном тег нужен для значений по умолчанию. Предположим,
переменная \code{DB\_PORT} оказалась пуста. Чтобы избежать ошибки, укажем
стандартный порт PostgreSQL. Обратите внимание, что после \code{\#or} обязательно
следует вектор или список.

\begin{clojure}
{:db {:port #or [#env DB_PORT 5432]}}
\end{clojure}

\index{профили!Aero}

Оператор \code{\#profile} позволяет найти значение по профилю. Значение за тегом
должно быть словарём. Ключ словаря~--- профиль, а~значение~--- то, что получим в
результате его разрешения. Профиль задают в параметрах \code{read-config}.

Пример ниже показывает, как найти имя базы по профилю. Без профиля получим
\code{"book"}, но для \code{:test} имя станет \code{"book\_test"}:

\pagebreakafive

\ifnarrow

\begin{clojure}
{:db
 {:name
  #profile {:default "book"
            :dev     "book_dev"
            :test    "book_test"}}}

(read-config "aero.test.edn"
  {:profile :test})
{:db {:name "book_test"}}
\end{clojure}

\else

\begin{clojure}
{:db {:name #profile {:default "book"
                      :dev     "book_dev"
                      :test    "book_test"}}}

(read-config "aero.test.edn" {:profile :test})
{:db {:name "book_test"}}
\end{clojure}

\fi

Тег \code{\#include} помещает в конфигурацию другой EDN-файл. В~нём тоже могут
быть теги, и библиотека выполнит их рекурсивно. К~импорту прибегают, когда
конфигурация становится большой.

\begin{clojure}
{:queue #include "message-queue.edn"}
\end{clojure}

Тег \code{\#ref} ставит ссылку на любое место конфигурации. Он принимает вектор
ключей, который обычно передают в \code{get-in}. Ссылка позволит избежать
повторов.  Например, компонент фоновой задачи нуждается в~пользователе, которого
мы указали для базы. Чтобы не копировать его, поставим ссылку:

\begin{clojure}
;; config.edn
{:db {:user #env DB_USER}
 :worker {:user #ref [:db :user]}}
\end{clojure}

\noindent
При чтении файла ссылка разрешится в~значение:

\ifnarrow

\begin{clojure}
{:db {:user "ivan"}
 :worker {:user "ivan"}}
\end{clojure}

\else

\begin{clojure}
{:db {:user "ivan"}, :worker {:user "ivan"}}
\end{clojure}

\fi

Aero предлагает несложный язык описания конфигурации. Библиотека подкупает идеей
и красотой реализации. Но в момент, когда вам захочется переехать с негибкого
JSON на Aero, подумайте об обратной стороне медали.

\index{декларативность}

Конфигурацию не случайно отделяют от кода. Если бы не потребность индустрии, мы
бы хранили параметры в исходных файлах. Но этого не делают~--- наоборот, хорошие
практики советуют отделять параметры от кода. В том числе потому, что, в
отличие от кода, конфигурация \emph{декларативна}.

Негибкие JSON-файлы обладают важным свойством: они декларативны. Если вы открыли
файл или сделали \code{cat}, то увидите данные. Синтаксис может быть неудобен,
но данные означают сами себя, и есть только один способ прочитать их.

Наоборот, файл с обилием тегов труден в поддержке. Это уже не конфигурация, а
код. Чтобы увидеть данные, файл нужно выполнить. При чтении файла в вашей голове
запустится мини-интерпретатор, который не гарантирует правильный результат.

Получается своего рода круг: мы вынесли параметры в конфигурацию, добавили теги
и вернулись к коду. Подход имеет право на жизнь, но к нему приходят осознанно.

\subsection{Yummy}

\index{библиотеки!Yummy}
\index{организации!Exoscale}

Библиотека \footurl{Yummy}{https://github.com/exoscale/yummy}[Yummy] замыкает обзор. От
аналогов она отличается двумя свойствами. Во-первых, работает с файлами YAML для
чтения конфигурации (отсюда и название). Во-вторых, процесс загрузки похож на
тот, что мы рассмотрели в начале главы.

Полноценный загрузчик не только читает параметры. Его цикл включает проверку данных
и вывод ошибки. Сообщение внятно объясняет, в~чём причина. С помощью опций можно
задать реакцию на исключение, которые возникло в работе. Yummy предлагает всё из
перечисленного.

Путь к файлу либо указывают в параметрах, либо библиотека ищет его по особым
правилам. Вариант, когда путь задан явно:

\ifnarrow

\begin{clojure}
(require
  '[yummy.config :refer [load-config]])

(load-config
  {:path "/path/to/config.yaml"})
\end{clojure}

\else

\begin{clojure}
(require '[yummy.config :refer [load-config]])

(load-config {:path "/path/to/config.yaml"})
\end{clojure}

\fi

Во втором случае вместо пути указали имя проекта. Yummy ищет путь к файлу в
переменной среды \code{<project>\_CONFIGURATION} или свойстве
\code{<project>.configuration}:

\begin{bash}
$ export BOOK_CONFIGURATION=config.yaml
\end{bash}

\ifafive\vspace{-5mm}\fi

\begin{clojure}
(load-config {:program-name :book})
\end{clojure}

Библиотека расширяет YAML несколькими тегами. Это знакомый \code{!envvar}
для переменных среды:

\index{теги!Yummy}

\begin{yaml}
db:
  password: !envvar DB_PASS
\end{yaml}

\noindent
Тег \code{!keyword} полезен, чтобы привести строку к кейворду:

\begin{yaml}
states:
  - !keyword task/pending
  - !keyword task/in-progress
  - !keyword task/done
\end{yaml}

\noindent
Результат:

\ifnarrow

\begin{clojure}
{:states [:task/pending
          :task/in-progress
          :task/done]}
\end{clojure}

\else

\begin{clojure}
{:states [:task/pending :task/in-progress :task/done]}
\end{clojure}

\fi

Тег \code{!uuid} аналогичен \code{\#uuid} в EDN: он возвращает объект
\code{java.\-util.\-UUID} из строки:

\ifnarrow

\begin{yaml}
system-user: !uuid
    cb7aa305-997c-4d53-a61a-38e0d8628dbb
\end{yaml}

\else

\begin{yaml}
system-user: !uuid cb7aa305-997c-4d53-a61a-38e0d8628dbb
\end{yaml}

\fi

Тег \code{!slurp} читает файл, что удобно для сертификатов шифрования. Их
содержимое~--- длинная строка, которую неудобно хранить в общей конфигурации. В
ключах \code{:auth}, \code{:cert} и \code{:pkey} окажется содержимое файлов из
папки \code{certs}.

\begin{yaml}
tls:
  auth: !slurp "certs/ca.pem"
  cert: !slurp "certs/cert.pem"
  pkey: !slurp "certs/key.pk8"
\end{yaml}

\index{spec!assert}

Чтобы проверить конфигурацию, в параметры \code{load-config} передают ключ
спеки. Когда ключ указан, Yummy выполняет \code{s/assert} с данными из
файла. Если проверка вернула ложь, всплывает исключение. Yummy использует
Expound \page{expound}, чтобы улучшить текст об ошибке.

\index{библиотеки!Expound}

\begin{clojure}
(load-config {:program-name :book
              :spec ::config})
\end{clojure}

\index{die-fn}
\index{функция смерти}

Словарь опций принимает параметр \code{:die-fn}. Это функция, которая
сработает, если любая стадия завершится ошибкой. Функция принимает исключение
и метку с именем стадии.

\index{каналы!stderr}

Если \code{:die-fn} не задан, Yummy вызовет обработчик по умолчанию. Он
выводит текст в \code{stderr} и завершает JVM с кодом 1. На этапе разработки
мы не хотим обрывать REPL из-за ошибки конфигурации. В интерактивном сеансе
наша \code{die-fn} только печатает текст и ошибку:

\ifnarrow

\begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e label]
            (binding [*out* *err*]
              (println label
                (ex-message e))))})
\end{clojure}

\else

\begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e label]
            (binding [*out* *err*]
              (println label (ex-message e))))})
\end{clojure}

\fi

В боевом режиме запишем исключение в лог и завершим программу.

\index{логирование}

\ifnarrow

\begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e label]
            (log/error e
              "Config error" label)
            (System/exit 1))})
\end{clojure}

\else

\begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e label]
            (log/error e "Config error" label)
            (System/exit 1))})
\end{clojure}

\fi

Заметим, что макрос \code{s/assert} не выводит значения, как это делает
\code{s/conform}, а только бросает исключение. Это значит, вывод типов спекой на
работает в Yummy. Это сделано нарочно: типы выводят тегами, а спека только
проверяет значения.

\section{Заключение}

Перечислим основные тезисы из этой главы. Конфигурация нужна, чтобы проект шёл
по стадиям производства: разработка, тестирование, выпуск. На каждом шаге его
запускают с разными настройками. Без конфигурации это невозможно.

Загрузка конфигурации означает чтение данных, вывод типов и~проверку значений. В
случае ошибки программа выводит сообщение и~завершается с аварийным
кодом. Нельзя продолжать работу с неверными параметрами.

Источниками конфигурации могут быть файл, ресурс, переменные окружения. Бывают
гибридные схемы, когда основные данные приходят из файла, а секретные поля~--- из
окружения.

Переменные среды живут в памяти операционной системы. Когда переменных много, их
помещают в ENV-файл. Приложение не читает его: это делает скрипт, который
управляет приложением на сервере. Приложению неизвестно, откуда пришли
переменные.

Окружение~--- это плоский словарь. Переменные хранят только текст, в ключах нет
вложенности или пространств имён. В разных системах свои соглашения о том, как
извлечь структуру из имени переменной. Это могут быть точки, двойные
подчеркивания или что-то ещё.

Форматы данных отличаются синтаксисом и типами. Форматы общего назначения задают
строки, числа, списки и словари. Они не настолько гибки, как специализированные
форматы, но работают везде. Наоборот, формат для конкретной платформы тесно
связан с ней, но непопулярен в других языках.

Некоторые форматы поддерживают теги. С помощью тегов из скаляров получают более
сложные типы, например даты. Теги опасны тем, что когда их много, конфигурация
превращается в код.

Clojure предлагает несколько библиотек для конфигурации приложения. Они
различаются замыслом и архитектурой, и каждый разработчик найдёт то, что ему по
душе. Нет точного ответа на вопрос, какой формат или библиотека лучше. Выбирайте
то, что предельно дёшево решит вашу задачу.
