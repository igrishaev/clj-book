\chapter{Clojure.spec}

\label{chapter-spec}

\index{spec}

\begin{teaser}
В этой главе мы рассмотрим clojure.spec~--- библиотеку для проверки данных в
Clojure. Это особенная библиотека: на ней пишут валидаторы и парсеры, с её
помощью генерируют данные для тестов. Spec фундаментальна по своей природе,
поэтому уделим ей пристальное внимание.
\end{teaser}

Название spec происходит от specification (с англ.~--- <<спецификация, описание>>). Это
набор функций и макросов, чтобы схематично описать данные. Например, из каких
ключей состоит словарь и типы его значений. Запись называют спецификацией данных или
сокращённо спекой. Далее мы будем использовать короткий термин.

Специальные функции проверяют, подходят ли данные к спеке. Если нет, получим
отчёт, в каком месте произошла ошибка и почему.

\index{модули!clojure.spec.alpha}

Spec входит в поставку Clojure начиная с версии 1.9. Полностью модуль называется
\verb|clojure.spec.alpha|. Не волнуйтесь о частичке alpha на конце
имени: она осталась по историческим причинам.

\index{валидация}
\index{парсинг}

Spec стала важной вехой в развитии Clojure. Ключевое свойство Spec в том, что
она фундаментальна. Валидация данных~--- это малая часть её возможностей. Spec
не только проверяет данные, но и преобразует их. На Spec легко писать парсеры.

Формально Spec~--- это обычная библиотека. Но её абстракции настолько мощны, что
Clojure переиспользует их. С версии 1.10 компилятор Clojure анализирует главные
макросы с помощью Spec. Так проекты дополняют друг друга.

Прежде чем браться за техническую часть, разберёмся с теорией. Вспомним, как
связаны между собой классы, типы и валидация.

\section{Типы и классы}

\label{type-and-pred}

\index{типизация!статическая}
\index{типизация!динамическая}

Считается, что код на языке со статической типизацией безопаснее, чем с
динамической. Компилятор не позволит сложить число и~строку ещё до того, как
мы запустим программу. Однако тип переменной~--- это лишь одно из многих
ограничений. Редко случается так, что тип задаёт все допустимые
значения. Чаще всего вместе с типом учитывают границы, длину, попадание в
интервалы и перечисления. Иногда значения верны по отдельности, но не могут
стоять в паре друг с другом.

\index{порт}

Рассмотрим, как выразить в коде сетевой порт. В операционной системе это число
от 0 до $2^{16}-1$. Целые типы обычно описаны степенями двойки, поэтому найдётся
условный \verb|unsigned int|, который охватит именно этот диапазон. У нулевого
порта особая семантика, и в~прикладных программах его не используют.
Вероятность, что в~языке предусмотрен тип от~1 до~$2^{16}-1$, крайне мала.

Легче всего увидеть проблему на диапазоне дат. Единичная дата может быть сколь
угодно разумной, но диапазон накладывает ограничение: начало строго меньше
конца. Бизнес дополняет: разница не больше недели, обе даты в рамках текущего
месяца.

\index{валидация}

В ООП знают об этой проблеме и решают её классами \verb|UnixPort|
и~\verb|DateRange|. Условный \verb|UnixPort|~--- это класс с конструктором. Он
принимает целое число и выполняет проверку на диапазон. Если число выходит за
рамки 1~\dots~$2^{16}-1$, конструктор бросит исключение. Программист уверен, что
создал новый тип. Это неверно~--- классы и типы не тождественны.

Конструктор~--- это обычный валидатор. Он неявно сработает, когда мы напишем
\spverb|new UnixPort(8080)|. Из-за неявности возникает иллюзия, что мы создали
тип. На деле это валидация и синтаксический сахар.

\index{синтаксический сахар}

В промышленных языках нельзя описать класс так, чтобы выражение
\verb|new UnixPort(-42)| привело к ошибке компиляции. Найти её могут
только сторонние утилиты и плагины для IDE.

Конструктор нельзя использовать повторно. Представим классы \verb|UnixPort| и
\verb|NetPort|. Первый класс проверяет порт на~диапазон и~бросает
исключение. Выгодно пользоваться этим классом, поскольку он совмещён
с~валидацией. Однако сторонняя библиотека принимает \verb|NetPort|. Возникает
проблема конвертации: нужно извлечь <<сырой>> порт из \verb|UnixPort|
и~передать в~\verb|NetPort|. Это лишний код и путаница с~классами.

\index{классы}

Признаки удобной валидации~--- это независимость и компоновка. Независимость
означает, что данные не привязаны к валидации. Нет ничего зазорного в том, что
порт~--- это целое число. Пусть библиотека принимает \verb|integer|, а разработчик
сам решит, как его проверить. Появится выбор, насколько строгой должна быть
проверка.

\index{функции!композиция}

Компоновка означает, что полезно иметь несколько простых проверок, чтобы
составить из них сложные. Пусть заданы проверки <<это>> и~<<то>> и теперь нужны
комбинации <<это \emph{и}~то>>, <<это \emph{или}~то>>. В идеале компоновка
занимает пару строк и считается тривиальной задачей.

\index{функции}

Оба тезиса ложатся на функцию. На неё действует одна операция~--- вызов, что
упрощает схему. Функция принимает значение и возвращает истину или ложь. Это
ответ на вопрос, было ли значение правильным или нет. Функция~--- объект
высшего порядка, поэтому другие функции порождают из них комбинации.

\section{Основы spec}

С багажом рассуждений мы подходим к Spec. Подключим модуль в~текущее
пространство:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
  \end{clojure}
\end{english}

Синоним \verb|s| нужен, чтобы избежать конфликтов имён с
\verb|clojure.core|. Модуль Spec несёт макросы \verb|s/and|, \verb|s/or| и
другие, у которых ничего общего с обычными \verb|and| и \verb|or|. Считается
дурным тоном, если имена одного модуля затеняют другие, поэтому обращаемся к
Spec через синоним.

\index{spec!def}

Главная операция в Spec~--- создать новую \emph{спеку}:

\begin{english}
  \begin{clojure}
(s/def ::string string?)
  \end{clojure}
\end{english}

\index{clojure.core!string?}

Макрос \verb|s/def| принимает ключ и предикат. Он создал объект спеки из
функции \verb|string?| и поместил в глобальный реестр с~ключом
\verb|::string|.

Важно понимать, что \verb|::string|~--- это не спека, а псевдоним. Макросы
Spec работают не с объектами спеки, а с ключам. Они сами найдут спеку в
реестре. Это удобно, потому что ключи глобальны. В любом месте можно сослаться
на \verb|::string| без лишних импортов.

\index{spec!get-spec}

Вторым аргументом идёт предикат \verb|string?|. Предикат~--- это функция,
которая возвращает истину или ложь. Функция~--- это не спека, а строительный
материал для неё. Спека оборачивает функцию в особый объект. Технически на
него можно сослаться: функция \verb|s/get-spec| по~ключу спеки вернёт
её объект. На практике он не нужен, потому что везде указывают ключи.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/get-spec ::string)
;;#object[clojure.spec.alpha$reify 0x...]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/get-spec ::string)
;; #object[clojure.spec.alpha$reify 0x3e9dde1d]
  \end{clojure}
\end{english}

\fi

\index{spec!регистр}

Спеки хранятся в глобальном реестре под своими ключами. Макрос \verb|s/def| не
проверяет, была ли уже такая спека, перед тем как поместить её в
реестр. Если была, мы потеряем старую версию.

\index{конфликты ключей}

Spec не работает с ключами без пространства, например \verb|:name| или
\verb|:email|. Это повышает риск конфликта ключей. Чтобы назначить ключу
текущее пространство, поставьте два двоеточия: \verb|::name|, \verb|::email|.

\index{пространства имён!текущее}

Самое простое, что можно сделать со спекой,~--- проверить, подходит ли ей
значение. Функция \verb|s/valid?| принимает ключ спеки, значение и~возвращает
\verb|true| или \verb|false|.

\begin{english}
  \begin{clojure}
(s/valid? ::string 1)      ;; false
(s/valid? ::string "test") ;; true
  \end{clojure}
\end{english}

Пустая строка пройдёт валидацию, но чаще всего в этом нет смысла. Пустые имя или
заголовок означают ошибку. Объявим спеку, которая дополнительно проверит, что
строка не пустая. Наивный способ это сделать~--- усложнить предикат:

\index{spec!::ne-string}

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (fn [val]
    (and (string? val)
         (not (empty? val)))))
  \end{clojure}
\end{english}

\noindent
Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::ne-string "test") ;; true
(s/valid? ::ne-string "")     ;; false
  \end{clojure}
\end{english}

Ключ \verb|::ne-string|~--- это сокращение от <<\textbf{n}on-\textbf{e}mpty
string>>. Спека встречается часто, поэтому логично сэкономить на её имени.

Более изящный способ задать эту спеку~--- объединить предикаты через
\verb|every-pred|. Функция принимает предикаты и возвращает супер-предикат. Он
вернёт истину только если истинны все предикаты.

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (every-pred string? not-empty))
  \end{clojure}
\end{english}

\index{spec!and}
\index{clojure.core!every-pred}
\index{предикаты}

Мы собираем новую сущность из базовых, что короче и следует функциональному
стилю. Но ещё лучше комбинировать не предикаты, а спеки. Макрос \verb|s/and|
объединяет несколько предикатов и спек в новую спеку:

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (s/and string? not-empty))
  \end{clojure}
\end{english}

Так в Clojure строят сложные спеки: объявляют примитивы и~наращивают их
комбинации.

\section{Исключения}

\index{исключения}

Во время проверки Spec не перехватывает исключения~--- о них заботится
программист. Рассмотрим спеку для проверки URL. Проще всего это сделать
регулярным выражением:

\index{clojure.core!re-matches}
\index{регулярные выражения}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::url
  (partial
    re-matches #"(?i)^http(s?)://.*"))

(s/valid? ::url "test") ;;false
(s/valid? ::url "http://test.com") ;;true
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::url
  (partial re-matches #"(?i)^http(s?)://.*"))

(s/valid? ::url "test")            ;; false
(s/valid? ::url "http://test.com") ;; true
  \end{clojure}
\end{english}

\fi

Что-то отличное от строки вызовет ошибку:

\index{исключения}
\index{классы!NullPointerException}

\begin{english}
  \begin{clojure}
(s/valid? ::url nil)
;; Execution error (NullPointerException)
;; at java.util.regex.Matcher...
  \end{clojure}
\end{english}

\index{NPE}

Примечание: класс \verb|NullPointerException|~--- частый гость в мире Java. Для
краткости его называют \verb|NPE|.

Причина в том, что \verb|nil| попал в функцию \verb|re-matches|. Функция
трактует аргумент как строку, что приводит к \verb|NPE|. Перепишите спеку так,
чтобы она не бросала исключения. В примере с \verb|::url| сначала убедимся,
что это строка, и только потом проверим регулярным выражением.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::url
  (s/and ::ne-string
         (partial re-matches
           #"(?i)^http(s?)://.*")))

(s/valid? ::url nil) ;; false
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::url
  (s/and ::ne-string
         (partial re-matches #"(?i)^http(s?)://.*")))

(s/valid? ::url nil) ;; false
  \end{clojure}
\end{english}

\fi

\index{spec!::ne-string}

Макрос \verb|s/and| устроен так, что на первой неудаче цепь
оборвётся. Всё, что после \verb|::ne-string|, не сработает, и
исключения не будет.

По аналогии проверим возраст пользователя. Это предикаты на~число и~диапазон.

\begin{english}
  \begin{clojure}
(s/def ::age
  (s/and int? #(<= 0 % 150)))

(s/valid? ::age nil) ;; false
(s/valid? ::age -1)  ;; false
(s/valid? ::age 42)  ;; true
  \end{clojure}
\end{english}

\section{Спеки-коллекции}

\index{коллекции}
\index{скаляры}

Выше мы проверяли примитивные типы, или \emph{скаляры}. Это удобно для примеров,
но редко встречается на практике. В~основном проверяют не скаляры,
а~коллекции. Spec предлагает макросы, чтобы задать спеки-коллекции из
примитивов.

\index{spec!coll-of}

Макрос \verb|s/coll-of| принимает предикат или ключ и возвращает
спеку-коллекцию. Она проверяет, что каждый элемент проходит валидацию. Вот так
мы определим список URL:

\begin{english}
  \begin{clojure}
(s/def ::url-list (s/coll-of ::url))
  \end{clojure}
\end{english}

\noindent
Быстрая проверка:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/valid? ::url-list
  ["http://test.com" "http://ya.ru"])
;; true

(s/valid? ::url-list
  ["http://test.com" "dunno.com"])
;; false
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/valid? ::url-list ["http://test.com" "http://ya.ru"])
;; true

(s/valid? ::url-list ["http://test.com" "dunno.com"])
;; false
  \end{clojure}
\end{english}

\fi

\index{spec!map-of}
\index{HTTP!параметры}

Макрос \verb|s/map-of| описывает словарь. Вспомним поле \verb|:params| из
главы про веб-разработку \page{ring-params}. Его ключи~--- кейворды, а значения~---
строки. На языке спеки это выглядит так:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::params
  (s/map-of keyword? string?))

(s/valid? ::params
  {:foo "test"})  ;; true
(s/valid? ::params
  {"foo" "test"}) ;; false
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::params
  (s/map-of keyword? string?))

(s/valid? ::params {:foo "test"})  ;; true
(s/valid? ::params {"foo" "test"}) ;; false
  \end{clojure}
\end{english}

\fi

Проверка \verb|s/map-of| довольно слабая, чтобы покрыть все варианты. Факт
того, что значения~--- строки не даёт полезной информации. Важнее убедиться, что
в словаре именно те ключи, что мы ожидаем. К тому же редко бывает так, что тип
значений одинаковый. Наоборот, словарь несёт разные сведения о сущности:
имя, возраст, дату.

\index{spec!keys}

В таких случаях используют макрос \verb|s/keys|, в котором перечислены
спеки. Имена спек совпадают с ключами словаря. Значения ключей проверяются
одноимёнными спеками.

Представим веб-страницу с адресом и описанием. Объявим примитивы:

\begin{english}
  \begin{clojure}
(s/def :page/address ::url)
(s/def :page/description ::ne-string)
  \end{clojure}
\end{english}

\index{пространства имён}

Обратите внимание на пространство ключей. Адрес и описание относятся к странице,
поэтому им задают своё пространство. У статьи или книги тоже могут быть адрес и
описание. Пространство обещает, что спеки \verb|:page/address| и
\verb|:book/address| не заменят друг друга.

Составим спеку страницы:

\begin{english}
  \begin{clojure}
(s/def ::page
  (s/keys :req-un [:page/address
                   :page/description]))
  \end{clojure}
\end{english}

\index{spec!:req-un}

В параметре \verb|:req-un| указан вектор спек. Для каждой из них спека ищет в
словаре ключ с таким же именем и проверяет значение. Рассмотрим, что означает
\verb|:req-un| и какие ещё параметры принимает \verb|s/keys|.

Имя \verb|:req-un| состоит из частей req и un. Это признаки наличия
ключа и его типа. Req (англ.~required) означает, что ключи обязательно должны
быть в словаре. Если хотя бы одного ключа нет, получим ошибку. Противоположный
по смыслу параметр называется opt (англ.~optional). В нём указаны ключи,
которых может не быть. Их валидация происходит, только если они были в словаре.

\index{spec!:un}

Частичка un означает unqualified, неполный ключ. При проверке un-ключей
спека отбрасывает их пространство. Например, если указать \verb|:page/address|
в списке \verb|:req-un|, то в словаре ищется ключ \verb|:address|, а не
\verb|:page/address|.

Неполные ключи встречаются часто. Данные приходят из чужих API и баз данных,
которые не знают о пространствах имён. Исключения бывают, когда весь стек фирмы
построен на Clojure. В этом случае клиент и сервер шлют данные с полными
ключами.

Различают следующие комбинации \verb|req|, \verb|opt| и \verb|un|:

\begin{itemize}

\item
  \verb|:req|~--- необходимые полные ключи,

\item
  \verb|:req-un|~--- необходимые краткие ключи,

\index{spec!:opt}

\item
  \verb|:opt|~--- опциональные полные ключи,

\index{spec!:opt-un}

\item
  \verb|:opt-un|~--- опциональные краткие ключи.

\end{itemize}

У спеки \verb|::page| ключи обязательны и не учитывают пространство. Ниже
примеры данных \emph{с ошибками}. Это может быть неправильный адрес, пустое
описание, пропавший ключ. Если каждый из словарей подставить в выражение
\spverb|(s/valid? ::page <data>)|, результат будет ложью.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:address "clojure.org" ;; not a URL
 :description "Clojure Language"}

;; empty string
{:address "https://clojure.org/"
 :description ""}

;; no description
{:address "https://clojure.org/"}

 ;; full keys
{:page/address "https://clojure.org/"
 :page/description "Clojure Language"}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:address "clojure.org" ;; not a URL
 :description "Clojure Language"}

{:address "https://clojure.org/"
 :description ""} ;; empty string

{:address "https://clojure.org/"} ;; no description

{:page/address "https://clojure.org/" ;; full keys
 :page/description "Clojure Language"}
  \end{clojure}
\end{english}

\fi

Обратите внимание на последний случай. Значения верны, но у ключей пространство
\verb|:page|. Валидация не сработает, потому что спека ищет \verb|:address|,
а не \verb|:page/address|. Чтобы исправить последний пример, замените тип
ключей \verb|:req-un| на \verb|:req| (необходимые полные).

\index{spec!valid?}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::page-fq
  (s/keys :req [:page/address
                :page/description]))

(s/valid? ::page-fq
  {:page/address "https://clojure.org/"
   :page/description "Clojure Language"})
;; true
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::page-fq
  (s/keys :req [:page/address
                :page/description]))

(s/valid? ::page-fq
          {:page/address "https://clojure.org/"
           :page/description "Clojure Language"})
;; true
  \end{clojure}
\end{english}

\fi

Усложним пример: добавим странице статус, который мы получили при
последнем обращении к ней. Поле опционально, потому что если к странице ещё не
обращались, в него нечего записать. Новая спека:

\begin{english}
  \begin{clojure}
(s/def :page/status int?)

(s/def ::page-status
  (s/keys :req-un [:page/address
                   :page/description]
          :opt-un [:page/status]))
  \end{clojure}
\end{english}

Словари с правильным статусом и без него пройдут валидацию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
  {:address "https://clojure.org/"
   :description "Clojure Language"})

(s/valid? ::page-status
  {:address "https://clojure.org/"
   :description "Clojure Language"
   :status 200})
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"})

(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status 200})
  \end{clojure}
\end{english}

\fi

\index{nil}

Заметим, что \verb|s/keys| различает \verb|nil| и наличие ключа. Если статус
\verb|nil|, он \emph{состоит} в словаре. Сработает проверка \verb|nil| на
\verb|int?|, что приведёт к ошибке. Это тот случай, когда пустое значение
не равно его отсутствию.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
  {:address "https://clojure.org/"
   :description "Clojure Language"
   :status nil})
;; false
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status nil})
;; false
  \end{clojure}
\end{english}

\fi

\section{Вывод значений}

\label{spec-conform}

\index{вывод!значений}

До сих пор мы проверяли данные с помощью \verb|s/valid?|. Функция вернёт
истину или ложь, что значит~--- данные верны или нет. Но одной проверки
недостаточно: иногда значения корректны, но требуется привести их к~нужному
типу.

На вход поступило число в виде строки. Мы убедились, что строка состоит из цифр
и не превышает допустимой длины. После валидации значение по-прежнему строка, и
нужно парсить его вручную. Хотелось бы, чтобы типы вывел за нас какой-то
механизм.

\index{spec!conform}

\mnoindent
Spec предлагает такие возможности. Это функции \verb|s/conformer|
и~\verb|s/conform| (англ.~conform~--- <<подчиняться>>).

\label{spec-invalid}

\index{spec!conformer}

\index{spec!::invalid}

Сначала пишут функцию вывода. Она принимает исходное значение и возвращает либо
новое, либо ключ \verb|::s/invalid|, что означает ошибку. Затем функцию
оборачивают в \verb|s/conformer|, чтобы получить спеку. \verb|S/conform|
принимает спеку-конформер и данные. Если вывод прошёл без ошибок, получим новое
значение, а иначе~--- ключ \verb|::s/invalid|.

Рассмотрим вывод числа из строки. Чтобы отличить конформер от валидатора, к
имени добавляют стрелку, что означает приведение типа.

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (try
       (Integer/parseInt value)
       (catch Exception e
         ::s/invalid)))))
  \end{clojure}
\end{english}

\noindent
Эту спеку передают в \verb|s/conform| с данными:

\begin{english}
  \begin{clojure}
(s/conform ::->int "42") ;; 42

(s/conform ::->int "dunno")
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\index{исключения}

\verb|S/conform| не ловит исключения при работе, а вывод типов богат на
них. Будет правильно перехватить исключение и вернуть \verb|::s/invalid|, как
в примере выше.

Обе спеки~--- валидатор и конформер~--- можно объединить через \verb|s/and|,
чтобы проверить тип перед выводом. В нашем случае убедимся, что значение~---
строка. Так мы не допустим, чтобы в \verb|parseInt| попал \verb|nil| или
что-то другое:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and ::ne-string ::->int))

(s/conform ::->int nil)
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\index{веб-разработка!даты}

Рассмотрим, как восстановить из строки дату. Это старая проблема веб-разработки:
JSON не поддерживает даты, поэтому их передают строкой ISO или числом
секунд. Возникает вопрос, как привести их к~объекту на сервере.

\index{модули!clojure.instant}
\index{функции!read-instant-date}

\mnoindent
Понадобятся парсер строки и небольшая обвязка, чтобы подружить его со
спекой. Функция \verb|read-instant-date| из модуля \verb|clojure.instant|
читает дату из строки. Она лояльна к формату и учитывает разные
комбинации. Например, датой может быть только год.

\index{даты}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[clojure.instant
           :refer [read-instant-date]])

(read-instant-date "2019")
#inst "2019-01-01T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.instant :refer [read-instant-date]])

(read-instant-date "2019")
#inst "2019-01-01T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\fi

Обернём функцию в спеку:

\begin{english}
  \begin{clojure}
(s/def ::->date
  (s/and
   ::ne-string
   (s/conformer
    (fn [value]
      (try
        (read-instant-date value)
        (catch Exception e
          ::s/invalid))))))
  \end{clojure}
\end{english}

Перед разбором мы делаем минимальные проверки. Убеждаемся, что это не пустая
строка, чтобы отсечь \verb|nil| и прочий мусор. Вывод даты:

\begin{english}
  \begin{clojure}
(s/conform ::->date "2019-12-31")
#inst "2019-12-31T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\noindent
Дата и время:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/conform ::->date
           "2019-12-31T23:59:59")
#inst "2019-12-31T23:59:59.000-00:00"
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/conform ::->date "2019-12-31T23:59:59")
#inst "2019-12-31T23:59:59.000-00:00"
  \end{clojure}
\end{english}

\fi

\section{Спеки-перечисления}

\index{spec!перечисления}

Иногда известно заранее, какие значения принимает поле. Представим, при вызове
API клиент передаёт архитектуру системы~--- 32 или 64 бита. Ради двух значений
нет смысла парсить число: подойдёт \verb|case| или словарь.

Вариант с макросом \verb|case|. Если ничего не найдено, сигналим об ошибке
ключом \verb|::s/invalid|. Заметим, что \verb|case| не означает линейный
перебор. Он строит индексы веток и сразу переходит на нужную.

\index{clojure.core!case}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::->bits
  (s/conformer
   (fn [value]
     (case value
       "32" 32 "64" 64
       ::s/invalid))))

(s/conform ::->bits "32") ;; 32

(s/conform ::->bits "42")
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::->bits
  (s/conformer
   (fn [value]
     (case value
       "32" 32 "64" 64
       ::s/invalid))))

(s/conform ::->bits "32") ;; 32
(s/conform ::->bits "42") :clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\fi

\index{конфигурация}

Вариант со словарём для перевода значения. Удобно, что словарь живёт в
отдельной переменной. Его легко дополнить или вынести в~конфигурацию, при этом
логика валидации не изменится.

\begin{english}
  \begin{clojure}
(def bits-map {"32" 32 "64" 64})

(s/def ::->bits
  (s/conformer
   #(get bits-map % ::s/invalid)))
  \end{clojure}
\end{english}

Похожим образом читают логические значения из строк. Нет единого соглашения о
том, как передать истину и ложь в тексте. Это могут быть \verb|True|,
\verb|TRUE|, \verb|1|, \verb|yes| для истины и противоположности
\verb|FALSE|, \verb|no| и~другие. При разборе значений их приводят к одному
регистру. В~Clojure \verb|FALSE| и \verb|false|~--- это разные строки, даже если
отправитель имел в виду одно и то же. Сценарий выглядит так:

\begin{itemize}

\item
  убедиться, что значение~--- это строка;

\item
  привести её к нижнему регистру;

\item
  найти значение по словарю или \verb|case|.

\end{itemize}

\noindent
Код вывода:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ::ne-string
   (s/conformer
     clojure.string/lower-case)
   (s/conformer
    (fn [value]
      (case value
        ("true" "1" "on" "yes")
        true

        ("false" "0" "off" "no")
        false

        ::s/invalid)))))

  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ::ne-string
   (s/conformer clojure.string/lower-case)
   (s/conformer
    (fn [value]
      (case value
        ("true" "1" "on" "yes") true
        ("false" "0" "off" "no") false
        ::s/invalid)))))

  \end{clojure}
\end{english}

\fi

\noindent
Вывод в действии:

\begin{english}
  \begin{clojure}
(s/conform ::->bool "True") ;; true
(s/conform ::->bool "yes")  ;; true
(s/conform ::->bool "0")    ;; false
  \end{clojure}
\end{english}

\section{Продвинутые техники}

\index{паттерны}

Мы написали достаточно кода, чтобы увидеть одинаковые участки~--- паттерны. В
этом разделе мы вынесем их в функции и~макросы, которые ускорят вашу работу.

\subsection{Множества}

\index{множества}

Когда значения известны, на роль спеки подходит множество. Оно ведёт себя как
функция: если аргумент найден в множестве, получим его же. Если нет, результат
будет \verb|nil|. Представим, что статус задачи может быть строкой
\verb|todo|, \verb|in_progress| и \verb|done|. Опишем спеку множеством
этих значений:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::status
  #{"todo" "in_progres" "done"})
(s/valid? ::status "todo") ;; true
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::status #{"todo" "in_progres" "done"})
(s/valid? ::status "todo") ;; true
  \end{clojure}
\end{english}

\fi

Множества подходят и для точного равенства. Если спека принимает строго одно
значение, её по-прежнему можно задать множеством одного
элемента. Предположим, параметр \verb|notify| определяет, как часто уведомлять
пользователя. Пока что мы поддерживаем только тип \verb|daily|, поэтому
запишем спеку так:

\begin{english}
  \begin{clojure}
(s/def ::notification #{"daily"})
  \end{clojure}
\end{english}

\noindent
Это же выражение можно переписать на \verb|partial| от равенства:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::notification
  (partial = "daily"))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::notification (partial = "daily"))
  \end{clojure}
\end{english}

\fi

Плюс множества в том, что его легче расширить, вынести в~файл или конфигурацию.

\subsection{Перечисления}

\index{clojure.core!contains?}

Множество не подходит в случаях, когда \verb|false| и \verb|nil| считают
верными значениями. \verb|S/valid?| трактует их как неудачу. Если \verb|nil|
или \verb|false| допустимы, их проверяют функцией \verb|contains?|:

\begin{english}
  \begin{clojure}
(contains? #{1 :a nil} nil) ;; true
  \end{clojure}
\end{english}

Чтобы не повторяться, напишем функцию \verb|enum|. Она принимает значения и
возвращает предикат. В свою очередь, предикат принимает аргумент и проверяет,
есть ли такой среди исходных значений.

\begin{english}
  \begin{clojure}
(defn enum [& args]
  (let [arg-set (set args)]
    (fn [value]
      (contains? arg-set value))))
  \end{clojure}
\end{english}

Функция внутри замкнута на переменной \verb|arg-set|. Это множество, которое
получили из списка аргументов. Мы создали его один раз, чтобы не делать это
постоянно при вызове предиката. Новые перечисления выглядят коротко и ясно:

\begin{english}
  \begin{clojure}
(s/def ::status
  (enum "todo"
        "in_progres"
        "done"))
  \end{clojure}
\end{english}

\subsection{With-conformer}

\index{макросы!with-conformer}
\index{исключения!try}
\index{исключения!catch}

Конформеры требуют особого внимания. В них легко допустить ошибку: не
перехватить исключение или не обернуть функцию во вспомогательный
~\verb|s/conformer|. Чтобы снизить риск ошибки, вынесем рутину в~макрос
\verb|with-conformer|.

Макрос принимает символ переменной и произвольное тело. Он порождает функцию
одного аргумента, которая выполнит тело в блоке \verb|try/catch|. Если
исключения не было, получим последнее выражение тела. В~противном случае
вернётся \verb|::s/invalid|. Мы специально поместили символ в~квадратные скобки,
чтобы синтаксис напоминал функцию (\verb|defn|).

\begin{english}
  \begin{clojure}
(defmacro with-conformer
  [[bind] & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))))
  \end{clojure}
\end{english}

\noindent

Вывод числа:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def ->int
  (with-conformer [val]
    (Integer/parseInt val)))
  \end{clojure}

\splitter

  \begin{clojure}
(s/def ::->int
  (s/and ::ne-string
         ->int))
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

  \begin{clojure}
(def ->int
  (with-conformer [val]
    (Integer/parseInt val)))
  \end{clojure}

&

  \begin{clojure}
(s/def ::->int
  (s/and ::ne-string
         ->int))
  \end{clojure}

\end{tabular}

\end{english}

\fi

\noindent
и булева типа:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ->lower
   (with-conformer [val]
     (case val
       ("true"  "1" "on"  "yes")
       true

       ("false" "0" "off" "no" )
       false))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ->lower
   (with-conformer [val]
     (case val
       ("true"  "1" "on"  "yes") true
       ("false" "0" "off" "no" ) false))))
  \end{clojure}
\end{english}

\fi

\noindent
Переменная \verb|->lower|~--- это обёртка для приведения регистра:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def ->lower
  (s/and
    string?
    (s/conformer
      clojure.string/lower-case)))
  \end{clojure}
\end{english}
\else

\begin{english}
  \begin{clojure}
(def ->lower
  (s/and
    string?
    (s/conformer clojure.string/lower-case)))
  \end{clojure}
\end{english}

\fi

\mnoindent
В \verb|case| необязательно указывать \verb|::s/invalid| на конце
макроса. Если \verb|case| не нашёл ветку и не задан вариант по умолчанию,
он~бросит исключение. \verb|With-conformer| перехватит его и вернёт
\verb|::s/invalid|.

\section{Логические пути}

\index{spec!логические пути}

Функция \verb|s/conform| не всегда возвращает то, что мы ожидаем. Некоторые
спеки оборачивают результат в вектор, где первый элемент~--- логический путь. Он
появляется там, где проверка ветвится из-за условных спек.

Знакомый нам \verb|s/and| обходит дочерние спеки по порядку и проверяет
данные. Иногда линейного обхода недостаточно из-за развилки. Например, если
значение~--- число, то оставить его как есть, а~если строка, то привести
к~числу. Спеки, в которых проверка ветвится, называют условными
\eng{conditional}.

Макрос \verb|s/or| принимает теги и дочерние спеки. Он применяет их к значению
до первого совпадения. Результат будет парой, где первый элемент~--- тег, а
второй~--- значение из спеки, которая подошла.

Тег становится частью пути, по которому шла проверка. Логический путь помогает
расследовать, в каком месте произошла ошибка. Для простых спек это не проблема,
но на практике условная спека вложена в другую условную, та тоже и так
далее. Найти ошибку без логического пути будет трудно.

\index{spec!explain}

Если валидация не прошла, логический путь получают из отладочной информации. Её
возвращают функции семейства \verb|s/explain*|, которые мы рассмотрим ниже.

Напишем спеку сетевого порта, которая принимает число или строку. Во втором
случае спека выводит число. Это полезно, если значение приходит из переменной
среды или INI-файла.

\begin{english}
  \begin{clojure}
(s/def ::smart-port
  (s/or :string ::->int :num int?))
  \end{clojure}
\end{english}

\noindent
Теперь \verb|s/conform| вернёт не просто значение, а пару с тегом:

\begin{english}
  \begin{clojure}
(s/conform ::smart-port 8080)
[:num 8080]

(s/conform ::smart-port "8080")
[:string 8080]
  \end{clojure}
\end{english}

\index{скаляры}
\index{spec!развилки}

Если в спеке была развилка (\verb|s/or|, \verb|s/alt|), то структура
\verb|s/conform| отличается от входных данных: на месте скаляра появится
вектор. Покажем это на вложенных данных. Пусть порт~--- одно из полей
подключения к базе:

\begin{english}
  \begin{clojure}
(s/def :conn/port ::smart-port)
(s/def ::conn
  (s/keys :req-un [:conn/port]))

(s/conform ::conn {:port "9090"})
{:port [:string 9090]}
  \end{clojure}
\end{english}

Топология результата изменилась, и это нужно учесть. Если передать поле
\verb|:port| в подключение, получим ошибку типов.

\section{Обратное действие}

\index{spec!unform}

У функции \verb|unform| противоположный смысл: по спеке и результату она
вернёт исходное значение. Выше мы получили словарь, где поле \verb|:port|~--- это
вектор. Чтобы вернуться к исходным данным, выполните:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:num 9090]})
{:port 9090}
  \end{clojure}
\end{english}

\noindent
Если передать пару со строкой, получим ошибку:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
;;Execution error (IllegalStateException)
;;no unform fn for conformer
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
;; Execution error (IllegalStateException)
;; no unform fn for conformer
  \end{clojure}
\end{english}

\fi

Дело в том, что тегу \verb|:num| мы задали предикат. Он ничего не выводит,
поэтому для предиката \verb|unform| отбросит тег и вернёт значение. Тег
\verb|:string| указывает на спеку типа \verb|conformer|, которая
\emph{меняет} значение. Чтобы выполнить \verb|unform|, нужно сказать ей, как
это делается.

\index{spec!conformer}

Первый аргумент \verb|s/conformer|~--- это функция вывода типа. К ней обращается
\verb|s/conform|, когда его вызывают. Второй необязательный аргумент~--- это
функция с обратным эффектом: по результату \verb|conform| вернуть прежнее
значение. Функция сработает в момент \verb|s/unform|.

Изменим \verb|::->int|, чтобы он поддерживал \verb|unform|:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (s/conformer
    (fn [string]
      (Integer/parseInt string))
    (fn [integer]
      (str integer)))))
  \end{clojure}
\end{english}

\noindent
Теперь порт со строкой не вызовет ошибки:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
{:port "9090"}
  \end{clojure}
\end{english}

\verb|Unform| полезен, если вы утратили исходные данные, но сохранили их
\verb|conform|-вариант.

Читатель заметит, что нашей целью было вывести порт из строки, однако из-за
\verb|conform| и \verb|unform| всё пошло не так. \verb|Conform| вывел тип,
но добавил в результат теги, из-за чего изменилась структура. \verb|Unform|
убрал теги, но вернул строку на место числа. В чём смысл?

Если коротко, \verb|conform| и теги незаменимы для парсинга данных и их
обхода. Далее мы покажем, как с помощью \verb|conform| получить синтаксическое
дерево, без которого не обходится ни один компилятор. Что касается
\verb|unform|, его поведение можно исправить хитростью.

В спеке \verb|::->int| в \verb|unform|-части мы переводим число в обратно
строку. Если вернуть число без изменений, оно встанет на место \verb|:port| в
итоговом словаре:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (s/conformer
    (fn [string]
      (Integer/parseInt string))
    (fn [integer]
      integer))))

(s/unform ::conn {:port [:string 9090]})
{:port 9090}
  \end{clojure}
\end{english}

\index{clojure.core!identity}

Для краткости вторым аргументом указывают \verb|identity|~--- функцию, которая
возвращает переданный аргумент. С таким подходом \verb|unform| всегда
вернёт то, что получили на этапе \verb|conform|. Полный цикл
\verb|conform| и \verb|unform|:

\begin{english}
  \begin{clojure}
(->> {:port "9090"}
     (s/conform ::conn)
     (s/unform ::conn))
{:port 9090}
  \end{clojure}
\end{english}

Чтобы не забыть \verb|unfrom| в спеке, сделайте его частью макроса
\verb|with-conformer|:

\begin{english}
  \begin{clojure}
(defmacro with-conformer
  [[bind] & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))
    identity))
  \end{clojure}
\end{english}

\section{Анализ ошибок}

\index{ошибки!spec}

\label{spec-explain}

Когда данные неверны, \verb|s/valid?| и \verb|s/conform| возвращают \verb|false|
и~\verb|::s/invalid|. Этого недостаточно, чтобы понять причину
ошибки. Представьте, что у вас спека пользователя. В ней несколько адресов,
в~каждом адресе несколько строк, и проверка вернула \verb|false|. Ручной поиск
ошибки займёт час.

Функции семейства \verb|s/explain| принимают спеку и данные. Если проверка не
удалась, получим отчёт. Это словарь, где указаны проблемные значения, спеки,
пути к ним и другие данные. Разница между функциями в том, как они поступают с
отчётом:

\begin{itemize}

\index{spec!explain}
\index{spec!explain-str}
\index{spec!explain-data}
\index{spec!отчёт}
\index{отчёт!spec}

\item
  \verb|s/explain| печатает его в стандартный поток (на экран);

\item
  \verb|s/explain-str| возвращает отчёт в виде строки;

\item
  \verb|s/explain-data| возвращает словарь. Это самый полный отчёт об~ошибке.

\end{itemize}

Попробуем функции в действии. Подготовим для них простую спеку:

\begin{english}
  \begin{clojure}
(s/def :sample/username ::ne-string)

(s/def ::sample
  (s/keys :req-un [:sample/username]))
  \end{clojure}
\end{english}

\noindent
На корректных данных функции не проявляют себя:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain ::sample
  {:username "some user"})
Success!
nil

(s/explain-data ::sample
  {:username "some user"})
nil
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username "some user"})
Success!
nil

(s/explain-data ::sample {:username "some user"})
nil
  \end{clojure}
\end{english}

\fi

\noindent
Попробуем число вместо имени:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username 42})
;; 42 - failed: string? in: [:username]
;; at: [:username] spec: ::string
  \end{clojure}
\end{english}

Вывод читается так: значение \verb|42| не прошло проверку предикатом
\verb|string?|. Путь к значению внутри словаря \verb|[:username]|. Ключ
спеки, где случилась ошибка,~--- \verb|::string|.

Отчёт показывает наиболее вложенные спеки и предикаты. Вспомним, что
\verb|::ne-string|~--- это комбинация \verb|::string| и
\verb|not-empty|. Ошибка случилась на этапе \verb|::string|, о чём и было
сказано.

Для пустой строки вывод будет другим. На этот раз причиной станет
\verb|not-empty|. Проверим это:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username ""})
;; "" - failed: not-empty in: [:username]
;; at: [:username] spec: ::ne-string
  \end{clojure}
\end{english}

\verb|Explain|~--- это быстрый способ сообщить о проблеме в конфигурации или
JSON-файле. Со временем вы научитесь читать его. Но чем сложнее данные, тем
меньше понятен \verb|explain|. Когда в коллекции больше трёх уровней,
отчёт заливает экран. Трудно даже разбить его на части, не говоря уж о
понимании. Чтобы подружиться с \verb|explain|, нужно промежуточное звено, о
котором речь в следующем разделе.

\section{Понятные ошибки}

\index{сообщения}
\index{spec!ошибки}

\label{spec-messages}

Когда проверяют данные, важен не только факт ошибки. Ещё важнее объяснить
клиенту, где именно он ошибся. Под клиентом не обязательно имеют в виду
человека. Даже если это другая программа, в~ответ добавляют понятный текст. Он
попадёт в логи, которые читают сотрудники.

Часто мы видим сообщения вроде <<Ошибка: DATAERROR>> без каких-либо деталей. Или
красную надпись <<проверьте данные>> над формой в два экрана. Этих глупостей
можно было избежать, умей программисты переводить язык машины на человеческий.

\index{интерфейс}
\index{пользователь}

Фраза \texttt{"" - failed: not-empty in: [:user\-name]} не только ничего не скажет
пользователю, но и отпугнёт его машинной природой. Кажется, что в интерфейсе
возникла брешь и пользователь видит то, что не должен. Это резко снижает
доверие к системе.

Чтобы составить сообщение, вернёмся к функции \verb|s/explain-data|. Она
возвращает словарь с полной информацией о неудаче. Пример такого отчёта:

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username ""})

#:clojure.spec.alpha
{:problems
 ({:path [:username]
   :pred clojure.core/not-empty
   :val ""
   :via [::sample ::ne-string]
   :in [:username]})
 :spec ::sample
 :value {:username ""}}
  \end{clojure}
\end{english}

\index{языки!Python}
\index{языки!JavaScript}

На первый взгляд непонятно, что с ним делать. Некоторые программисты сдаются и
говорят, что Spec не подходит для ошибок. Это не так: в отчёте все
необходимые данные, нужно только правильно их обработать.

Новички спрашивают: почему бы не сделать понятные сообщения на уровне
библиотеки? Например, назначить спеке поле с текстом <<введите правильный
адрес>>? Почему не взять пример с библиотек для Python или JavaScript?

\index{фундаментальность}

Ответ на этот вопрос не устраивает новичков. Вспомним тезис из начала главы:
Spec~--- это \emph{фундаментальная библиотека}. То, что мы проверяем ей поля
формы,~--- всего лишь частный случай. У~спеки разные области применения, поэтому
структура ошибки тоже фундаментальна.

Трудно создать систему ошибок, которая устроит всех. В каждом проекте свои
правила о том, как показывать ошибки. Иногда это фиксированное сообщение, а в
других случаях~--- шаблон. Где-то учитывают язык пользователя. Всё вместе это
сложные сценарии.

Если бы разработчики Spec занялись ошибками, их фокус был бы смещён с главной
цели. Вместо Spec мы получили бы валидаторы по типу тех, что пишут десятками для
Python и JavaScript. Они скучны, не гибки и без концепции.

Словарь \verb|explain-data| содержит ключи \verb|:spec|, \verb|:value| и
\verb|:problems| с пространством \verb|clojure.spec.alpha|. Первые два~--- это
спека и значение, которые приняли участие в проверке. Нас интересует
\verb|:problems|. Это список словарей, где каждый описывает ошибку
валидации. Перечислим их поля и семантику:

\index{spec!развилки}

\begin{itemize}

\item
  \verb|:path|~--- логический путь валидации. Вектор ключей, где спеки
  чередуются с тегами-развилками. Условные спеки вроде \verb|s/or| пишут сюда
  свои метки;

\item
  \verb|:pred|~--- символ предиката, например \verb|clojure.core/string?|;

\item
  \verb|:val|~--- значение, для которого предикат вернул ложь (число,
  \verb|nil|, коллекция);

\item
  \verb|:via|~--- вектор спек, по которым прошло значение от верхнего уровня к
  нижнему;

\item
  \verb|:in|~--- физический путь к значению. Вектор ключей и индексов, который
  передают в функцию \verb|get-in|. Если выполнить \verb|(get-in <данные> <:in>)|,
  получим значение, которое вызвало ошибку.

\end{itemize}

В отчёте всё, что нам нужно. Из \verb|:val| возьмём проблемное
значение. Спека, на которой остановилась валидация~--- это последний элемент вектора
\verb|:via|.

Составим словарь, где ключ~--- спека, а значение~--- понятный текст или
шаблон. Зная спеку, которая вызвала ошибку, получим из словаря текст. В нашем
случае последний элемент \verb|:via|~--- это \verb|::ne-string|. Назначим ей
сообщение <<Строка не должна быть пустой>> или что-то похожее.

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string
   "Строка не должна быть пустой"})
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"})
  \end{clojure}
%% \end{english}

\fi

\mnoindent
Напишем функцию, которая принимает словарь ошибки (один из элементов
\verb|::s/problems|) и возвращает сообщение:

\index{функции!get-message}

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(defn get-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (get spec-errors spec)))

(get-message {:via [::sample
                    ::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(defn get-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (get spec-errors spec)))

(get-message {:via [::sample ::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

\fi

Функция \verb|peek| похожа на \verb|last| (получить последний
элемент). Разница в том, что \verb|last| бежит от начала коллекции, что
неэффективно. \verb|Peek|~--- это версия \verb|last| для вектора, которая сразу
прыгает в конец.

Проверим способ на других полях. Добавим в спеку \verb|::sample| адрес почты:

\index{регулярные выражения}
\index{clojure.core!re-matches}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::email
  (s/and
    ::ne-string
    (partial re-matches
      #"(.+?)@(.+?)\.(.+?)")))

(s/def :sample/email ::email)

(s/def ::sample
  (s/keys :req-un [:sample/username
                   :sample/email]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::email
  (s/and
   ::ne-string
   (partial re-matches #"(.+?)@(.+?)\.(.+?)")))

(s/def :sample/email ::email)

(s/def ::sample
  (s/keys :req-un [:sample/username
                   :sample/email]))
  \end{clojure}
\end{english}

\fi

Спека \verb|::email| проверяет, что строка не пустая и совпадает с~шаблоном
адреса. Шаблон требует, чтобы в строке были символ~\verb|@| и~точка, а~между
ними произвольные символы.

\mnoindent
Если передать в \verb|email| пустую строку, последним элементом \verb|via|
будет \verb|::ne-string|. Для экономии места сократим вывод
\verb|explain-data|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::sample
  {:username "test" :email ""})

{:path [:email]
 :pred clojure.core/not-empty
 :val ""
 :via [::sample ::email ::ne-string]
 :in [:email]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username "test" :email ""})

{:path [:email]
 :pred clojure.core/not-empty
 :val ""
 :via [::sample ::email ::ne-string]
 :in [:email]}
  \end{clojure}
\end{english}

\fi

Вызов \verb|get-message| с этой ошибкой вернёт сообщение о пустой
строке. Попробуем почту, которая не совпала с шаблоном. Последним элементом
\verb|:via| станет \verb|:sample/email|. Словарь ошибки выглядит так:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::sample
  {:username "test" :email "test"})

{:path [:email]
 :pred
 (clojure.core/partial
  clojure.core/re-matches
  #"(.+?)@(.+?)\.(.+?)")
 :val "test"
 :via [::sample ::email]
 :in [:email]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username "test" :email "test"})

{:path [:email]
 :pred
 (clojure.core/partial
  clojure.core/re-matches
  #"(.+?)@(.+?)\.(.+?)")
 :val "test"
 :via [::sample ::email]
 :in [:email]}
  \end{clojure}
\end{english}

\fi

Чтобы \verb|get-message| вернул новое сообщение, добавим в словарь ключ
\verb|::email|:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string
   "Строка не должна быть пустой"
   ::email
   "Введите правильный почтовый адрес"})
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   ::email "Введите правильный почтовый адрес"})
  \end{clojure}
%% \end{english}

\fi

\index{перевод}
\index{языки!ClojureScript}

Осталось наполнить его другими спеками и сообщениями, пока не покроем все
варианты. Система переводов, которую мы построили, довольно проста. Её легко
тестировать и менять под нужды конкретного проекта. Доработанные версии этой
системы работают в бою. В одной из них формы проверяют на клиенте до отправки на
сервер. Сообщение для виджетов получают тем же способом. Это возможно, поскольку
мощь Spec в полной мере доступна в ClojureScript.

Далее рассмотрим, как улучшить систему переводов.

\subsubsection{Сообщение по умолчанию}

Что случится, если перевода нет в словаре? В этом случае вернём нейтральное
<<исправьте ошибку в данных>>. Заодно запишем в лог событие с именем спеки. Лог
настроен так, что сообщения из модуля переводов оседают в отдельном файле. Позже
локализаторы прочтут его и~добавят перевод.

%% \begin{english}
  \begin{clojure}
(def default-message
  "Исправьте ошибку в данных")
  \end{clojure}
%% \end{english}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn get-better-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (do
          (log/warnf
            "Missing message for spec %s"
            spec)
          default-message))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn get-better-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (do (log/warnf "Missing message for spec %s" spec)
            default-message))))
  \end{clojure}
\end{english}

\fi

\noindent
Для любой незнакомой спеки получим нейтральное сообщение. В~комментарии показан
лог, который возникнет в консоли при вызове:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(get-better-message
    {:via [::unknown :unknown/field]})
;; WARN book.spec - Missing message for
;; spec :unknown/field
"Исправьте ошибки в поле"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(get-better-message {:via [::unknown :unknown/field]})
;; WARN book.spec - Missing message for spec :unknown/field
"Исправьте ошибки в поле"
  \end{clojure}
%% \end{english}

\fi

\subsubsection{Восходящий поиск}

До сих пор мы работали с последним элементом вектора \verb|:via|. Давайте
рассмотрим его в целом. Для этого спровоцируем \verb|s/explain-data| с~пустой
почтой. В поле \verb|:via| окажется цепочка:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::sample
  {:username "test" :email ""})

;; :via field
[::sample ::email ::ne-string]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username "test" :email ""})
[::sample ::email ::ne-string] ;; :via field
  \end{clojure}
\end{english}

\fi

Её читают так: ошибка в образце из-за почты \arr{} ошибка в почте из-за
пустой строки. Очевидно, спеки убывают по старшинству: на первом месте
глобальный объект, на последнем~--- локальная проблема. Из убывания можно
извлечь пользу: искать перевод не строго последней спеки, а по нарастанию
важности. Сперва проверить \verb|::ne-string|, затем \verb|::email| и, если
ничего не нашли, \verb|::sample|. Назовём метод восходящим поиском.

\index{clojure.core!keep}

В отличие от прошлых решений, мы ищем перевод для каждого элемента в обратном
порядке. Функции \verb|reverse| и \verb|keep| порождают ленивые коллекции,
поэтому вычислений не происходит, пока мы не обратимся к ним. В качестве
результата вернём первый не пустой элемент.

\begin{english}
  \begin{clojure}
(defn get-message
  [problem]
  (let [{:keys [via]} problem]
    (->> via
         reverse
         (keep spec-errors)
         first)))
  \end{clojure}
\end{english}

Преимущество метода в том, что он сохраняет нужную детализацию
сообщений. Например, \verb|::email| может состоять из нескольких мелких спек,
однако из-за их низкого уровня сообщение будет непонятным. Для более ясного
перевода удалим из-словаря \verb|::ne-string| и оставим \verb|::email|.

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::email
   "Введите правильный почтовый адрес"})

(get-message
  {:via [::sample ::email ::ne-string]})
"Введите правильный почтовый адрес"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::email "Введите правильный почтовый адрес"})

(get-message {:via [::sample ::email ::ne-string]})
"Введите правильный почтовый адрес"
  \end{clojure}
%% \end{english}

\fi

Если в \verb|::sample| появится поле, для которого забыли перевод, поиск
разрешится в \verb|::sample|. Назначим ей общий перевод вроде <<образец
заполнен неверно>>, чтобы локализовать проблему. Это полезно, если
\verb|::sample| станет элементом другой спеки, та~--- ещё одной и так далее.

\subsubsection{Сходимость}

Чтобы объяснить, что такое сходимость и как ей управлять, объявим спеки книги и
фильма с одним полем~--- описанием:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :book/description ::ne-string)
(s/def ::book
  (s/keys :req-un [:book/description]))

(s/def :movie/description ::ne-string)
(s/def ::movie
  (s/keys :req-un [:movie/description]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :book/description ::ne-string)
(s/def ::book (s/keys :req-un [:book/description]))

(s/def :movie/description ::ne-string)
(s/def ::movie (s/keys :req-un [:movie/description]))
  \end{clojure}
\end{english}

\fi

Если передать в описание пустую строку, в векторе \verb|:via| будет следующее:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::book
  {:description ""})
[::book ::ne-string]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::book {:description ""})
[::book ::ne-string]
  \end{clojure}
\end{english}

\fi

Заметим, что в векторе нет спеки \texttt{:book/de\-scription}. Это значит, не
получится составить сообщение специально для этого поля, например <<неверное
описание книги>>. Аналогично ведёт себя \verb|::movie|: если передать
пустую строку, на конце via будет спека \verb|::ne-string|.

\mnoindent
Выражение \texttt{(s/def :book/description ::ne\--string)}~--- это
ссылка. Когда одна спека ссылается на другую, Spec укорачивает цепь, чтобы сразу
достичь \verb|::ne-string|. Говорят, что спеки \verb|:book/description|
и~\verb|:movie/description| \emph{сходятся} в \verb|::ne-string|. Иногда у
сходимости преимущества: можно задать перевод для \verb|::ne-string| и ссылаться
на неё во всех полях с текстом. В случаях, когда важен путь \verb|:via|, спеку
реорганизуют.

\mnoindent
Один из способов это сделать~--- заменить ссылку на предикат. Перепишите
\verb|:book/description|, как в примере ниже:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def ne-string
  (every-pred string? not-empty))
(s/def :book/description ne-string)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def ne-string (every-pred string? not-empty))
(s/def :book/description ne-string)
  \end{clojure}
\end{english}

\fi

\mnoindent
Теперь описание ссылается не на \verb|::ne-string|, а на предикат с~таким же
именем. Ниже \verb|:book/description| уже не будет спек. Если
\verb|ne-string| вернёт ложь, \verb|:book/description| станет последним
элементом \verb|:via|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::book
  {:description ""})
{:via [::book :book/description]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::book {:description ""})
{:via [::book :book/description]}
  \end{clojure}
\end{english}

\fi

То же самое с фильмом: укажите в спеке \verb|:movie/description| предикат
\verb|ne-string|, и она появится в \verb|:via| при ошибке. Добавьте спекам
отдельные переводы и выполните поиск, как мы делали выше.

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {:book/description
   "Введите описание книги"
   :movie/description
   "Введите описание фильма"})

(get-message
  {:via [::book :book/description]})
"Введите описание книги"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {:book/description "Введите описание книги"
   :movie/description "Введите описание фильма"})

(get-message {:via [::book :book/description]})
"Введите описание книги"
  \end{clojure}
%% \end{english}

\fi

Другой способ повлиять на сходимость~--- обернуть ключ спеки в~функцию
\verb|s/spec|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :book/description
  (s/spec ::ne-string))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :book/description (s/spec ::ne-string))
  \end{clojure}
\end{english}

\fi

При такой записи спека \verb|:book/description| заменит \verb|::ne-string|
в~векторе \verb|:via|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::book
  {:description ""})
[:book.spec/book :book/description]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::book {:description ""})
[:book.spec/book :book/description]
  \end{clojure}
\end{english}

\fi

Преимущество \verb|s/spec| в том, что нужно только обернуть ссылки, а~предикаты
и~остальной код останутся без изменений.

\subsubsection{Гибкий поиск}

Решим обратную задачу. Предположим, в проекте много сущностей с~описанием:
книги, фильмы, игры и так далее. Хотелось бы, чтобы описания
\verb|:movie/description|, \texttt{:book/descrip\-tion} и остальные сходились к
переводу <<неверное описание>>. Как это сделать, не добавляя каждую спеку в
перевод?

Чтобы не засорять словарь, пойдём на хитрость. Пусть функция ищет перевод по
полному ключу, а если его нет, то по имени. Тогда хватит ключа
\verb|:description|, чтобы все спеки сошлись в этот перевод. Если для
конкретного \verb|:book/description| нужна особая фраза, добавим полную
версию:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {:description
   "Неверное описание"
   :book/description
   "Введите описание книги"})
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {:description "Неверное описание"
   :book/description "Введите описание книги"})
  \end{clojure}
%% \end{english}

\fi

Обновим поиск с учётом неполного ключа и фразы по умолчанию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn get-message
  [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (get spec-errors
          (-> spec name keyword))
        default-message)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn get-message
  [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (get spec-errors (-> spec name keyword))
        default-message)))
  \end{clojure}
\end{english}

\fi

\noindent
В действии:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(get-message
  {:via [::movie :movie/description]})
"Неверное описание"

(get-message
  {:via [::movie :book/description]})
"Введите описание книги"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(get-message {:via [::movie :movie/description]})
"Неверное описание"

(get-message {:via [::movie :book/description]})
"Введите описание книги"
  \end{clojure}
%% \end{english}

\fi

\subsubsection{Мультиметод}

Возможно, система переводов понравится вашим коллегам, и они захотят её
использовать. Разумно вынести код в библиотеку и подключить в зависимости. Тогда
проекты будут одинаковы в плане сообщений.

Минус словаря в том, что его трудно расширить со стороны. Чтобы добавить
перевод, нужно выпустить новую версию библиотеки и обновить зависимости, что в
целом долго. Предоставим клиентам только механизм перевода, а содержимое они
наполнят сами.

Для этого заменим словарь на мультиметод. Его диспатчер принимает словарь ошибки
и находит виновную спеку. Далее расширим мультиметод спеками. С таким подходом
каждый добавит свои переводы или заменит чужие, если они не подошли.

\mnoindent
Объявим мультиметод с переводом \verb|::ne-string|:

\index{мультиметоды!problem\arr{}text}

%% \begin{english}
  \begin{clojure}
(defmulti problem->text
  (fn [{:keys [via]}]
    (peek via)))

(defmethod problem->text ::ne-string [_]
  "Строка не должна быть пустой")
  \end{clojure}
%% \end{english}

\noindent
Пример его работы:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(problem->text
  {:val "" :via [::email ::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(problem->text {:val "" :via [::email ::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

\fi

Ключ \verb|:default| отвечает за действие по умолчанию. Если перевод не
найден, вернём стандартную фразу:

\begin{english}
  \begin{clojure}
(defmethod problem->text :default [_]
  default-message)
  \end{clojure}
\end{english}

\index{наследование}

Вспомним сообщение для описания. Хотелось бы, чтобы обе спеки~---
\verb|:book/description| и \verb|:movie/description|~--- сходились в общий перевод
\verb|::description|, но так, чтобы можно было задать им частный перевод. Это
возможно с помощью иерархии ключей. Если у мультиметода нет ключа, но ключ
наследует родителя, мультиметод выполнит поиск для родителя.

\mnoindent
Для этого унаследуем ключ \verb|:book/description| от
\verb|::description|. Если ошибка случится в спеке \verb|:book/description|,
получим общий перевод для любого описания.

\index{clojure.core!derive}

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(defmethod problem->text
  ::description [_] "Введите описание")

(derive :book/description ::description)

(problem->text
  {:val "" :via [:book/description]})
"Введите описание"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(defmethod problem->text ::description [_]
  "Введите описание")

(derive :book/description ::description)

(problem->text {:val "" :via [:book/description]})
"Введите описание"
  \end{clojure}
%% \end{english}

\fi

\noindent
Если нужен особый перевод, расширим мультиметод:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(defmethod problem->text
  :book/description [_]
  "Введите описание книги")

(problem->text
  {:val "" :via [:book/description]})
"Введите описание книги"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(defmethod problem->text :book/description [_]
  "Введите описание книги")

(problem->text {:val "" :via [:book/description]})
"Введите описание книги"
  \end{clojure}
%% \end{english}

\fi

\index{синтаксис!\textbf{\_} (затенение)}

Заметим, что каждый метод принимает словарь ошибки. Мы затенили его символом
\verb|_|, потому что не обращаемся к нему и не хотим порождать лишнюю
переменную. В особых случаях можно построить фразу в зависимости от полей
ошибки. Например, добавить текущее значение:

\ifx\devicetype\mobile

%% \begin{english}
  \begin{clojure}
(defmethod problem->text
  :book/description
  [{:keys [val]}]
  (format "Ошибка в описании книги: %s"
    val))

(problem->text
  {:val "abc" :via [:book/description]})
"Ошибка в описании книги: abc"
  \end{clojure}
%% \end{english}

\else

%% \begin{english}
  \begin{clojure}
(defmethod problem->text :book/description
  [{:keys [val]}]
  (format "Ошибка в описании книги: %s" val))

(problem->text {:val "abc" :via [:book/description]})
"Ошибка в описании книги: abc"
  \end{clojure}
%% \end{english}

\fi

\emph{Замечание:} функция \verb|derive| с двумя аргументами порождает
глобальное наследование ключей. Это может повлиять на другие части программы,
где логика зависит от наследования. В Clojure пользуются локальными иерархиями
ключей. Изучите, что представляет собой третий аргумент \verb|derive| и как им
пользоваться в паре с мульмитеметодом.

\subsubsection{Шаблон}

\index{шаблоны}

Если варианты выше показались вам сложными, попробуйте сообщение по~шаблону. Оно
складывается из имени поля и значения, например: <<в~поле email неверное
значение test>>. Сообщение легко получить функцией \verb|format|. В нём
слышится машинная природа, зато способ быстрый и дешёвый.

Имя поля получим как последний кейворд поля \verb|:in|. Почему бы не взять
просто последний элемент? Вспомним, что \verb|:in|~--- это физический путь к данным,
который передают в функции \verb|get-in|, \verb|assoc-in| и~другие. Его
элементами могут быть не только кейворды для вложенных словарей, но и индексы
для векторов.

Приведём пример, когда \verb|:in| заканчивается на число. Пусть задана
спека \verb|::post| для публикации в блоге. Кроме заголовка у записи могут
быть теги, набор не пустых строк:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :post/title ::ne-string)
(s/def :post/tags
  (s/coll-of ::ne-string))
(s/def ::post
  (s/keys :req-un [:post/title]
          :opt-un [:post/tags]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :post/title ::ne-string)
(s/def :post/tags (s/coll-of ::ne-string))
(s/def ::post (s/keys :req-un [:post/title]
                      :opt-un [:post/tags]))
  \end{clojure}
\end{english}

\fi

Предположим, один из тегов оказался пустым, что не имеет смысла. Привёдем
сокращённый отчёт \verb|s/explain-data|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/explain-data ::post
  {:title "On Clojure"
   :tags ["clojure" ""]})

{:path [:tags]
 :pred clojure.core/not-empty
 :val ""
 :via [:book.spec/post
       :post/tags
       :book.spec/ne-string
       :book.spec/not-empty]
 :in [:tags 1]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/explain-data ::post {:title "On Clojure"
                        :tags ["clojure" ""]})

{:path [:tags]
 :pred clojure.core/not-empty
 :val ""
 :via [:book.spec/post
       :post/tags
       :book.spec/ne-string
       :book.spec/not-empty]
 :in [:tags 1]}
  \end{clojure}
\end{english}

\fi

Последний элемент 1 указывает на второй проблемный тег, что верно. Чтобы узнать
имя поля, которое привело к ошибке, поднимемся на уровень выше и получим
\verb|:tags|. Значение, которое не прошло валидацию, находится в поле
\verb|:val|. Этого достаточно, чтобы построить фразу:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn get-common-message
  [problem]
  (let [{:keys [in val]} problem
        field (->> in
                   reverse
                   (filter keyword?)
                   first)]
    (format
      "The field '%s' has
                an incorrect value '%s'."
      (name field) val)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn get-common-message
  [problem]
  (let [{:keys [in val]} problem
        field (->> in
                   reverse
                   (filter keyword?)
                   first)]
    (format "The field '%s' has an incorrect value '%s'."
            (name field) val)))
  \end{clojure}
\end{english}

\fi

Поле и значение заключим в кавычки, чтобы выделить из общего текста. Проверим,
что вернёт функция:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(get-common-message
  {:val "" :in [:tags 1]})
"The field 'tags' has
          an incorrect value ''."
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(get-common-message {:val "" :in [:tags 1]})
"The field 'tags' has an incorrect value ''."
  \end{clojure}
\end{english}

\fi

Если поле множественное, одного имени недостаточно. Сообщение станет лучше, если
добавить индекс значения с~ошибкой, например \verb|'tags[1]'|. Подумайте, как
найти последовательность \tuple{кейворд, число}, и~доработайте алгоритм.

\subsection{Открытые вопросы}

За рамками остались несколько вопросов. Они слишком общие, чтобы претендовать на
конкретное решение. В этом разделе мы не будем писать код, а только
порассуждаем.

Что делать, если требуется локализация, то есть текст на русском или английском
в зависимости от настроек? Переделаем словарь ошибок. В нём станет два уровня:
на первом~--- код локали (\verb|ru|, \verb|en|), а на втором~--- переводы спек.

\index{локаль}
\index{перевод}

По локали мы получим словарь переводов, затем переводим сообщение, как делали
выше. С кодом локали можно схитрить, чтобы облегчить поиск. Для отдельных фраз
выделяют более точные локали, например американский и британский диалекты
с~кодами \verb|en_US| и~\verb|en_GB|. Изменим поиск так, что сперва он ищет
по младшей локали (\verb|en_US|), а затем по старшей (\verb|en|). Если
британского текста не оказалось, получим общий английский. Так работает перевод
сообщений в~широком смысле, не только ошибок.

Вопрос, откуда читать локаль, остаётся на ваше усмотрение. Можно хранить её в
сессии, параметрах запроса, базе данных, словом~--- как это удобно в проекте. Мы
ещё вернёмся к теме перевода строк в главе про изменяемость \page{translate}.

Второй вопрос~--- как связать ошибки с интерфейсом. Модель отделяют от
представления, и формы следуют этому правилу. Удобно, когда форма~--- это структура
данных. Операции над ней~--- это чистые функции, которые легко поддерживать. Каждая
функция возвращает форму в новом состоянии.

Представим форму в виде дерева. Ключи~--- это поля, а значения~--- виджеты. Виджет
содержит тип поля, текущее значение и ошибку. На каждый виджет подписан
React-компонент. При изменении виджета он рисует поле ввода с текущим
значением. Если ошибка не \verb|nil|, над полем появится красное сообщение.

Валидация принимает форму и строит дерево значений. У него такая же топология, но
на месте виджетов значения полей ввода. С~помощью спеки мы проверяем значения и
выводим типы из строк. В~случае ошибки получим отчёт \verb|explain|. Для
каждого элемента из поля \verb|problems| находим путь, спеку и сообщение об
ошибке. Это сообщение добавляем виджету в поле \verb|:error|. Компонент,
который подписан на виджет, заново отрисует его с ошибкой над полем.

\index{интерфейс}
\index{фреймворки!React}

Мы упомянули формы, React и проблемы интерфейса. Всё вместе это называется
\emph{фронтенд}. Мы не будем на нём останавливаться, потому что фронтенд~---
сложная тема, достойная отдельной книги.

\section{Парсинг}

Мы научились проверять данные и выводить типы. Перейдём к более сложной
операции~--- парсингу. Под термином понимают разбор данных на части, поиск
структуры там, где прежде её не было.

Возможно, вам приходилось писать регулярные выражения. Это шаблоны, которые
описывают структуру текста. Специальные функции принимают строку и регулярное
выражение. Они возвращают фрагменты текста, которые совпали с шаблоном.

Пример регулярного выражения~--- это IP-адрес. Он состоит из четырёх групп с
точками. Каждая группа~--- это число от 0 до 255.

\index{парсинг}
\index{регулярные выражения}

\begin{english}
  \begin{text}
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
  \end{text}
\end{english}

В шаблоне мы ставим косую черту перед точкой. Без слеша точка означает любой
символ. Чтобы сослаться именно на символ точки, её экранируют.

В регулярных выражениях применяют операторы \verb|+|, \verb|?|, \verb|*| и
другие. Они указывают, сколько раз встречается шаблон перед ними: один и~более
раз, ни одного или один, произвольное число. В зависимости от оператора шаблон
захватывает разные части текста.

Представьте, что регулярные выражения откусывают строку частями. Та часть, что
легла на шаблон, уходит в результат. Остаток переходит к следующему шаблону, и
так далее.

Регулярные выражения подводят нас к \verb|regex|-спекам. Это особые спеки для
разбора данных по шаблону. Разница в том, что входные данные~--- это коллекции, а не
текст.

\index{spec!regex}

\subsection{Простой разбор}

Предположим, нужно разобрать массив пользователей. Каждый из них~--- это кортеж вида
\tuple{номер, почта, статус}. Все значения~--- строки. Для каждого пользователя
требуется:

\begin{itemize}

\item
  убедиться, что в кортеже именно три элемента;

\item
  привести номер к числу;

\item
  проверить почту на минимальные критерии;

\item
  привести статус к перечислению;

\item
  получить словарь с верными значениями.

\end{itemize}

Мы уже знакомы с \verb|s/conformer|. Можно написать функцию, которая примет
кортеж и выполнит действия выше. Это несложно, но функция будет монолитом со
слишком большим \emph{скоупом}. Рассмотрим другой способ.

\index{spec!cat}

Спека \verb|s/cat| служит для разбора коллекций. Она принимает набор тегов и
других спек. На вход подают коллекцию, и \verb|s/cat| накладывает её элементы на
спеки. Если они совпали, получим словарь. Ключи словаря~--- это теги, а значения~---
вызов дочерней спеки с элементом.

Составим спеку для разбора кортежа. Начнём со статуса: спека ниже приводит
строки \verb|active| и \verb|pending| к особым кейвордам. Другие значения
спровоцируют ошибку.

\begin{english}
  \begin{clojure}
(s/def :user/status
  (s/and ->lower
         (with-conformer [val]
           (case val
             "active"  :USER_ACTIVE
             "pending" :USER_PENDING))))

(s/def ::user
  (s/cat :id ::->int
         :email ::email
         :status :user/status))
  \end{clojure}
\end{english}

\noindent
Положительный случай даёт на выходе словарь:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/conform ::user
  ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}
  \end{clojure}
\end{english}

\fi

Варианты с плохим номером, почтой или статусом не пройдут разбор. Примеры ниже
вернут \verb|::s/invalid|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/conform ::user
  ["" "test@test.com" "active"])
(s/conform ::user
  ["1" "@test.com" "active"])
(s/conform ::user
  ["1" "test@test.com" "unknown"])
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/conform ::user ["" "test@test.com" "active"])
(s/conform ::user ["1" "@test.com" "active"])
(s/conform ::user ["1" "test@test.com" "unknown"])
  \end{clojure}
\end{english}

\fi

\subsection{Условный разбор}

Представим, что работаем с устаревшим форматом данных. В нём условие: если
перед номером стоит метка blocked, пользователь заблокирован. Например:

\begin{english}
  \begin{text}
blocked;1;test@test.com;active
  \end{text}
\end{english}

Это усложняет задачу, ведь теперь кортеж состоит из трёх \emph{или} четырёх
элементов. Сдвигается семантика полей: первый элемент не только номер, но и флаг
блокировки. В старых данных, особенно финансовых, бывают и более странные
условия.

В императивных языках они порождают каскад \verb|if/else|. В Clojure проблему
решают декларативно. Объявим спеку блокировки, которая выводит флаг из строки:

\begin{english}
  \begin{clojure}
(s/def ::blocked
  (s/and
   ->lower
   (s/conformer (partial = "blocked"))))
  \end{clojure}
\end{english}

\index{spec!?}

Добавим её в итоговую \verb|s/cat|, но укажем, что она встречается ни разу
или только один раз. Для этого \verb|::blocked| оборачивают в спеку
\verb|s/?|.  В регулярных выражениях знак вопроса делает то же самое для
шаблона.

Мы уже писали спеки для вывода чисел и почты. Осталось собрать их в общую
композицию:

\begin{english}
  \begin{clojure}
(s/def ::user
  (s/cat :blocked (s/? ::blocked)
         :id ::->int
         :email ::email
         :status :user/status))
  \end{clojure}
\end{english}

Теперь оба кортежа совпадают со спекой \verb|::user|. Если метки нет, получим
словарь, как в начале. Если пользователь заблокирован, в~словаре будет поле
\verb|:blocked|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/conform ::user
  ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}

(s/conform ::user
  ["BLOCKED" "1"
   "test@test.com" "active"])
{:blocked true
 :id 1
 :email "test@test.com"
 :status ...}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1 :email "test@test.com" :status :USER_ACTIVE}

(s/conform ::user ["BLOCKED" "1" "test@test.com" "active"])
{:blocked true :id 1 :email "test@test.com" :status ...}
  \end{clojure}
\end{english}

\fi

Представим, что на входе коллекция кортежей. Чтобы не утруждать себя итерацией,
объявим спеку-коллекцию:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::users (s/coll-of ::user))

(def user-data
  [["1" "test@test.com" "active"]
   ["Blocked" "2" "joe@doe.com"
    "pending"]])

(s/conform ::users user-data)
[{:id 1
  :email "test@test.com"
  :status :USER_ACTIVE}
 {:blocked true
  :id 2
  :email "joe@doe.com"
  :status ...}]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::users (s/coll-of ::user))

(def user-data
  [["1" "test@test.com" "active"]
   ["Blocked" "2" "joe@doe.com" "pending"]])

(s/conform ::users user-data)
[{:id 1 :email "test@test.com" :status :USER_ACTIVE}
 {:blocked true :id 2 :email "joe@doe.com" :status ...}]
  \end{clojure}
\end{english}

\fi

\index{clojure.core!filter}
\index{clojure.core!complement}

Отсеем заблокированных пользователей с помощью \verb|filter| и предиката
\spverb|(complement :blocked)|

\subsection{Практика}

\index{форматы!INI}
\index{парсинг}

С помощью Spec парсят не только данные, но и текст. Рассмотрим, как прочитать
INI-файл в словарь данных. \footurl{INI}{https://en.wikipedia.org/wiki/INI\_file}[INI][-3mm]~---
это старый формат конфигурации. Он состоит из заголовков и пар полей и
значений. Пример условного \verb|config.ini|:

\begin{english}
  \begin{ini}
[database]
host=localhost
port=5432
user=test

[server]
host=127.0.0.1
port=8080
  \end{ini}
\end{english}

Наша цель~--- получить словарь, где на первом уровне заголовки, а~под ними поля
и значения.

\begin{english}
  \begin{clojure}
{:database {:host "localhost"
            :port 5432
            :user "test"}
 :server {:host "127.0.0.1"
          :port 8080}}
  \end{clojure}
\end{english}

Если отбросить пустые строки и комментарии, формат сводится к~грамматике
\verb|([title], (key=value)*)*|, где звёздочка означает сколько угодно раз, в
том числе ничего.

\index{clojure.core!doall}
\index{clojure.core!with-open}

Для начала прочитаем строки из файла. Спеки не должны иметь побочных эффектов,
поэтому чтение выносят в отдельный шаг. Функция \verb|line-seq| ленива: она
возвращает коллекцию строк, которая наполняется по мере обхода. Форма
\verb|doall| насильно перебирает её, чтобы считать все элементы. Без
\verb|doall| мы выйдем из макроса \verb|with-open| с~незаполненной
коллекцией, но файл уже будет закрыт.

\index{итерация!doall}

\index{clojure.core!doall}

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(defn get-ini-lines [path]
  (with-open [src (io/reader path)]
    (doall (line-seq src))))
  \end{clojure}
\end{english}

Переходим к парсеру. Это спека, которая принимает список строк. Алгоритм
следующий:

\begin{itemize}

\item
  удалить пустые строки и комментарии;

\item
  сгруппировать оставшиеся строки по заголовкам;

\item
  разбить поля и значения по знаку равенства;

\item
  построить вложенный словарь;

\item
  вывести типы и проверить результат.

\end{itemize}

Опишем спеку по принципу <<сверху вниз>>, словно все компоненты готовы. Ниже~---
композиция, которая решает задачу:

\begin{english}
  \begin{clojure}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   ::ini-config))
  \end{clojure}
\end{english}

\index{функции!clear-ini-lines}
\index{clojure.core!some-fn}

Перейдём к недостающим элементам. Функция \verb|clear-ini-lines| убирает
пустые строки и комментарии. В INI они начинаются с символа решётки.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn comment? [line]
  (str/starts-with? line "#"))

(defn clear-ini-lines [lines]
  (remove
    (some-fn comment? str/blank?) lines))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn comment? [line]
  (str/starts-with? line "#"))

(defn clear-ini-lines [lines]
  (remove (some-fn comment? str/blank?) lines))
  \end{clojure}
\end{english}

\fi

\index{spec!*}

Функция \verb|some-fn| объединяет несколько предикатов логикой <<любой
из>>. Спека \spverb|(s/* :ini/section)| читается как <<ноль и более
секций>>. Под секцией понимают заголовок и прилегающие поля и значения. Запишем
её в виде \verb|s/cat|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :ini/section
  (s/cat :title
    :ini/title :fields (s/* :ini/field)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :ini/section
  (s/cat :title :ini/title :fields (s/* :ini/field)))
  \end{clojure}
\end{english}

\fi

Объявим спеку \verb|:ini/title|. Она проверяет, что строка~--- это
заголовок. Согласно формату, заголовок пишут в квадратных скобках. Если первый и
последний символы~--- это скобки, отбросим их и вернём заголовок:

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (s/and
   #(str/starts-with? % "[")
   #(str/ends-with? % "]")
   (with-conformer [line]
     (subs line 1 (dec (count line))))))
  \end{clojure}
\end{english}

\noindent
То же самое с регулярным выражением:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (with-conformer [line]
    (or (second
         (re-matches #"^\[(.+)\]$" line))
        ::s/invalid)))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (with-conformer [line]
    (or (second (re-matches #"^\[(.+)\]$" line))
        ::s/invalid)))
  \end{clojure}
\end{english}

\fi

\index{алгоритмы!base64}

Спека \verb|:ini/field| парсит поле и значение. Строку разбивают по знаку
равенства. Цифра 2 означает, что в результате должно быть не более двух
элементов: ключ и значение. Это важно, потому что в~значении может быть знак
равенства, например если это base64-строка. Если не получили пару, сигналим об
ошибке.

\begin{english}
  \begin{clojure}
(s/def :ini/field
  (with-conformer [line]
    (let [pair (str/split line #"=" 2)]
      (if (= (count pair) 2)
        pair
        ::s/invalid))))
  \end{clojure}
\end{english}

Не терпится проверить нашу работу. Обернём черновую спеку в~функцию
\verb|parse-ini|, которая читает файл.

\begin{english}
  \begin{clojure}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)))

(defn parse-ini [path]
  (let [lines (get-ini-lines path)]
    (s/conform ::->ini-config lines)))
  \end{clojure}
\end{english}

\noindent
Пробный результат:

\begin{english}
  \begin{clojure}
(parse-ini "config.ini")

[{:title "database"
  :fields [["host" "localhost"]
           ["port" "5432"]
           ["user" "test"]]}
 {:title "server"
  :fields [["host" "127.0.0.1"]
           ["port" "8080"]]}]
  \end{clojure}
\end{english}

Разбор прошёл удачно, хотя структура отличается от той, что мы планировали. Это
неважно: мы вывели данные из текста, а привести словарь к нужному виду
легко. Напишем функцию \verb|remap-ini-data|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn remap-ini-data [data-old]
  (reduce
   (fn [data-new entry]
     (let [{:keys [title fields]} entry]
       (assoc data-new
         title (into {} fields))))
   {}
   data-old))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(defn remap-ini-data [data-old]
  (reduce
   (fn [data-new entry]
     (let [{:keys [title fields]} entry]
       (assoc data-new title (into {} fields))))
   {}
   data-old))
  \end{clojure}
\end{english}

\fi

\noindent
Если передать в неё вектор из последнего шага, получим словарь:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{"database" {"host" "localhost"
             "port" "5432"
             "user" "test"}
 "server" {"host" "127.0.0.1"
           "port" "8080"}}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{"database" {"host" "localhost" "port" "5432" "user" "test"}
 "server" {"host" "127.0.0.1" "port" "8080"}}
  \end{clojure}
\end{english}

\fi

Напишем спеку для вывода типов и проверки. Номера портов приводим к числам, хост
и пользователь~--- не пустые строки.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :db/host ::ne-string)
(s/def :db/port ::->int)
(s/def :db/user ::ne-string)

(s/def ::database
  (s/keys :req-un
    [:db/host :db/port :db/user]))

(s/def :server/host ::ne-string)
(s/def :server/port ::->int)

(s/def ::server
  (s/keys :req-un
    [:server/host :server/port]))

(s/def ::ini-config
  (s/keys :req-un [::database ::server]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :db/host ::ne-string)
(s/def :db/port ::->int)
(s/def :db/user ::ne-string)

(s/def ::database
  (s/keys :req-un [:db/host :db/port :db/user]))

(s/def :server/host ::ne-string)
(s/def :server/port ::->int)

(s/def ::server
  (s/keys :req-un [:server/host :server/port]))

(s/def ::ini-config
  (s/keys :req-un [::database ::server]))
  \end{clojure}
\end{english}

\fi

\index{модули!clojure.walk}
\index{функции!keywordize-keys}

Последний штрих~--- исправить тип ключей в словаре. В настоящий момент это
строки, но спека \verb|::ini-config| ожидает кейворды. Модуль
\verb|clojure.walk| предлагает функцию \verb|keywordize-keys| на этот
случай. Она обходит словарь любой вложенности и меняет ключи. Итоговая спека:

\begin{english}
  \begin{clojure}
(require '[clojure.walk :as walk])

(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   (s/conformer walk/keywordize-keys)
   ::ini-config))
  \end{clojure}
\end{english}

\noindent
Результат:

\begin{english}
  \begin{clojure}
(parse-ini "config.ini")

{:database {:host "localhost"
            :port 5432
            :user "test"}
 :server {:host "127.0.0.1"
          :port 8080}}
  \end{clojure}
\end{english}

Получились аккуратные данные из текста. Обратите внимание, что в коде нет
состояния и в целом он выглядит как цепочка шагов. Каждый шаг легко исправить
или добавить новый между ними.

Устраните мелкие недостатки в коде. Пусть пара \verb|"foo="| становится
\verb|{:foo nil}|, а не \spverb|{:foo ""}|.  Удалите пустые символы из
имён полей и~значений. Опробуйте код на больших INI-файлах.

\section{Разбор кода (теория)}

\index{парсинг}
\index{макросы}

В завершение темы поговорим о том, как парсить код. Мы уже видели, что Spec
подходит для разбора коллекций. Код на Clojure состоит из списков. Это приводит
к неожиданному решению: код можно проверить спекой и вернуть ошибку до того, как
он запущен.

Проверку удобно делать в макросах. Это особые функции, которые работают на этапе
компиляции. Макрос принимает код в виде списка символов. В коде могут быть
ошибки, но макрос об этом ничего не знает: для него это просто символы.

Задача макроса в том, чтобы перестроить список в другой, понятный
Clojure. Компилятор заменит вызов макроса на то, что он вернул, и запустит
код. Макросы~--- это отдельная веха в изучении Clojure. Пока что рассмотрим, как
проверить макрос спекой.

Каждый макрос~--- это мини-язык с соглашением о том, что подавать на вход. В простых
случаях код парсят функциями \verb|first|, \verb|rest| и условиями. Сложные
макросы разбирают грамматиками, как мы делали это с INI-файлом. Если код
нарушает правила, мы должны объяснить, в чём ошибка.

Иногда один и тот же макрос допускает разные записи. Хорошим примером служит
\verb|defn|~--- определение функции. Кроме обязательных параметров он принимает
дополнительные: строку документации, пре- и постпроверки. У функции может быть
несколько тел:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(defn my-inc
  [x]
  (+ x 1))
  \end{clojure}

\splitter

  \begin{clojure}
(defn my-inc
  "Increase the number."
  [x]
  {:pre [(int? x)]
   :post [(int? %)]}
  (+ x 1))
  \end{clojure}

\splitter

  \begin{clojure}
(defn my-inc
  ([x]
   (my-inc x 1))
  ([x delta]
   (+ x delta)))
  \end{clojure}
\end{english}

\else

\begin{english}

\noindent
\begin{tabular}{ @{}p{2.5cm} @{}p{4.5cm} @{}p{3cm} }

  \begin{clojure}
(defn my-inc
  [x]
  (+ x 1))
  \end{clojure}

&

  \begin{clojure}
(defn my-inc
  "Increase the number."
  [x]
  {:pre [(int? x)]
   :post [(int? %)]}
  (+ x 1))
  \end{clojure}

&

  \begin{clojure}
(defn my-inc
  ([x]
   (my-inc x 1))
  ([x delta]
   (+ x delta)))
  \end{clojure}

\end{tabular}

\end{english}

\fi

Это одна и та же функция, записанная по-разному. Очевидно, разобрать все
варианты вручную тяжело. До версии Clojure 1.10 каждый макрос парсил код как
придётся. Это было неорганизованно. С выходом Spec основные макросы перешли на
спеку. Появился общий подход, которым легко управлять.

\index{spec!cat}

Разберём устно, как бы мы построили спеку для разбора \verb|defn|. Это список,
поэтому на верхнем уровне поместим \verb|s/cat|. Первый его элемент~--- символ
\verb|defn|, второй~--- символ с именем функции. После имени следует строка
документации (её может и не быть). Далее~--- тело или список тел. Набросаем
черновик:

\begin{english}
  \begin{clojure}
(s/def ::defn
  (s/cat :tag #{'defn}
         :name symbol?
         :doc (s/? string?)
         :body ...))
  \end{clojure}
\end{english}

Что скрывается за ключом \verb|:body|, пока неизвестно. Проблема в том, что
\verb|defn| принимает либо одно тело, либо их список. Сравните первый и третий
столбики в примере с \verb|my-inc|.

Для начала напишем спеку обычного тела. Считаем, что тело начинается с вектора
параметров. После него идёт опциональный словарь пре- и постпроверок. Затем
произвольные формы, из которых состоит тело функции.

\begin{english}
  \begin{clojure}
(s/def :defn/body
  (s/cat :args vector?
         :prepost (s/? map?)
         :code (s/* any?)))
  \end{clojure}
\end{english}

Теперь обернём спеку \verb|:defn/body| так, чтобы она учитывала оба
случая: одно тело и несколько. Обозначим её звёздочкой. Поскольку
\verb|:defn/body|~--- это \verb|regex|-спека, сгруппируем её с помощью
\verb|s/spec|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def :defn/body*
  (s/alt :single :defn/body
         :multi (s/+
                  (s/spec :defn/body))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def :defn/body*
  (s/alt :single :defn/body
         :multi (s/+ (s/spec :defn/body))))
  \end{clojure}
\end{english}

\fi

\index{синтаксис!\textquotesingle{ }(заморозка)}

Подготовим данные для спеки. Это список, который повторяет выражение
\verb|defn|. Он состоит из примитивов~--- символов, чисел, строк~--- и вложенных
коллекций. Список можно составить комбинацией \verb|list| и~экранированных
символов. Выражение \verb|'something| не вычисляет символ за апострофом,
а~только возвращает его. Эту запись называют квотированием \eng{quote} или
заморозкой. На жаргоне программистов говорят <<заквотить символ>>.

\begin{english}
  \begin{clojure}
(def defn-expr
  (list 'defn 'my-inc
        "Increase a number"
        ['x]
        {:pre [(list 'int? 'x)]} ...))
  \end{clojure}
\end{english}

Если выполнить \verb|defn-expr| в REPL, увидим код в том виде, в каком он
выглядел бы в редакторе. Однако из-за частых \verb|list| и апострофов код
получился шумный, и в нём легко допустить ошибку. Для краткости заморозим не
отдельные символы, а выражение \verb|defn| целиком. Так мы сохраним оригинальный
синтаксис:

\begin{english}
  \begin{clojure}
(def defn-expr
  '(defn my-inc
     "Increase a number"
     [x]
     {:pre [(int? x)]
      :post [(int? %)]}
     (+ x 1)))
  \end{clojure}
\end{english}

Заметим, что во внутреннем \verb|defn| могут быть какие угодно ошибки, но мы
о~них не узнаем. С точки зрения Clojure это список символов без всякой
семантики. Для этого мы и пишем спеку~--- убедиться, что у~списка правильная
структура. Распарсим его:

\begin{english}
  \begin{clojure}
(s/conform ::defn defn-expr)
  \end{clojure}
\end{english}

\noindent
Результат:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
{:tag defn
 :name my-inc
 :doc "Increase a number"
 :body
 [:single
  {:args [x]
   :prepost {:pre [(int? x)]
             :post [(int? %)]}
   :code [(+ x 1)]}]}
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
{:tag defn
 :name my-inc
 :doc "Increase a number"
 :body
 [:single
  {:args [x]
   :prepost {:pre [(int? x)] :post [(int? %)]}
   :code [(+ x 1)]}]}
  \end{clojure}
\end{english}

\fi

Обратите внимание на поле \verb|:body|. Это вектор из метки и результата. Для
одного тела получим метку \verb|:single| и словарь. Для нескольких тел метка
будет \verb|:multi|, а значение~--- вектор словарей:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
[:multi [{:args [x]
          :code [(println 1)]}
         {:args [x y]
          :code [(println 2)]}]]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
[:multi [{:args [x] :code [(println 1)]}
         {:args [x y] :code [(println 2)]}]]
  \end{clojure}
\end{english}

\fi

Чтобы проверить метку (одно тело или несколько), пригодится оператор
\verb|case|. Ниже в переменой \verb|result| записан результат
парсинга. Функция \verb|process-body| обрабатывает словарь тела:

\begin{english}
  \begin{clojure}
(let [{:keys [body]} result
      [tag body] body]
  (case tag
    :single
    (process-body body)
    :multi
    (doseq [body body]
      (process-body body))))
  \end{clojure}
\end{english}

\subsection{Самостоятельная работа}

\index{сообщения}

Каждый уровень спеки расширяется вглубь. Доработаем аргументы функции: разделим
их на обязательные и остаточные. Например, чтобы параметры \verb|[x y & other]|
предстали в виде словаря:

\begin{english}
  \begin{clojure}
{:req [x y] :opt other}
  \end{clojure}
\end{english}

\noindent
По аналогии разберите словари пре- и постпроверок.

Передайте в спеку данные с ошибками. Что делать в таком случае? Как составить
\emph{понятное} сообщение о том, где именно ошибка и чего вы ожидали? Подойдёт ли
словарь переводов? Получится ли у вас сделать ошибки лучше, чем в промышленных
языках?

Данные, которые вернула спека-парсер, называются \emph{абстрактным синтаксическим деревом}
(англ.~abstract syntax tree, \footurl{AST}{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}[AST][-2mm]).
Это вложенная структура, которую получают из текста. AST~--- важный этап в~исполнении
программы. Только построив дерево, можно выполнить логику, которая за ним стоит.

\index{интерпретатор}

Spec работает в том числе как парсер грамматик: можно разобрать данные и
построить дерево. Вы в шаге от того, чтобы написать простой интерпретатор~---
программу, которая читает код и выполняет его. Узлы дерева~--- это функции, а
потомки~--- аргументы или другие функции. Напишите обход дерева и его
вычисление. Даже если это курсовая работа, простой интерпретатор улучшит ваши
навыки.

\section{Спецификация функций}

\index{spec!функции}

Проблема валидации касается и функций. Они получают данные от посредников, и
всегда есть шанс, что в них ошибка. Вспомним функцию с диапазоном дат. Если
поменять их местами (начало больше конца), проверки на интервал вернут
ложь. Здесь и пригодится спека.

Опишем параметры функции. Это \verb|s/cat|, которая <<откусывает>>
от~аргументов даты и помещает в словарь с ключами \verb|:start| и
\verb|:end|.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/def ::date-range-args
  (s/and
    ;; parse args
    (s/cat :start inst? :end inst?)
    ;; compare args
    (fn [{:keys [start end]}]
      (<= (compare start end) 0))))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/def ::date-range-args
  (s/and
   (s/cat :start inst? :end inst?) ;; parse args
   (fn [{:keys [start end]}]       ;; compare args
     (<= (compare start end) 0))))
  \end{clojure}
\end{english}

\fi

\index{clojure.core!compare}

Вторая функция в \verb|s/and| принимает словарь и сравнивает даты. Для дат
используют функцию \verb|compare|, которая вернёт -1, 0 и 1 для случаев
<<меньше>>, <<равно>> и <<больше>>. Быстрая проверка:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(s/valid? ::date-range-args
          [#inst "2019" #inst "2020"])
;; true

(s/valid? ::date-range-args
          [#inst "2020" #inst "2019"])
;; false
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(s/valid? ::date-range-args
          [#inst "2019" #inst "2020"]) ;; true

(s/valid? ::date-range-args
          [#inst "2020" #inst "2019"]) ;; false
  \end{clojure}
\end{english}

\fi

\index{декораторы}

Напрашивается декоратор, который принимает функцию и спеку. Перед тем как
запустить функцию, он проверяет аргументы и в случае ошибки бросит исключение. То
же самое проделаем с результатом.

\index{модули!clojure.spec.test.alpha}
\index{функции!instrument}

Писать декоратор не нужно, потому что его включили в Spec. Это функция
\verb|instrument| из модуля \verb|clojure.spec.test.alpha|
(англ.~instru\-ment~--- <<оснастить, оборудовать>>). Обратите внимание на пространство:
в него закралась частичка test. Оснащение функций вынесли в отдельный
модуль.

\index{monkey patch}

\verb|Instrument| принимает символ функции, которую <<заряжают>>. Таким же
символом задают спеку для функции. \verb|Instrument| подменяет функцию на
такую же, но с проверками. Это своего рода \footurl{monkey patch}{https://en.wikipedia.org/wiki/Monkey\_patch}[Monkey patch][-3mm], когда один модуль изменяет другой. Функциональную спеку объявляют макросом \verb|s/fdef|.
Ему передают символ функции и спеки входящих параметров, результата и их композиции.

\index{даты}
\index{классы!Date}

Напишем функцию и спеку к ней. Пусть функция считает разницу между датами в
секундах. Если первая дата больше второй, результат отрицательный.

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(import 'java.util.Date)

(defn date-range-sec
  "Return the difference
           between two dates in seconds."
  [^Date date1 ^Date date2]
  (quot (- (.getTime date2)
           (.getTime date1))
        1000))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(import 'java.util.Date)

(defn date-range-sec
  "Return the difference between two dates in seconds."
  [^Date date1 ^Date date2]
  (quot (- (.getTime date2)
           (.getTime date1))
        1000))
  \end{clojure}
\end{english}

\fi

Теги \verb|^Date| нужны, чтобы компилятор знал тип объектов \verb|date1| и
\verb|date2|. Если тега нет, Clojure находит тип во время исполнения
рефлексией, что медленней. Посчитаем разницу в сутках:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(date-range-sec #inst "2019-01-01"
                #inst "2019-01-02")
86400
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(date-range-sec #inst "2019-01-01" #inst "2019-01-02")
86400
  \end{clojure}
\end{english}

\fi

\noindent
Если поменять даты местами, получим то же число с минусом.

Опишем функциональную спеку с символом \verb|date-range-sec|. В~ключе
\verb|:args| указывают спеку входящих параметров. Это список, поэтому пригодится
\verb|s/cat|. Он разбивает список на словарь, чтобы спеки ниже работали с
ключами.

Ключ \verb|:ret| означает спеку результата. Чаще всего это проверка на число или
строку: \verb|int?|, \verb|string?| или их \verb|nilable|-версии, которые
допускают \verb|nil|: \verb|(s/nilable int?)| и так далее.

\index{spec!fdef}

\begin{english}
  \begin{clojure}
(s/fdef date-range-sec
  :args (s/cat :start inst? :end inst?)
  :ret int?)
  \end{clojure}
\end{english}

В ключи \verb|:args| и \verb|:ret| можно передать готовые спеки, что полезно
для повторного использования. У вас может быть несколько спек для диапазона дат.

При создании функциональная спека не меняет функцию. Она только объявляет
проверки, но не запускает их. Чтобы подменить функцию на её оснащенную версию,
вызывают \verb|instrument|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require '[clojure.spec.test.alpha
           :refer [instrument]])
(instrument `date-range-sec)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.spec.test.alpha :refer [instrument]])
(instrument `date-range-sec)
  \end{clojure}
\end{english}

\fi

\index{синтаксис!\textasciigrave{ }(заморозка)}

Символ функции должен быть полным (с пространством). Чтобы подставить в символ
текущее пространство, перед ним ставят обратную кавычку \verb|`|.

Теперь \verb|date-range-sec| проверит аргументы и результат. Что случится,
если передать в <<заряженную>> функцию не тот аргумент? Получим исключение
\verb|ExceptionInfo|:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(date-range-sec nil #inst "2019")
;; Execution error - invalid arguments
;; to date-range-sec
;; nil - failed: inst? at: [:start]
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(date-range-sec nil #inst "2019")
;; Execution error - invalid arguments to date-range-sec
;; nil - failed: inst? at: [:start]
  \end{clojure}
\end{english}

\fi

\index{spec!explain}
\index{отчёт!explain}

Сообщение и тело нам знакомы. В поле \verb|message| текст из функции
\verb|s/explain-str|. В поле \verb|data| отчёт из
\verb|s/explain-data|. Чтобы добраться до него, передайте исключение в функцию
\verb|(ex-data e)|.

\subsection{Документация}

\index{документация}
\index{модули!clojure.repl}

Функциональная спека улучшает документацию. Функция \verb|doc| из модуля
\verb|clojure.repl| выводит справку о запрошенной функции. С появлением Spec
её поведение изменилось: кроме документации она выводит спеку, если её
задали. Вот как выглядит справка для \verb|date-range-sec| после того, как
объявили спеку:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(clojure.repl/doc date-range-sec)
-------------------------
([date1 date2])
  Return the difference
            between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(clojure.repl/doc date-range-sec)
-------------------------
([date1 date2])
  Return the difference between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
  \end{clojure}
\end{english}

\fi

\index{библиотеки!Autodoc}

На функцию \verb|doc| полагаются IDE и редакторы, чтобы подсказывать аргументы
в коде. Утилита для сборки документации \footurl{Autodoc}{https://github.com/tomfaulhaber/autodoc}[Autodoc][-3mm]
добавляет спеки в HTML-файлы.

\subsection{Производительность}

\index{производительность}

\verb|Instrument| помогает в тестировании. На время тестов функции
<<заряжают>>, чтобы выявить ошибки. Это делают с помощью модуля, который
выполняет серию \verb|(instrument ...)| при загрузке. Проект устроен так, что
модуль загружается только на время тестов. Если функция получила не те
аргументы, это станет заметно.

\index{бенчмарк}

\verb|Instrument| не подходит для боевого режима, потому что замедляет
код. Напишем бенчмарк, который вызывает функцию много раз:

\index{clojure.core!time}

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019"
                   #inst "2020")))
;; Elapsed time: 1.783962 msecs
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
;; Elapsed time: 1.783962 msecs
  \end{clojure}
\end{english}

\fi

\noindent
То же самое после оснащения:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019"
                   #inst "2020")))
;; Elapsed time: 116.984496 msecs
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
;; Elapsed time: 116.984496 msecs
  \end{clojure}
\end{english}

\fi

\index{тесты}

Разница в сто раз! Проверка \emph{существенно} замедляет приложение. Вот почему
\verb|instrument| не претендует на запуск в бою: это слишком дорогая
цена. Однако в тестах нас не волнует скорость. На время прогона код покрывают
как можно б\'{о}льшим числом проверок, чтобы поймать все ошибки.

\section{Повторное использование спек}

\index{повторное использование}
\index{библиотеки!JDBC}

В Clojure принято снабжать библиотеки спеками, чтобы помочь другим
разработчикам. Если библиотека активно работает с какой-то структурой данных,
опишите её спекой. Хорошим примером служит
\footurl{JDBC}{https://github.com/clojure/java.jdbc}[JDBC][-7mm], обёртка для реляционных
баз данных.

Подключение к базе задают словарём с ключами \verb|:host|, \verb|:port|,
\verb|:user| и другими. Обычно словарь читают из конфигурации. Перед
подключением его нужно проверить, чтобы не получить \verb|NPE| и другие
странности.

\index{NPE}

Предположим, конфигурация описана в ресурсе EDN. Поле \verb|:db| задаёт
подключение к базе.

\index{форматы!EDN}

\begin{english}
  \begin{clojure}
{:db {:dbtype "mysql"
      :host "127.0.0.1"
      :port 3306
      :dbname "project"
      :user "user"}}
  \end{clojure}
\end{english}

Ключи \verb|:dbtype|, \verb|:host| и другие уже описаны в библиотеке. Один
из модулей JDBC несёт спеки подключения и основных функций. Используем их
повторно:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(require
  '[clojure.java.jdbc.spec :as jdbc])
(s/def ::db ::jdbc/db-spec)
(s/def ::config (s/keys :req-un [::db]))
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(require '[clojure.java.jdbc.spec :as jdbc])
(s/def ::db ::jdbc/db-spec)
(s/def ::config (s/keys :req-un [::db]))
  \end{clojure}
\end{english}

\fi

\noindent
Прочитаем конфигурацию из файла и проверим спекой:

\ifx\devicetype\mobile

\begin{english}
  \begin{clojure}
(def config
  (read-string (slurp "config.edn")))
(s/valid? ::config config)
  \end{clojure}
\end{english}

\else

\begin{english}
  \begin{clojure}
(def config (read-string (slurp "config.edn")))
(s/valid? ::config config)
  \end{clojure}
\end{english}

\fi

\label{jdbc-conform-warning}

\index{spec!or}

Будьте внимательны с \verb|::jdbc/db-spec|: это сложная спека с макросами
\verb|s/or|, которые порождают развилки. Если передать её в
\verb|s/conform|, получим поля с тегами (строки 3, 4, 6):

\begin{english}
  \begin{clojure/lines}
(s/conform ::config config)
{:db
 [:friendly
  {:dbtype   [:name "mysql"]
   :host     "127.0.0.1"
   :port     [:port 3306]
   :dbname   "project"
   :user     "user"
   :password "********"}]}
  \end{clojure/lines}
\end{english}

Результат не работает с \verb|jdbc/query| и другими функциями JDBC. Мы
ограничились \verb|s/valid?|, чтобы оставить структуру прежней.

Иногда спеки выносят в отдельную библиотеку. Так поступили разработчики
\footurl{Alia}{https://github.com/mpenet/alia}[Alia][-2mm]~--- клиента для БД
Cassandra. Проект \verb|qbits.alia| содержит основные функции для работы с
базой. Спеки идут в пакете \verb|cc.qbits/alia-spec|, который подключают
отдельно.

\section{Дополнения}

Spec входит в поставку Clojure и поэтому меняется не так часто, как хотелось бы
разработчикам. Дополнения к Spec выпускают в виде библиотек. Среди прочих
заслуживают внимания Expound и Spec.tools. Коротко опишем возможности каждой.

\index{библиотеки!Expound}

Библиотека \footurl{Expound}{https://github.com/bhb/expound}[Expound] улучшает сообщения об
ошибках. Сигнатура функции \verb|expound| аналогична \verb|s/explain|: она
тоже принимает спеку и~данные. Новое сообщение об ошибке выглядит так:

\index{spec!ошибки}
\index{сообщения}

\begin{english}
  \begin{clojure}
(expound/expound string? 1)
-- Spec failed --------------------
  1
should satisfy
  string?
-------------------------
Detected 1 error
  \end{clojure}
\end{english}

\index{spec!explain}

Это всё ещё машинный текст, который нельзя показывать пользователю. Всё же
он лучше, чем сырой \verb|s/explain|: его прочтут инженеры, которые не знают
Clojure. \verb|Expound| подойдёт для проверки конфигурации на старте
приложения. Конфигурацию обновляют часто, поэтому внятный отчёт об ошибке
полезен.

\index{организации!Metosin}
\index{библиотеки!Spec.tools}
\index{веб-разработка!Swagger}
\index{веб-разработка!REST}

Разработчики Metosin собрали улучшения для Spec в проекте
\footurl{Spec.tools}{https://github.com/metosin/spec-tools}[Spec tools]. В сердце библиотеки
лежит объект \verb|Spec|. Он оборачивает стандартную спеку и дополняет её
новыми методами. С помощью Spec.tools формируют JSON-схему и описывают REST
API по стандарту Swagger. Библиотека играет роль посредника между
REST-фреймворком и спекой.

\section{Будущее спеки}

\index{библиотеки!Schema}
\index{библиотеки!Bouncer}

На сегодняшний день пакет Spec всё ещё не избавился от частички
alpha в названии. Авторы экспериментируют со спекой, ищут лучшие способы
валидации. Это смущает некоторых разработчиков: опасаясь, что по окончании
эксперимента от Spec избавятся, они используют другие решения:
\footurl{Schema}{https://github.com/plumatic/schema}[Schema][-27mm],
\footurl{Bouncer}{https://github.com/leonardoborges/bouncer}[Bouncer][-4mm] и другие.

Отдельные группы пишут обёртки над спекой, чтобы расширить её
возможности. Например, подружить с JSON-схемой и инструментами вроде
Swagger. Это путь Spec.tools, которую мы рассмотрели.

\index{люди!Рич Хикки}
\index{видео!Maybe Not}

В докладе \footurl{Maybe Not}{https://youtube.com/watch?v=YR5WdGrpoug}[Maybe\\*Not] Рич
Хикки анонсировал вторую версию Spec. В ней упростят работу со словарями (спека
\verb|select|) и множественными типами (когда значение~--- строка или
число). Разработка идёт в~открытом режиме, но ещё рано говорить о
результатах. Обсуждение второй спеки выходит за рамки главы.

\section{Заключение}

Spec~--- это библиотека Clojure, которая идёт в поставке с языком. Spec предлагает
набор функций и макросов. Ими описывают правила, которым подчиняются
данные. Правила~--- это предикаты~--- функции, которые возвращают истину или ложь.

Предикаты гибче и мощнее типов. Если известно, что значение верного типа, это не
гарантирует корректности. Классы вроде \verb|UnixPort|~--- это не типы, а
валидация в рантайме. Она привязана к вызову класса с помощью синтаксиса.

В отличие от классов, предикаты компонуются друг с другом. Легко составить
предикат с логикой <<каждый из>>, <<любой из>> и другие.

Библиотека выводит новые данные из старых. Функция \verb|s/conform|
оборачивает другую функцию для вывода значения. Этим пользуются для вывода чисел
и дат из строк.

Spec предлагает regex-спеки, похожие на регулярные выражения. От~обычных спек
они отличаются тем, что захватывают часть коллекции. На regex-спеках пишут
парсеры данных, в том числе для самой Clojure. Основные макросы проверяют тело с
помощью Spec.

Библиотека полезна в тестах. Функция \verb|instrument| изменяет другую функцию
так, что её аргументы проверяются спекой. Это замедляет вызов, но делает тесты
надёжней. Функциональная спека становится частью документации.

Spec не предлагает решения для сообщений об ошибках. Как их~строить и показывать
клиенту, зависит от проекта. Один из подходов основан на словаре, где ключи~---
спеки, а значения~--- текст ошибки или тег перевода. Если заменить словарь на
мультиметод, потребителям будет проще расширить его.

Мы рассмотрели основные возможности библиотеки. В обсуждение не попали
генераторы, мультиспеки и другие интересные вещи. Всё это читатель найдёт в
официальной документации. Не прощаемся со спекой~--- в следующих главах мы
вернёмся к ней.
